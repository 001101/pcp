<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type"><title>Chapter 4. Trace PMDA</title><meta name="generator" content="DocBook XSL Stylesheets V1.51.1"><meta name="generator" content="SGI XSL DocBook Customization Stylesheets V1.1"><link rel="home" href="index.html" title="Performance Co-Pilot&#8482; Programmer's Guide"><link rel="up" href="index.html" title="Performance Co-Pilot&#8482; Programmer's Guide"><link rel="previous" href="ch03.html" title="Chapter 3. PMAPI--The Performance Metrics API"><link rel="next" href="apa.html" title="Appendix A. Acronyms"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 4. Trace PMDA</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="apa.html">Next</a></td></tr></table><hr></div><!--CONTENT_BEGIN--><a name="sgi_start_content"></a><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="LE25915-PARENT"></a>Chapter 4. Trace PMDA</h2></div></div>
<p><a class="indexterm" name="IG31340177462"></a><a class="indexterm" name="IG31340177463"></a>This chapter provides an introduction to the design of the trace Performance Metrics Domain Agent (PMDA), in an effort to explain how to configure the agent optimally for a particular problem domain. This information supplements the functional coverage which the man pages provide to both the agent and the library interfaces.</p>
<p> <a class="indexterm" name="IG31340177464"></a><a class="indexterm" name="IG31340177465"></a> The chapter also includes information on how to use the trace PMDA and the associated library (<tt>libpcp_trace</tt>) for instrumenting applications. The example programs in IRIX are installed in <tt>/var/pcp/demos/trace</tt> from the <tt>pcp.sw.trace</tt> subsystem. On Linux, the trace PMDA exists in the <tt>pcp-2.3-<i>rev</i></tt> package at <tt>/usr/share/pcp/demo/trace</tt>.</p>
<div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5213106"></a>4.1. Performance Instrumentation and Tracing</h2></div></div>
<p><a class="indexterm" name="IG31340177466"></a><a class="indexterm" name="IG31340177467"></a><a class="indexterm" name="IG31340177468"></a>The <tt>pcp_trace</tt> library provides function calls for identifying sections of a program as transactions or events for examination by the trace PMDA, a user command called <tt>pmdatrace</tt>. The <tt>pcp_trace</tt> library is described in the <tt>pmdatrace(3)</tt> man page</p>
<p>The monitoring of transactions using the Performance Co-Pilot (PCP) infrastructure begins with a <tt>pmtracebegin</tt> call. Time is recorded from there to the corresponding <tt>pmtraceend</tt> call (with matching tag identifier). A transaction in progress can be cancelled by calling <tt>pmtraceabort</tt>.</p>
<p>A second form of program instrumentation is available with the <tt>pmtracepoint</tt> function. This is a simpler form of monitoring that exports only the number of times a particular point in a program is passed. The <tt>pmtraceobs</tt> and pmtracecount functions have similar semantics, but allows an arbitrary numeric value to be passed to the trace PMDA.</p>
<p><a class="indexterm" name="IG31340177469"></a>The <tt>pmdatrace</tt> command is a PMDA that exports transaction performance metrics from application processes using the <tt>pcp_trace</tt> library; see the <tt>pmdatrace(1)</tt> man page for details.</p>
<p>For a complete introduction to performance tracing, refer to the Web-based <i>PCP Tutorial</i>, which contains the <tt>trace.html</tt> file covering this topic.</p>
</div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5213287"></a>4.2. Trace PMDA Design</h2></div></div>
<p><a class="indexterm" name="IG31340177470"></a>Trace PMDA design covers application interaction, sampling techniques, and configuring the trace PMDA.</p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5213308"></a>4.2.1. Application Interaction</h3></div></div>
<p><a class="indexterm" name="IG31340177471"></a><a href="ch04.html#id5213335" title="Figure 4-1. Trace PMDA Overview">Figure 4-1</a> describes the general state maintained within the trace PMDA.</p>
<p><div class="figure"><a name="id5213335"></a><p><a name="id5213335"></a><b>Figure 4-1. Trace PMDA Overview</b></p>
<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/trace_1.gif" alt="Trace PMDA Overview" height="414" width="526"></td></tr></table></div></div><br></p>
<p><a class="indexterm" name="IG31340177472"></a> <a class="indexterm" name="IG31340177473"></a> <a class="indexterm" name="IG31340177474"></a>Applications that are linked with the <tt>libpcp_trace</tt> library make calls through the trace Application Programming Interface (API). These calls result in interprocess communication of trace data between the application and the trace PMDA. This data consists of an identification tag and the performance data associated with that particular tag. The trace PMDA aggregates the incoming information and periodically updates the exported summary information to describe activity in the recent past.</p>
<p><a class="indexterm" name="IG31340177475"></a> <a class="indexterm" name="IG31340177476"></a>As each protocol data unit (PDU) is received, its data is stored in the current working buffer. At the same time, the global counter associated with the particular tag contained within the PDU is incremented. The working buffer contains all performance data that has arrived since the previous time interval elapsed. For additional information about the working buffer, see <a href="ch04.html#LE42586-PARENT" title="4.2.2.2. Rolling-Window Periodic Sampling">Section 4.2.2.2</a>.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5213449"></a>4.2.2. Sampling Techniques</h3></div></div>
<p><a class="indexterm" name="IG31340177477"></a> <a class="indexterm" name="IG31340177478"></a>The trace PMDA employs a rolling-window periodic sampling technique. The arrival time of the data at the trace PMDA in conjunction with the length of the sampling period being maintained by the PMDA determines the recency of the data exported by the PMDA. Through the use of rolling-window sampling, the trace PMDA is able to present a more accurate representation of the available trace data at any given time than it could through use of simple periodic sampling.</p>
<p> <a class="indexterm" name="IG31340177479"></a> <a class="indexterm" name="IG31340177480"></a> <a class="indexterm" name="IG31340177481"></a> <a class="indexterm" name="IG31340177482"></a> <a class="indexterm" name="IG31340177483"></a> <a class="indexterm" name="IG31340177484"></a>The rolling-window sampling technique affects the metrics in <a href="ch04.html#Z976568222sdc" title="Example 4-1. Rolling-Window Sampling Technique">Example 4-1</a>:</p>
<div class="example"><a name="Z976568222sdc"></a><p><a name="Z976568222sdc"></a><b>Example 4-1. Rolling-Window Sampling Technique</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">trace.observe.rate
trace.counter.rate
trace.point.rate
trace.transact.ave_time
trace.transact.max_time
trace.transact.min_time
trace.transact.rate</pre></td></tr></table><br></div><p>The remaining metrics are either global counters, control metrics, or the last seen observation value. <a href="ch04.html#LE26087-PARENT" title="4.3. Trace API">Section 4.3</a>, documents in more detail all metrics exported by the trace PMDA.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5213576"></a>4.2.2.1. Simple Periodic Sampling</h4></div></div>
<p><a class="indexterm" name="IG31340177485"></a><a class="indexterm" name="IG31340177486"></a> <a class="indexterm" name="IG31340177487"></a>The simple periodic sampling technique uses a single historical buffer to store the history of events that have occurred over the sampling interval. As events occur, they are recorded in the working buffer. At the end of each sampling interval, the working buffer (which at that time holds the historical data for the sampling interval just finished) is copied into the historical buffer, and the working buffer is cleared. It is ready to hold new events from the sampling interval now starting.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="LE42586-PARENT"></a>4.2.2.2. Rolling-Window Periodic Sampling</h4></div></div>
<p><a class="indexterm" name="IG31340177488"></a>In contrast to simple periodic sampling with its single historical buffer, the rolling-window periodic sampling technique maintains a number of separate buffers. One buffer is marked as the current working buffer, and the remainder of the buffers hold historical data. As each event occurs, the current working buffer is updated to reflect it.</p>
<p>At a specified interval, the current working buffer and the accumulated data that it holds is moved into the set of historical buffers, and a new working buffer is used. The specified interval is a function of the number of historical buffers maintained.</p>
<p>The primary advantage of the rolling-window sampling technique is seen at the point where data is actually exported. At this point, the data has a higher probability of reflecting a more recent sampling period than the data exported using simple periodic sampling.</p>
<p><a class="indexterm" name="IG31340177489"></a>The data collected over each sample duration and exported using the rolling-window sampling technique provides a more up-to-date representation of the activity during the most recently completed sample duration than simple periodic sampling as shown in <a href="ch04.html#id5213739" title="Figure 4-2. Sample Duration Comparison">Figure 4-2</a>.</p>
<p><div class="figure"><a name="id5213739"></a><p><a name="id5213739"></a><b>Figure 4-2. Sample Duration Comparison</b></p>
<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/trace_buffer.gif" alt="Sample Duration Comparison" height="373" width="472"></td></tr></table></div></div><br></p>
<p><a class="indexterm" name="IG31340177490"></a>The trace PMDA allows the length of the sample duration to be configured, as well as the number of historical buffers that are maintained. The rolling-window approach is implemented in the trace PMDA as a ring buffer (see <a href="ch04.html#id5213335" title="Figure 4-1. Trace PMDA Overview">Figure 4-1</a>).</p>
<p><a class="indexterm" name="IG31340177491"></a> <a class="indexterm" name="IG31340177492"></a>When the current working buffer is moved into the set of historical buffers, the least recent historical buffer is cleared of data and becomes the new working buffer.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5213803"></a>4.2.2.3. Rolling-Window Periodic Sampling Example</h4></div></div>
<p><a class="indexterm" name="IG31340177493"></a>Consider the scenario where you want to know the rate of transactions over the last 10 seconds. You set the sampling rate for the trace PMDA to 10 seconds and fetch the metric <tt>trace.transact.rate</tt>. So if in the last 10 seconds, 8 transactions took place, the transaction rate would be 8/10 or 0.8 transactions per second.</p>
<p>The trace PMDA does not actually do this. It instead does its calculations automatically at a subinterval of the sampling interval. Reconsider the 10-second scenario. It has a calculation subinterval of 2 seconds as shown in <a href="ch04.html#id5213848" title="Figure 4-3. Sampling Intervals">Figure 4-3</a>.</p>
<p><div class="figure"><a name="id5213848"></a><p><a name="id5213848"></a><b>Figure 4-3. Sampling Intervals</b></p>
<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/trace_example.gif" alt="Sampling Intervals" height="384" width="535"></td></tr></table></div></div><br></p>
<p>If at 13.5 seconds, you request the transaction rate, you receive a value of 0.7 transactions per second. In actual fact, the transaction rate was 0.8, but the trace PMDA did its calculations on the sampling interval from 2 seconds to 12 seconds, and not from 3.5 seconds to 13.5 seconds. For efficiency, the trace PMDA calculates the metrics on the last 10 seconds every 2 seconds. As a result, the PMDA is not driven each time a fetch request is received to do a calculation.</p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5213903"></a>4.2.3. Configuring the Trace PMDA</h3></div></div>
<p><a class="indexterm" name="IG31340177494"></a>The trace PMDA is configurable primarily through command-line options. The list of command-line options in <a href="ch04.html#id5213936" title="Table 4-1. Selected Command-Line Options">Table 4-1</a> is not exhaustive, but it identifies those options which are particularly relevant to tuning the manner in which performance data is collected.</p>
<div class="table"><a name="id5213936"></a><p><a name="id5213936"></a><b>Table 4-1. Selected Command-Line Options</b></p>
<table summary="Selected Command-Line Options" border="1"><colgroup><col><col></colgroup><thead><tr valign="top"><th scope="col" align="left" valign="bottom"><p>Option</p>
</th><th scope="col" align="left" valign="bottom"><p>Description</p>
</th></tr></thead><tbody><tr valign="top"><td scope="row" align="left" valign="top"><p>Access controls<a class="indexterm" name="IG31340177495"></a></p>
</td><td align="left" valign="top"><p>The trace PMDA offers host-based access control. This control allows and disallows connections from instrumented applications running on specified hosts or groups of hosts. Limits to the number of connections allowed from individual hosts can also be mandated.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p>Sample duration<a class="indexterm" name="IG31340177496"></a></p>
</td><td align="left" valign="top"><p>The interval over which metrics are to be maintained before being discarded is called the sample duration.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p>Number of historical buffers<a class="indexterm" name="IG31340177497"></a></p>
</td><td align="left" valign="top"><p>The data maintained for the sample duration is held in a number of internal buffers within the trace PMDA. These are referred to as historical buffers. This number is configurable so that the rolling window effect can be tuned within the sample duration.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p>Counter and observation metric units<a class="indexterm" name="IG31340177498"></a></p>
</td><td align="left" valign="top"><p><a class="indexterm" name="IG31340177499"></a> Since the data being exported by the <tt>trace.observe.value</tt> and <tt>trace.counter.count</tt> metrics are user-defined, the trace PMDA by default exports these metrics with a type of &#8220;none.&#8221; A framework is provided that allows the user to make the type more specific (for example, bytes per second) and allows the exported values to be plotted along with other performance metrics of similar units by tools like <tt>pmchart</tt>.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p>Instance domain refresh<a class="indexterm" name="IG31340177500"></a></p>
</td><td align="left" valign="top"><p>The set of instances exported for each of the <tt>trace</tt> metrics can be cleared through the storable <tt><a class="indexterm" name="IG31340177501"></a> trace.control.reset</tt> metric.</p>
</td></tr></tbody></table></div><br></div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="LE26087-PARENT"></a>4.3. Trace API</h2></div></div>
<p><a class="indexterm" name="IG31340177502"></a> <a class="indexterm" name="IG31340177503"></a>The <tt>libpcp_trace</tt> Application Programming Interface (API) is called from C, C++, Fortran, and Java. Each language has access to the complete set of functionality offered by <tt>libpcp_trace</tt>. In some cases, the calling conventions differ slightly between languages. This section presents an overview of each of the different tracing mechanisms offered by the API, as well as an explanation of their mappings to the actual performance metrics exported by the trace PMDA.</p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5214320"></a>4.3.1. Transactions </h3></div></div>
<p><a class="indexterm" name="IG31340177504"></a> <a class="indexterm" name="IG31340177505"></a> <a class="indexterm" name="IG31340177506"></a> <a class="indexterm" name="IG31340177507"></a>Paired calls to the <tt>pmtracebegin</tt> and <tt>pmtraceend</tt> API functions result in transaction data being sent to the trace PMDA with a measure of the time interval between the two calls. This interval is the transaction service time. Using the <tt>pmtraceabort</tt> call causes data for that particular transaction to be discarded. The trace PMDA exports transaction data through the following <tt>trace.transact</tt> metrics listed in <a href="ch04.html#id5214410" title="Table 4-2. trace.transact Metrics">Table 4-2</a>:</p>
<div class="table"><a name="id5214410"></a><p><a name="id5214410"></a><b>Table 4-2. <tt>trace.transact</tt> Metrics</b></p>
<table summary="trace.transact Metrics" border="1"><colgroup><col><col></colgroup><thead><tr valign="top"><th scope="col" align="left" valign="bottom"><p>Metric</p>
</th><th scope="col" align="left" valign="bottom"><p>Description</p>
</th></tr></thead><tbody><tr valign="top"><td scope="row" align="left" valign="top"><p><tt><a class="indexterm" name="IG31340177508"></a> trace.transact.ave_time</tt></p>
</td><td align="left" valign="top"><p>The average service time per transaction type. This time is calculated over the last sample duration.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt><a class="indexterm" name="IG31340177509"></a> trace.transact.count</tt></p>
</td><td align="left" valign="top"><p>The running count for each transaction type seen since the trace PMDA started.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt><a class="indexterm" name="IG31340177510"></a> trace.transact.max_time</tt></p>
<p><tt></tt></p>
</td><td align="left" valign="top"><p>The maximum service time per transaction type within the last sample duration.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt><a class="indexterm" name="IG31340177511"></a> trace.transact.min_time</tt></p>
</td><td align="left" valign="top"><p>The minimum service time per transaction type within the last sample duration.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt><a class="indexterm" name="IG31340177512"></a> trace.transact.rate</tt></p>
<p> </p>
</td><td align="left" valign="top"><p>The average rate at which each transaction type is completed. The rate is calculated over the last sample duration.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt><a class="indexterm" name="IG31340177513"></a> trace.transact.total_time</tt></p>
</td><td align="left" valign="top"><p>The cumulative time spent processing each transaction since the trace PMDA started running.</p>
</td></tr></tbody></table></div><br></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5214714"></a>4.3.2. Point Tracing </h3></div></div>
<p><a class="indexterm" name="IG31340177514"></a> <a class="indexterm" name="IG31340177515"></a>Point tracing allows the application programmer to export metrics related to salient events. The <tt>pmtracepoint</tt> function is most useful when start and end points are not well defined. For example, this function is useful when the code branches in such a way that a transaction cannot be clearly identified, or when processing does not follow a transactional model, or when the desired instrumentation is akin to event rates rather than event service times. This data is exported through the <tt>trace.point</tt> metrics listed in <a href="ch04.html#id5214762" title="Table 4-3. trace.point Metrics">Table 4-3</a>:<div class="table"><a name="id5214762"></a><p><a name="id5214762"></a><b>Table 4-3. <tt>trace.point</tt> Metrics</b></p>
<table summary="trace.point Metrics" border="1"><colgroup><col><col></colgroup><thead><tr valign="top"><th scope="col" align="left" valign="bottom"><p>Metric</p>
</th><th scope="col" align="left" valign="bottom"><p>Description</p>
</th></tr></thead><tbody><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>trace.point.count<a class="indexterm" name="IG31340177516"></a></tt></p>
</td><td align="left" valign="top"><p>Running count of point observations for each tag seen since the trace PMDA started.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>trace.point.rate<a class="indexterm" name="IG31340177517"></a></tt></p>
</td><td align="left" valign="top"><p>The average rate at which observation points occur for each tag within the last sample duration.</p>
</td></tr></tbody></table></div><br></p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5214931"></a>4.3.3. Observations and Counters</h3></div></div>
<p><a class="indexterm" name="IG31340177518"></a> <a class="indexterm" name="IG31340177519"></a> <a class="indexterm" name="IG31340177520"></a>The <tt>pmtraceobs</tt> and <tt>pmtracecount</tt> functions have similar semantics to <tt>pmtracepoint</tt>, but also allow an arbitrary numeric value to be passed to the trace PMDA. The most recent value for each tag is then immediately available from the PMDA. Observation data is exported through the <tt>trace.observe</tt> metrics listed in <a href="ch04.html#id5215021" title="Table 4-4. trace.observe Metrics">Table 4-4</a>:</p>
<div class="table"><a name="id5215021"></a><p><a name="id5215021"></a><b>Table 4-4. <tt>trace.observe</tt> Metrics</b></p>
<table summary="trace.observe Metrics" border="1"><colgroup><col><col></colgroup><thead><tr valign="top"><th scope="col" align="left" valign="bottom"><p>Metric</p>
</th><th scope="col" align="left" valign="bottom"><p>Description</p>
</th></tr></thead><tbody><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>trace.observe.count</tt></p>
</td><td align="left" valign="top"><p>Running count of observations seen since the trace PMDA started.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>trace.observe.rate</tt></p>
</td><td align="left" valign="top"><p>The average rate at which observations for each tag occur. This rate is calculated over the last sample duration.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>trace.observe.value</tt></p>
</td><td align="left" valign="top"><p>The numeric value associated with the observation last seen by the trace PMDA.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>trace.counter</tt></p>
</td><td align="left" valign="top"><p>Counter data is exported through the <tt>trace.counter</tt> metrics. The only difference between <tt>trace.counter</tt> and <tt>trace.observe</tt> metrics is that the numeric value of <tt>trace.counter</tt> must be a monotonic increasing count.</p>
</td></tr></tbody></table></div><br></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5215241"></a>4.3.4. Configuring the Trace Library</h3></div></div>
<p><a class="indexterm" name="IG31340177521"></a><a class="indexterm" name="IG31340177522"></a> <a class="indexterm" name="IG31340177523"></a> <a class="indexterm" name="IG31340177524"></a>The trace library is configurable through the use of environment variables listed in <a href="ch04.html#id5215299" title="Table 4-5. Environment Variables">Table 4-5</a> as well as through the state flags listed in <a href="ch04.html#id5215745" title="Table 4-6. State Flags">Table 4-6</a>. Both provide diagnostic output and enable or disable the configurable functionality within the library.</p>
<div class="table"><a name="id5215299"></a><p><a name="id5215299"></a><b>Table 4-5. Environment Variables</b></p>
<table summary="Environment Variables" border="1"><colgroup><col><col></colgroup><thead><tr valign="top"><th scope="col" align="left" valign="bottom"><p>Name</p>
</th><th scope="col" align="left" valign="bottom"><p>Description</p>
</th></tr></thead><tbody><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>PCP_TRACE_HOST</tt><a class="indexterm" name="IG31340177525"></a></p>
</td><td align="left" valign="top"><p>The name of the host where the trace PMDA is running.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>PCP_TRACE_PORT</tt><a class="indexterm" name="IG31340177526"></a></p>
</td><td align="left" valign="top"><p><a class="indexterm" name="IG31340177527"></a> TCP/IP port number on which the trace PMDA is accepting client connections.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>PCP_TRACE_TIMEOUT</tt><a class="indexterm" name="IG31340177528"></a></p>
</td><td align="left" valign="top"><p>The number of seconds to wait until assuming that the initial connection is not going to be made, and timeout will occur. The default is three seconds.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>PCP_TRACE_REQTIMEOUT</tt><a class="indexterm" name="IG31340177529"></a></p>
</td><td align="left" valign="top"><p><a class="indexterm" name="IG31340177530"></a> The number of seconds to allow before timing out on awaiting acknowledgment from the trace PMDA after trace data has been sent to it. This variable has no effect in the asynchronous trace protocol (refer to <a href="ch04.html#id5215745" title="Table 4-6. State Flags">Table 4-6</a>).</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>PCP_TRACE_RECONNECT</tt><a class="indexterm" name="IG31340177531"></a></p>
</td><td align="left" valign="top"><p>A list of values which represents the backoff approach that the <tt>libpcp_trace</tt> library routines take when attempting to reconnect to the trace PMDA after a connection has been lost. The list of values should be a positive number of seconds for the application to delay before making the next reconnection attempt. When the final value in the list is reached, that value is used for all subsequent reconnection attempts.</p>
</td></tr></tbody></table></div><p><a class="indexterm" name="IG31340177532"></a> <a class="indexterm" name="IG31340177533"></a> <a class="indexterm" name="IG31340177534"></a> <a class="indexterm" name="IG31340177535"></a>The <a href="ch04.html#id5215745" title="Table 4-6. State Flags">Table 4-6</a> are used to customize the operation of the <tt>libpcp_trace</tt> routines. These are registered through the <tt>pmtracestate</tt> call, and they can be set either individually or together.</p>
<div class="table"><a name="id5215745"></a><p><a name="id5215745"></a><b>Table 4-6. State Flags</b></p>
<table summary="State Flags" border="1"><colgroup><col><col></colgroup><thead><tr valign="top"><th scope="col" align="left" valign="bottom"><p>Flag</p>
</th><th scope="col" align="left" valign="bottom"><p>Description</p>
</th></tr></thead><tbody><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>PMTRACE_STATE_NONE<a class="indexterm" name="IG31340177536"></a></tt></p>
</td><td align="left" valign="top"><p><a class="indexterm" name="IG31340177537"></a> The default. No state flags have been set, the fault-tolerant, synchronous protocol is used for communicating with the trace PMDA, and no diagnostic messages are displayed by the <tt></tt><tt>libpcp_trace</tt> routines.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>PMTRACE_STATE_API<a class="indexterm" name="IG31340177538"></a></tt></p>
</td><td align="left" valign="top"><p>High-level diagnostics. This flag simply displays entry into each of the API routines.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>PMTRACE_STATE_COMMS<a class="indexterm" name="IG31340177539"></a></tt></p>
</td><td align="left" valign="top"><p>Diagnostic messages related to establishing and maintaining the communication channel between application and PMDA.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>PMTRACE_STATE_PDU<a class="indexterm" name="IG31340177540"></a> <a class="indexterm" name="IG31340177541"></a></tt></p>
</td><td align="left" valign="top"><p><a class="indexterm" name="IG31340177542"></a> The low-level details of the trace protocol data units (PDU) is displayed as each PDU is transmitted or received.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>PMTRACE_STATE_PDUBUF<a class="indexterm" name="IG31340177543"></a></tt></p>
</td><td align="left" valign="top"><p>The full contents of the PDU buffers are dumped as PDUs are transmitted and received.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>PMTRACE_STATE_NOAGENT<a class="indexterm" name="IG31340177544"></a></tt></p>
</td><td align="left" valign="top"><p><a class="indexterm" name="IG31340177545"></a> <a class="indexterm" name="IG31340177546"></a> Interprocess communication control. If this flag is set, it causes interprocess communication between the instrumented application and the trace PMDA to be skipped. This flag is a debugging aid for applications using <tt>libpcp_trace</tt>.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>PMTRACE_STATE_ASYNC<a class="indexterm" name="IG31340177547"></a></tt></p>
</td><td align="left" valign="top"><p><a class="indexterm" name="IG31340177548"></a> <a class="indexterm" name="IG31340177549"></a> Asynchronous trace protocol. This flag enables the asynchronous trace protocol so that the application does not block awaiting acknowledgment PDUs from the trace PMDA. In order for the flag to be effective, it must be set before using the other <tt></tt><tt>libpcp_trace</tt> entry points.</p>
</td></tr></tbody></table></div><br></div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5216224"></a>4.4. Instrumenting Applications to Export Performance Data</h2></div></div>
<p><a class="indexterm" name="IG31340177550"></a><a class="indexterm" name="IG31340177551"></a> <a class="indexterm" name="IG31340177552"></a>The relationship between an application, the <tt>libpcp_trace</tt> library, the trace PMDA and the rest of the PCP infrastructure is shown in <a href="ch04.html#id5216302" title="Figure 4-4. Application and PCP Relationship">Figure 4-4</a>:</p>
<p><div class="figure"><a name="id5216302"></a><p><a name="id5216302"></a><b>Figure 4-4. Application and PCP Relationship</b></p>
<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/trace_libpcp.gif" alt="Application and PCP Relationship" height="231" width="371"></td></tr></table></div></div><br></p>
<p><a class="indexterm" name="IG31340177553"></a> <a class="indexterm" name="IG31340177554"></a> <a class="indexterm" name="IG31340177555"></a>The <tt>libpcp_trace</tt> library is designed to encourage application developers (independent software vendors and end-user customers) to embed calls in their code that enable application performance data to be exported. When combined with system-level performance data, this feature allows total performance and resource demands of an application to be correlated with application activity.</p>
<p>For example, developers can provide the following application performance metrics:</p>
<div class="itemizedlist"><ul type="disc"><li><p><a class="indexterm" name="IG31340177556"></a>Computation state (especially for codes with major shifts in resource demands between phases of their execution)</p>
</li>
<li><p><a class="indexterm" name="IG31340177557"></a>Problem size and parameters, that is, degree of parallelism throughput in terms of subproblems solved, iteration count, transactions, data sets inspected, and so on</p>
</li>
<li><p><a class="indexterm" name="IG31340177558"></a>Service time by operation type</p>
</li>
</ul></div><p>The <tt>libpcp_trace</tt> library approach offers a number of attractive features:</p>
<div class="itemizedlist"><ul type="disc"><li><p>A simple API for inserting instrumentation calls into an application as shown in the following example:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">pmtracebegin(&#8220;pass 1&#8221;);
... 
pmtraceend(&#8220;pass 1&#8221;); 
...
pmtraceobs(&#8220;threads&#8221;, N);</pre></td></tr></table><br></li>
<li><p><a class="indexterm" name="IG31340177559"></a>Trace routines that are called from C, C++, Fortran, and Java, and that are well suited to macro encapsulation for compile-time inclusion and exclusion.</p>
</li>
<li><p>Shipped source code for a stub version of the library that enables the following:</p>
<div class="itemizedlist"><ul type="round"><li><p>Replacement by private debugging or development versions</p>
</li>
<li><p>Flexibility based on not being locked into a SGI program</p>
</li>
<li><p>Added functionality on SGI platforms, when the PCP version of the library is present</p>
</li>
</ul></div></li>
<li><p><a class="indexterm" name="IG31340177560"></a>A PCP version of the library that allows numerical observations, measures time between matching begin-end calls, and so on to be shipped to a PCP agent and then exported into the PCP infrastructure. As exporting is controlled by environment variables, the overhead is very low if the metrics are not being exported.</p>
</li>
</ul></div><p>Once the application performance metrics are exported into the PCP framework, all of the PCP tools may be leveraged to provide performance monitoring and management, including:</p>
<div class="itemizedlist"><ul type="disc"><li><p>Two- and three-dimensional visualization of resource demands and performance, showing concurrent system activity and application activity. <div class="note"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/note.png" height="24" width="24"></td><td align="left" valign="top"><b>Note: </b>On Linux, visualization tools are not provided as part of the PCP for IA-64 Linux distribution.
</td></tr></table><hr noshade="noshade"></div><br></p>
</li>
<li><p><a class="indexterm" name="IG31340177561"></a>Transport of performance data over the network for distributed performance management.</p>
</li>
<li><p><a class="indexterm" name="IG31340177562"></a>Archive logging for historical records of performance, most useful for problem diagnosis, postmortem analysis, performance regression testing, capacity planning, and benchmarking.</p>
</li>
<li><p><a class="indexterm" name="IG31340177563"></a>Automated alarms when bad performance is observed. These apply both in real-time or when scanning archives.</p>
</li>
<li><p><a class="indexterm" name="IG31340177564"></a><a class="indexterm" name="IG31340177565"></a>A toolkit approach that encourages customization. For example, a complete PCP for XYZ package could be offered for performance monitoring of application XYZ on SGI and other Linux-based platforms.</p>
</li>
</ul></div></div></div><!--CONTENT_END--><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03.html">Prev</a> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Table of Contents</a></td><td width="40%" align="right"> <a accesskey="n" href="apa.html">Next</a></td></tr><tr><td width="40%" align="left">Chapter 3. PMAPI--The Performance Metrics API </td><td width="20%" align="center"> </td><td width="40%" align="right">Appendix A. Acronyms </td></tr></table></div></body></html>
