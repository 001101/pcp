<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type"><title>Chapter 2. Writing a PMDA</title><meta name="generator" content="DocBook XSL Stylesheets V1.51.1"><meta name="generator" content="SGI XSL DocBook Customization Stylesheets V1.1"><link rel="home" href="index.html" title="Performance Co-Pilot&#8482; Programmer's Guide"><link rel="up" href="index.html" title="Performance Co-Pilot&#8482; Programmer's Guide"><link rel="previous" href="ch01.html" title="Chapter 1. Programming Performance Co-Pilot"><link rel="next" href="ch03.html" title="Chapter 3. PMAPI--The Performance Metrics API"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 2. Writing a PMDA</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch01.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch03.html">Next</a></td></tr></table><hr></div><!--CONTENT_BEGIN--><a name="sgi_start_content"></a><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="LE98072-PARENT"></a>Chapter 2. Writing a PMDA</h2></div></div>
<p><a class="indexterm" name="IG3134017759"></a>This chapter constitutes a programmer's guide to writing a Performance Metrics Domain Agent (PMDA) for Performance Co-Pilot (PCP).</p>
<p>The presentation assumes the developer is using the standard PCP <tt>libpcp_pmda</tt> library, as documented in the <tt>pmda(3)</tt> and associated man pages.</p>
<div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5187772"></a>2.1. Implementing a PMDA</h2></div></div>
<p><a class="indexterm" name="IG3134017760"></a><a class="indexterm" name="IG3134017761"></a>The job of a PMDA is to gather performance data and report them to the  Performance Metrics Collection Daemon (PMCD) in response to requests from PCP monitoring tools routed to the PMDA via PMCD.</p>
<p>An important  requirement for any PMDA is that it have low latency response to requests from PMCD. Either the PMDA must use a quick access method and a single thread of control, or it must have asynchronous refresh and two threads of control: one for communicating with PMCD, the other for updating the performance data.</p>
<p><a class="indexterm" name="IG3134017762"></a><a class="indexterm" name="IG3134017763"></a><a class="indexterm" name="IG3134017764"></a><a class="indexterm" name="IG3134017765"></a>The PMDA is typically acting as a gateway between the target domain (that is, the performance instrumentation in an application program or service) and the PCP framework. The PMDA may extract the information using one of a number of possible  export options that include a shared memory segment or <tt>mmap</tt> file; a sequential log  file (where the PMDA parses the tail of the log file to extract the information); a snapshot file (the PMDA rereads the file as required); or application-specific communication services  (IPC). The choice
of export methodology is typically determined by the source of the instrumentation (the target domain) rather than by the PMDA.</p>
<p><a class="indexterm" name="IG3134017766"></a><a href="ch02.html#id5187871" title="Procedure 2-1. Creating a PMDA">Procedure 2-1</a> describes the suggested steps for designing and implementing a PMDA:</p>
<div class="procedure"><a name="id5187871"></a><p><a name="id5187871"></a><b>Procedure 2-1. Creating a PMDA</b></p><div class="orderedlist"><ol type="1"><li><p>Determine how to extract the metrics from the target domain.</p>
</li>
<li><p>Select an appropriate architecture for the PMDA (daemon or DSO, IPC, <tt>sproc</tt>).</p>
</li>
<li><p>Define the metrics and instances that the PMDA will support.</p>
</li>
<li><p>Implement the functionality to extract the metric values.</p>
</li>
<li><p>Assign Performance Metric Identifiers (PMIDs) for the metrics, along with names for the metrics in the Performance Metrics Name Space (PMNS).</p>
</li>
<li><p><a class="indexterm" name="IG3134017767"></a>Specify the help file and control data structures for metrics and instances that are required by the standard PMDA implementation library functions.</p>
</li>
<li><p>Write code to supply the metrics and associated information to PMCD.</p>
</li>
<li><p>Implement any PMDA-specific callbacks, and PMDA initialization functions.</p>
</li>
<li><p><a class="indexterm" name="IG3134017768"></a>Exercise and test the PMDA with the purpose-built PMDA debugger; see the <tt>dbpmda(1)</tt> man page.</p>
</li>
<li><p>Install and connect the PMDA to a running PMCD process; see the <tt>pmcd(1)</tt> man page.</p>
</li>
<li><p><a class="indexterm" name="IG3134017769"></a><a class="indexterm" name="IG3134017770"></a><a class="indexterm" name="IG3134017771"></a><a class="indexterm" name="IG3134017772"></a><a class="indexterm" name="IG3134017773"></a><a class="indexterm" name="IG3134017774"></a><a class="indexterm" name="IG3134017775"></a>Configure or develop tools to use the new metrics. For examples of visualization tools, see the <tt>pmchart(1)</tt>, <tt>pmgadgets(1)</tt>, and <tt>pmview(1)</tt> man pages (IRIX only). For an examples of text-based tools, see the <tt>
pmval(1)</tt> and <tt>pminfo(1)</tt> man pages. For examples of alarm tools, see the <tt>pmie(1)</tt> and <tt>pmieconf(1)</tt> man pages.</p>
<p><a class="indexterm" name="IG3134017776"></a>Where appropriate, define <tt>pmlogger</tt> configurations suitable for creating PCP archives containing the new metrics. For more information, see the <tt>pmlogger(1)</tt> man page.</p>
</li>
</ol></div><ol type="1"></ol></div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5188149"></a>2.2. PMDA Architecture</h2></div></div>
<p><a class="indexterm" name="IG3134017777"></a><a class="indexterm" name="IG3134017778"></a> <a class="indexterm" name="IG3134017779"></a>This section discusses the two methods of connecting a PMDA to a PMCD process:<p><div class="itemizedlist"><ul type="disc"><li><p>As a separate process using some interprocess communication (IPC) protocol.</p>
</li>
<li><p>As a dynamically attached library (that is, a dynamic shared object or DSO).</p>
</li>
</ul></div></p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5188221"></a>2.2.1. Overview</h3></div></div>
<p><a class="indexterm" name="IG3134017780"></a><a class="indexterm" name="IG3134017781"></a>All PMDAs are launched and controlled by the PMCD process on the local host. PMCD receives requests from the monitoring tools and forwards them to the PMDAs. Responses, when required, are returned through PMCD to the clients. The requests fall into a small number of categories, and the PMDA must handle each request type. For a DSO PMDA, each request type corresponds to a method in the agent. For a daemon PMDA, each request translates to a message or  protocol data unit (PDU) that may be sent to a PMDA from PMCD.</p>
<p>For daemon PMDA, the following request PDUs must be supported:<div class="variablelist"><table border="0" cellspacing="3"><tr valign="top"><td><span class="term"><tt>PDU_FETCH</tt></span></td><td width="10"> </td><td><p><a class="indexterm" name="IG3134017782"></a><a class="indexterm" name="IG3134017783"></a>Request for metric values (see the <tt>pmFetch(3)</tt> man page.)</p>

</td></tr><tr valign="top"><td><span class="term"><tt>PDU_PROFILE</tt></span></td><td width="10"> </td><td><p><a class="indexterm" name="IG3134017784"></a><a class="indexterm" name="IG3134017785"></a>A list of instances required for the corresponding metrics in subsequent fetches (see the <tt>pmAddProfile(3)</tt> man page).</p>

</td></tr><tr valign="top"><td><span class="term"><tt>PDU_INSTANCE_REQ</tt></span></td><td width="10"> </td><td><p><a class="indexterm" name="IG3134017786"></a><a class="indexterm" name="IG3134017787"></a> Request for a particular instance domain for instance descriptions (see the <tt>pmGetInDom(3)</tt> man page).</p>

</td></tr><tr valign="top"><td><span class="term"><tt>PDU_DESC_REQ</tt></span></td><td width="10"> </td><td><p><a class="indexterm" name="IG3134017788"></a><a class="indexterm" name="IG3134017789"></a>Request for metadata describing metrics (see the <tt>pmLookupDesc(3)</tt> man page).</p>

</td></tr><tr valign="top"><td><span class="term"><tt>PDU_TEXT_REQ</tt></span></td><td width="10"> </td><td><p><a class="indexterm" name="IG3134017790"></a><a class="indexterm" name="IG3134017791"></a><a class="indexterm" name="IG3134017792"></a>Request for metric help text (see the <tt>pmLookupText(3)</tt> man page).</p>

</td></tr><tr valign="top"><td><span class="term"><tt>PDU_RESULT</tt></span></td><td width="10"> </td><td><p><a class="indexterm" name="IG3134017793"></a><a class="indexterm" name="IG3134017794"></a>Values to store into metrics (see the <tt>pmStore(3)</tt> man page).</p>

</td></tr></table></div></p>
<p>Each PMDA is associated with a unique domain number that is encoded in the domain field of metric and instance identifiers, and PMCD uses the domain number to determine which PMDA can handle the components of any given client request.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="LE82676-PARENT"></a>2.2.2. DSO PMDA</h3></div></div>
<p><a class="indexterm" name="IG3134017795"></a><a class="indexterm" name="IG3134017796"></a>Each PMDA is required to implement a function that handles each of the request types. By implementing these functions as library functions, a PMDA can be implemented as a  dynamically shared object (DSO) and attached by PMCD at run time with the <tt>dlopen</tt> call; see the <tt>dlopen(3)</tt> man page. This eliminates the need for an IPC layer (typically a UNIX pipe) between each PMDA and PMCD, because each request becomes a function call rather than a message exchange. The required library functions are detailed in <a href="ch02.html#LE21831-PARENT" title="2.5. DSO Interface">Section 2.5</a>.</p>
<p>A PMDA that interacts with PMCD in this fashion must abide by a formal initialization protocol so that PMCD can discover the location of the library functions that are subsequently called with function pointers. When a DSO PMDA is installed, the PMCD configuration file, <tt>/etc/pmcd.conf</tt> on IRIX; <tt>/var/pcp/config/pmcd/pmcd.conf</tt>, is updated to reflect the domain and name of the PMDA, the location of the shared object, and the name of the initialization function. The initialization sequence is discussed in <a href="ch02.html#LE19047-PARENT" title="2.6. Initializing a PMDA">Section 2.6</a>.</p>
<p><a class="indexterm" name="IG3134017797"></a>As superuser, install the simple PMDA as a DSO, as shown in <a href="ch02.html#Z963514088sdc" title="Example 2-1. Simple IRIX PMDA as a DSO">Example 2-1</a> and <a href="ch02.html#Z1033502809tls" title="Example 2-2. Simple Linux PMDA as a DSO">Example 2-2</a>, and observe the changes in the PMCD configuration file. The output may differ slightly depending on the other PMDAs you have installed.</p>
<div class="example"><a name="Z963514088sdc"></a><p><a name="Z963514088sdc"></a><b>Example 2-1. Simple IRIX PMDA as a DSO</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting"># <b><tt>cd /var/pcp/pmdas/simple</tt></b>
# <b><tt>cat /etc/pmcd.conf</tt></b>
# Name  Id      IPC     IPC Params      File/Cmd 
irix    1       dso     irix_init       libirixpmda.so 
pmcd    2       dso     pmcd_init       pmda_pmcd.so 
proc    3       dso     proc_init       pmda_proc.so 
# <b><tt>./Install</tt></b>
You will need to choose an appropriate configuration for installation 
of the &#8220;simple&#8221; Performance Metrics Domain Agent (PMDA).
collector   collect performance statistics on this system
  monitor     allow this system to monitor local and/or remote systems
  both         collector and monitor configuration for this system
Please enter c(ollector) or m(onitor) or b(oth) [b] <b><tt>both</tt></b>

Updating the Performance Metrics Name Space (PMNS) ... 
Installing pmchart view(s) ...
Install simple as a daemon or dso agent? [daemon] <b><tt>dso</tt></b>
...
Check simple metrics have appeared ... 5 metrics and 9 values
# <b><tt>cat /etc/pmcd.conf</tt></b>
# Name  Id      IPC     IPC Params      File/Cmd 
irix    1       dso     irix_init       libirixpmda.so 
pmcd    2       dso     pmcd_init       pmda_pmcd.so 
proc    3       dso     proc_init       pmda_proc.so 
simple  253     dso     simple_init     pmda_simple.so</pre></td></tr></table><p>As can be seen from the contents of <tt>/etc/pmcd.conf</tt>, the DSO version of the simple PMDA is in a library named <tt>pmda_simple.so</tt> and has an initialization function called <a class="indexterm" name="IG3134017798"></a> <tt>simple_init</tt>. The domain of the simple PMDA is 253, as shown in the column headed <tt>Id</tt>.</p>
</div><p><div class="example"><a name="Z1033502809tls"></a><p><a name="Z1033502809tls"></a><b>Example 2-2. Simple Linux PMDA as a DSO</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting"><b><tt>cat /var/pcp/config/pmcd/pmcd.conf</tt></b>
# Performance Metrics Domain Specifications
# 
# This file is automatically generated during the build
# Name  Id      IPC     IPC Params      File/Cmd
pmcd    2       dso     pmcd_init       /var/pcp/pmdas/pmcd/pmda_pmcd.so
linux   60      dso     linux_init      /var/pcp/pmdas/linux/pmda_linux.so

snia 63 pipe binary /var/pcp/pmdas/snia/pmdasnia -d 63
simple  254     dso     simple_init     pmda_simple.so</pre></td></tr></table><br></div><br></p>
<p>As can be seen from the contents of <tt>/var/pcp/config/pmcd/pmcd.conf</tt>, the DSO version of the simple PMDA is in a library named <tt>pmda_simple.so</tt> and has an initialization function called <a class="indexterm" name="IG3134017799"></a> <tt>simple_init</tt>. The domain of the simple PMDA is 254, as shown in the column headed <tt>Id</tt>.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5188840"></a>2.2.3. Daemon PMDA</h3></div></div>
<p><a class="indexterm" name="IG31340177100"></a>A DSO PMDA provides the most efficient communication between the PMDA and PMCD. This approach has some  disadvantages resulting from the DSO PMDA being the same process as PMCD:</p>
<div class="itemizedlist"><ul type="disc"><li><p>An error or bug that causes a DSO PMDA to exit also causes PMCD to exit.</p>
</li>
<li><p>There is only one thread of control in PMCD; as a result, a computationally expensive PMDA, or worse, a PMDA that blocks for I/O, adversely affects the performance of PMCD.</p>
</li>
<li><p>The PMCD runs as superuser; so any DSO PMDAs also run as superuser.</p>
</li>
<li><p>A memory leak in a DSO PMDA also causes a memory leak for PMCD.</p>
</li>
</ul></div><p>Consequently, many PMDAs are implemented as a daemon process.</p>
<p>The <tt>libpcp_pmda</tt> library is designed to allow simple implementation of a PMDA that runs as a separate process. The library functions provide a message passing layer acting as a generic wrapper that accepts PDUs, makes library calls using the standard DSO PMDA interface, and sends PDUs. Therefore, you can implement a PMDA as a DSO and then install it as either a daemon or a DSO, depending on the presence or absence of the generic wrapper.</p>
<p><a class="indexterm" name="IG31340177101"></a><a class="indexterm" name="IG31340177102"></a><a class="indexterm" name="IG31340177103"></a>The PMCD process launches a daemon PMDA with  <tt>fork</tt> and <tt>execv</tt>. You can easily connect a pipe to the PMDA using standard input and output. The PMCD process may also connect to a daemon PMDA using TCP/IP or UNIX domain sockets; see the <tt>inet(7)</tt> or <tt>unix(7)</tt> man page.</p>
<p><a class="indexterm" name="IG31340177104"></a><a class="indexterm" name="IG31340177105"></a>As superuser, install the  simple PMDA as a daemon process as shown in <a href="ch02.html#Z963516216sdc" title="Example 2-3. Simple IRIX PMDA as a Daemon">Example 2-3</a> for IRIX and <a href="ch02.html#Z1033576478tls" title="Example 2-4. Simple Linux PMDA as a Daemon">Example 2-4</a> for Linux. As in <a href="ch02.html#Z963514088sdc" title="Example 2-1. Simple IRIX PMDA as a DSO">Example 2-1</a>, the output may differ due to other PMDAs already installed.</p>
<div class="example"><a name="Z963516216sdc"></a><p><a name="Z963516216sdc"></a><b>Example 2-3. Simple IRIX PMDA as a Daemon</b></p>
<p>The specification for the simple PMDA now states the connection type of <tt>pipe</tt> to PMCD and the executable image for the PMDA is <tt>/var/pcp/pmdas/simple/pmdasimple</tt>, using domain number 253.</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting"># <b><tt>cd /var/pcp/pmdas/simple</tt></b>
# <b><tt>./Install</tt></b> 
... 
Install simple as a daemon or dso agent? [daemon] daemon 
PMCD should communicate with the daemon via pipe or socket? [pipe] pipe
...
# cat /etc/pmcd.conf 
# Name  Id   IPC     IPC Params File/Cmd 
irix    1    dso     irix_init  libirixpmda.so 
pmcd    2    dso     pmcd_init  pmda_pmcd.so 
proc    3    dso     proc_init  pmda_proc.so 
simple  253  pipe    binary     /var/pcp/pmdas/simple/pmdasimple -d 253</pre></td></tr></table><br></div><p><div class="example"><a name="Z1033576478tls"></a><p><a name="Z1033576478tls"></a><b>Example 2-4. Simple Linux PMDA as a Daemon</b></p>
<p>The specification for the simple PMDA now states the connection type of <tt>pipe</tt> to PMCD and the executable image for the PMDA is <tt>/var/pcp/pmdas/simple/pmdasimple</tt>, using domain number 253.<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting"># <b><tt>cd /var/pcp/pmdas/simple</tt></b>
# <b><tt>./Install</tt></b>
... 
Install simple as a daemon or dso agent? [daemon] daemon 
PMCD should communicate with the daemon via pipe or socket? [pipe] pipe
...
# cat /var/pcp/config/pmcd/pmcd.conf 
# Performance Metrics Domain Specifications
# 
# This file is automatically generated during the build
# Name  Id      IPC     IPC Params      File/Cmd
pmcd    2       dso     pmcd_init       /var/pcp/pmdas/pmcd/pmda_pmcd.so
linux   60      dso     linux_init      /var/pcp/pmdas/linux/pmda_linux.so
snia 63 pipe binary /var/pcp/pmdas/snia/pmdasnia -d 63 
simple  253  pipe    binary     /var/pcp/pmdas/simple/pmdasimple -d 253</pre></td></tr></table><br></p>
</div><br></p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5189181"></a>2.2.4. Caching PMDA</h3></div></div>
<p><a class="indexterm" name="IG31340177106"></a>When either the cost or latency associated with collecting performance metrics is high, the PMDA implementer may choose to trade off the currency of the performance data to reduce the PMDA resource demands or the fetch latency time.</p>
<p>One scheme for doing this is called a  caching PMDA, which periodically instantiates values for the performance metrics and responds to each request from PMCD with the most recently instantiated (or cached) values, as opposed to instantiating current values on demand when the PMCD asks for them.</p>
<p><a class="indexterm" name="IG31340177107"></a><a class="indexterm" name="IG31340177108"></a>The Cisco PMDA is an example of a caching PMDA. For additional information, see the contents of the <tt>/var/pcp/pmdas/cisco</tt> directory and the <tt>pmdacisco(1)</tt> man page.</p>
</div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="LE97285-PARENT"></a>2.3. Domains, Metrics, and Instances</h2></div></div>
<p>This section defines metrics and instances, discusses how they should be designed for a particular target domain, and shows how to implement support for them.</p>
<p><a class="indexterm" name="IG31340177109"></a>The examples in this section are drawn from the trivial and simple PMDAs, which are distributed in source format with PCP. Refer to the <tt>/var/pcp/pmdas/trivial</tt> and <tt>/var/pcp/pmdas/simple</tt> directories, respectively.</p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5189300"></a>2.3.1. Overview</h3></div></div>
<p><a class="indexterm" name="IG31340177110"></a><a class="indexterm" name="IG31340177111"></a><i>Domains</i> are autonomous performance areas, such as the operating system or a layered service or a particular application. <i>Metrics</i> are raw performance data for a domain, and typically quantify activity levels, resource utilization or quality of service. <i>Instances</i> are sets of related metrics, as for multiple processors, or multiple service classes, or multiple transaction types.</p>
<p> PCP employs the following simple and uniform data model to accommodate the demands of performance metrics drawn from multiple domains:</p>
<div class="itemizedlist"><ul type="disc"><li><p>Each metric has an identifier that is unique across all metrics for all PMDAs on a particular host.</p>
</li>
<li><p>Externally, metrics are assigned names for user convenience--typically there is a 1:1 relationship between a metric name and a metric identifier.</p>
</li>
<li><p>The PMDA implementation determines if a particular metric has a singular value or a set of (zero or more) values. For instance, the metric <tt>hinv.ndisk</tt> counts the number of disks and has only one value on a host, whereas the metric <tt>disk.dev.total</tt> counts disk I/O operations and has one value for each disk on the host.</p>
</li>
<li><p>If a metric has a set of values, then members of the set are differentiated by instances. The set of instances associated with a metric is an <i>instance domain</i>. For example, the set of metrics <tt>disk.dev.total</tt> is defined over an instance domain that has one member per disk spindle.</p>
</li>
</ul></div><p><a class="indexterm" name="IG31340177112"></a>The  selection of metrics and instances is an important design decision for a PMDA implementer. The metrics and instances for a target domain should have the following qualities:</p>
<div class="itemizedlist"><ul type="disc"><li><p>Obvious to a user</p>
</li>
<li><p>Consistent across the domain</p>
</li>
<li><p>Accurately representative of the operational and functional aspects of the domain</p>
</li>
</ul></div><p>For each metric, you should also consider these questions:</p>
<div class="itemizedlist"><ul type="disc"><li><p>How useful is this value?</p>
</li>
<li><p>What units give a good sense of scale?</p>
</li>
<li><p>What name gives a good description of the metric's meaning?</p>
</li>
<li><p>Can this metric be combined with another to convey the same useful information?</p>
</li>
</ul></div><p>As with all programming tasks, expect to refine the choice of metrics and instances several times during the development of the PMDA.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5189538"></a>2.3.2. Domains</h3></div></div>
<p>Each PMDA must be uniquely identified by PMCD so that requests from clients can be efficiently routed to the appropriate PMDA. The unique identifier, the PMDA's domain, is encoded within the metrics and instance domain identifiers so that they are associated with the correct PMDA, and so that they are unique, regardless of the number of PMDAs that are connected to the PMCD process.</p>
<p><a class="indexterm" name="IG31340177113"></a>The default  domain number for each PMDA is defined in <tt>/var/pcp/pmns/stdpmid</tt>. This file is a simple table of PMDA names and their corresponding domain number. However, a PMDA does not have to use this domain number--the file is only a guide to help avoid domain number clashes when PMDAs are installed and activated.</p>
<p>The domain number a PMDA uses is passed to the PMDA by PMCD when the PMDA is launched. Therefore, any data structures that require the PMDA's domain number must be set up when the PMDA is initialized, rather than declared statically. The protocol for PMDA initialization provides a standard way for a PMDA to implement this run-time initialization.</p>
<div class="tip"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/tip.png" height="24" width="25"></td><td align="left" valign="top"><b>Tip: </b>Although uniqueness of the domain number in the <tt>/etc/pmcd.conf</tt> control file used by PMCD is all that is required for successful starting of PMCD and the associated PMDAs, the developer of a new PMDA is encouraged to add the default domain number for each new PMDA to the <tt>/var/pcp/pmns/stdpmid.local</tt> file and then to run the  <tt>Make.stdpmid</tt> script in <tt>/var/pcp/pmns</tt> to recreate <tt>/var/pcp/pmns/stdpmid</tt>; this file acts as a repository for documenting the known default domain numbers.
</td></tr></table><hr noshade="noshade"></div><br></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="LE98565-PARENT"></a>2.3.3. Metrics</h3></div></div>
<p><a class="indexterm" name="IG31340177114"></a><a class="indexterm" name="IG31340177115"></a>A PMDA provides support for a collection of metrics. In addition to the obvious performance metrics, and the measures of time, activity and resource utilization, the metrics should also describe how the target domain has been configured, as this can greatly affect the correct interpretation of the observed performance. For example, metrics that describe network transfer rates should also describe the number and type of network interfaces connected to the host.</p>
<p><a class="indexterm" name="IG31340177116"></a><a class="indexterm" name="IG31340177117"></a>In addition, the metrics should describe how the PMDA has been configured. For example, if the PMDA was periodically probing a system to measure quality of service, there should be metrics for the delay between probes, the number of probes attempted, plus probe success and failure counters. It may also be appropriate to allow values to be  stored (see the <tt>pmstore(1)</tt> man page) into the delay metric, so that the delay used by the PMDA can be altered dynamically.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5189689"></a>2.3.3.1. Data Structures</h4></div></div>
<p><a class="indexterm" name="IG31340177118"></a><a class="indexterm" name="IG31340177119"></a><a class="indexterm" name="IG31340177120"></a>Each metric must be described in a <tt>pmDesc</tt> structure; see the <tt>pmLookupDesc(3)</tt> man page:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">typedef struct { 
    pmID        pmid;           /* unique identifier */ 
    int         type;           /* base data type */ 
    pmInDom     indom;          /* instance domain */ 
    int         sem;            /* semantics of value */ 
    pmUnits     units;          /* dimension and units */ 
} pmDesc;</pre></td></tr></table><p>This structure contains the following fields:</p>
<div class="variablelist"><table border="0" cellspacing="3"><tr valign="top"><td width="15%"><span class="term"><tt>pmid</tt></span></td><td width="85%"><p>A unique identifier, Performance Metric Identifier (PMID), that differentiates this metric from other metrics across the union of all PMDAs</p>

</td></tr><tr valign="top"><td width="15%"><span class="term"><tt>type</tt></span></td><td width="85%"><p>A data type indicator showing whether the format is an integer (32 or 64 bit, signed or unsigned); float; double; string; or arbitrary aggregate of binary data</p>

</td></tr><tr valign="top"><td width="15%"><span class="term"><tt>indom</tt></span></td><td width="85%"><p>An instance domain identifier that links this metric to an instance domain</p>

</td></tr><tr valign="top"><td width="15%"><span class="term"><tt>sem</tt></span></td><td width="85%"><p>An encoding of the value's semantics (counter, instantaneous, or discrete)</p>

</td></tr><tr valign="top"><td width="15%"><span class="term"><tt>units</tt></span></td><td width="85%"><p>A description of the value's units based on dimension and scale in the three orthogonal dimensions of space, time, and count (or events)</p>

</td></tr></table></div><p><a class="indexterm" name="IG31340177121"></a>Symbolic constants of the form <tt>PM_TYPE_*</tt>, <tt>PM_SEM_*</tt>, <tt>PM_SPACE_*</tt>, <tt>PM_TIME_*</tt>, and <tt>PM_COUNT_*</tt> are defined in the <tt>/usr/include/pcp/pmapi.h</tt> file. You may use them to initialize the elements of a <tt>pmDesc</tt> structure. The <tt>pmID</tt>  type is an unsigned integer that can be safely cast to a <tt>_pmID_int</tt> structure, which contains fields defining the metric's (PMDA's) domain, cluster, and item number as shown in <a href="ch02.html#Z975969343sdc" title="Example 2-5. _pmID_int Structure in IRIX">Example 2-5</a> for IRIX and <a href="ch02.html#Z1033577630tls" title="Example 2-6. _pmID_int Structure in Linux">Example 2-6</a> for Linux:</p>
<div class="example"><a name="Z975969343sdc"></a><p><a name="Z975969343sdc"></a><b>Example 2-5. <tt>_pmID_int</tt> Structure in IRIX</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">typedef struct { 
        int             pad:2; 
        unsigned int    domain:8; 
        unsigned int    cluster:12; 
        unsigned int    item:10; 
} _pmID_int;</pre></td></tr></table><br></div><p><div class="example"><a name="Z1033577630tls"></a><p><a name="Z1033577630tls"></a><b>Example 2-6. <tt>_pmID_int</tt> Structure in Linux</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">typedef struct { 
        unsigned int    item:10; 
        unsigned int    cluster:12; 
        unsigned int    domain:8; 
        int             pad:2; 
} _pmID_int;</pre></td></tr></table><br></div><br></p>
<p>For additional information, see the <tt>/usr/include/pcp/impl.h</tt> file.</p>
<p><a class="indexterm" name="IG31340177122"></a>The <tt>pad</tt> field should be ignored. The <tt>domain</tt> number should be set at run time when the PMDA is initialized. The <tt>PMDA_PMID</tt> macro defined in <tt>/usr/include/pcp/pmapi.h</tt> can be used to set the <tt>cluster</tt> and <tt>item</tt> fields at compile time, as these should always be known and fixed for a particular metric.</p>
<div class="note"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/note.png" height="24" width="24"></td><td align="left" valign="top"><b>Note: </b>The three components of the PMID should correspond exactly to the three-part definition of the PMID for the corresponding metric in the PMNS described in <a href="ch02.html#LE83854-PARENT" title="2.4.3. Name Space">Section 2.4.3</a>.
</td></tr></table><hr noshade="noshade"></div><p><a class="indexterm" name="IG31340177123"></a>A table of <tt>pmdaMetric</tt> structures should be defined within the PMDA, with one structure per metric as shown in <a href="ch02.html#Z976036629sdc" title="Example 2-7. pmdaMetric Structure">Example 2-7</a>. </p>
<div class="example"><a name="Z976036629sdc"></a><p><a name="Z976036629sdc"></a><b>Example 2-7. <tt>pmdaMetric</tt> Structure</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">typedef struct { 
    void        *m_user;        /* for users external use */ 
    pmDesc      m_desc;         /* metric description */ 
} pmdaMetric;</pre></td></tr></table><br></div><p>This structure contains a <tt>pmDesc</tt> structure and a handle that allows PMDA-specific structures to be associated with each metric. For example, <tt>m_user</tt> could be a pointer to a global variable containing the metric value, or a pointer to a function that may be called to instantiate the metric's value.</p>
<p><a class="indexterm" name="IG31340177124"></a>The trivial PMDA, shown in <a href="ch02.html#Z963521873sdc" title="Example 2-8. Trivial PMDA">Example 2-8</a>, has only a singular metric (that is, no instance domains):</p>
<div class="example"><a name="Z963521873sdc"></a><p><a name="Z963521873sdc"></a><b>Example 2-8. Trivial PMDA</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">static pmdaMetric metrictab[] = {
/* time */ 
 { (void *)0,  
   { PMDA_PMID(0,1), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_INSTANT, 
     PMDA_PMUNITS (0, 1, 0, 0, PM_TIME_SEC, 0) ), ) 
}; </pre></td></tr></table><p>This single metric (<tt>trivial.time</tt>) has the following:</p>
<div class="itemizedlist"><ul type="disc"><li><p>A PMID with a cluster of 0 and an item of 1</p>
</li>
<li><p>An unsigned 32-bit integer (<tt>PM_TYPE_U32</tt> )</p>
</li>
<li><p><a class="indexterm" name="IG31340177125"></a>A singular value and hence no instance domain (<tt>PM_INDOM_NULL</tt>)</p>
</li>
<li><p><a class="indexterm" name="IG31340177126"></a>An instantaneous semantic value (<tt>PM_SEM_INSTANT</tt>)</p>
</li>
<li><p>Dimension &#8220;time&#8221; and the units &#8220;seconds&#8221;</p>
</li>
</ul></div></div><br></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5190312"></a>2.3.3.2. Semantics</h4></div></div>
<p><a class="indexterm" name="IG31340177127"></a>The metric's semantics describe how PCP tools should interpret the metric's value. The following are the possible  semantic types:</p>
<div class="itemizedlist"><ul type="disc"><li><p><a class="indexterm" name="IG31340177128"></a>Counter ( <tt>PM_SEM_COUNTER</tt>)</p>
</li>
<li><p><a class="indexterm" name="IG31340177129"></a> Instantaneous value (<tt>PM_SEM_INSTANT</tt>)</p>
</li>
<li><p><a class="indexterm" name="IG31340177130"></a>Discrete value (<tt>PM_SEM_DISCRETE</tt>)</p>
</li>
</ul></div><p>A counter should be a value that monotonically increases (or monotonically decreases, which is less likely) with respect to time, so that the rate of change should be used in preference to the actual value. Rate conversion is not appropriate for metrics with instantaneous values, as the value is a snapshot and there is no basis for assuming any values that might have been observed between snapshots. Discrete is similar to instantaneous; however, once observed it is presumed the value will persist for an extended period (for example, system configuration, static tuning parameters and most metrics with nonnumeric values).</p>
<p><a class="indexterm" name="IG31340177131"></a> <a class="indexterm" name="IG31340177132"></a> <a class="indexterm" name="IG31340177133"></a>For a given time interval covering six consecutive timestamps, each spanning two units of time, themetric values, in <a href="ch02.html#Z963522765sdc" title="Example 2-9. Effect of Semantics on a Metric">Example 2-9</a>, are exported from a PMDA (&#8220;N/A&#8221; implies no value is available): </p>
<div class="example"><a name="Z963522765sdc"></a><p><a name="Z963522765sdc"></a><b>Example 2-9. Effect of Semantics on a Metric</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">Timestamps:         1   3   5   7   9  11 
Value:             10  30  60  80  90 N/A</pre></td></tr></table><p>The default display of the values would be as follows:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">Timestamps:         1   3   5   7   9  11 
Semantics: 
Counter           N/A  10  15  10   5 N/A 
Instantaneous      10  30  60  80  90 N/A 
Discrete           10  30  60  80  90  90</pre></td></tr></table><br></div><br></div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5190481"></a>2.3.4. Instances</h3></div></div>
<p>Singular metrics have only one value and no associated instance domain. Some metrics contain a set of values that share a common set of semantics for a specific instance, such as one value per processor, or one value per disk spindle, and so on.</p>
<div class="note"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/note.png" height="24" width="24"></td><td align="left" valign="top"><b>Note: </b>The PMDA implementation is solely responsible for choosing the instance identifiers that differentiate instances within the instance domain. The PMDA is also responsible for ensuring the uniqueness of instance identifiers in any instance domain.
</td></tr></table><hr noshade="noshade"></div><br><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5190506"></a>2.3.4.1. N Dimensional Data</h4></div></div>
<p><a class="indexterm" name="IG31340177134"></a>Where the performance data can be represented as scalar values (singular metrics) or one-dimensional arrays or lists (metrics with an instance domain), the PCP framework is more than adequate. In the case of metrics with an instance domain, each array or list element is associated with an instance from the instance domain.</p>
<p><a class="indexterm" name="IG31340177135"></a><a class="indexterm" name="IG31340177136"></a>To represent two or more dimensional arrays, the coordinates must be one of the following: </p>
<div class="itemizedlist"><ul type="disc"><li><p>Mapped onto one dimensional coordinates.</p>
</li>
<li><p>Enumerated into the Performance Metrics Name Space (PMNS).</p>
</li>
</ul></div><p>For example, this 2 x 3 array of values called M can be represented as instances 1,..., 6 for a metric M:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">  M[1]   M[2]   M[3] 
  M[4]   M[5]   M[6]</pre></td></tr></table><p>Or  they can be represented as instances 1, 2, 3 for metric M1 and instances 1, 2, 3 for metric M2:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">  M1[1]  M1[2]  M1[3] 
  M2[1]  M2[2]  M2[3]</pre></td></tr></table><p>The PMDA implementer must decide and consistently export this encoding from the N-dimensional instrumentation to the 1-dimensional data model of the PCP.</p>
<p>In certain special cases (for example, such as for a histogram), it may be appropriate to export an array of values as raw binary data (the type encoding in the descriptor is <tt>PM_TYPE_AGGREGATE</tt>). However, this requires the development of special PMAPI client tools, because the standard PCP tools have no knowledge of the structure and interpretation of the binary data.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5190626"></a>2.3.4.2. Data Structures</h4></div></div>
<p><a class="indexterm" name="IG31340177137"></a><a class="indexterm" name="IG31340177138"></a>If the PMDA is required to support instance domains, then for each instance domain the unique internal instance identifier and external instance identifier should be defined using a <tt>pmdaInstid</tt> structure as shown in <a href="ch02.html#Z975964618sdc" title="Example 2-10. pmdaInstid Structure">Example 2-10</a>:</p>
<div class="example"><a name="Z975964618sdc"></a><p><a name="Z975964618sdc"></a><b>Example 2-10. <tt>pmdaInstid</tt> Structure</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">typedef struct { 
    int         i_inst;         /* internal instance identifier */ 
    char        *i_name;        /* external instance identifier */ 
} pmdaInstid;</pre></td></tr></table><p>The <tt>i_inst</tt> instance identifier  must be a unique integer within a particular instance domain.</p>
</div><p><a class="indexterm" name="IG31340177139"></a>The complete instance domain description is specified in a <tt>pmdaIndom</tt>  structure as shown in <a href="ch02.html#Z975964773sdc" title="Example 2-11. pmdaIndom  Structure">Example 2-11</a>:</p>
<div class="example"><a name="Z975964773sdc"></a><p><a name="Z975964773sdc"></a><b>Example 2-11. <tt>pmdaIndom</tt>  Structure</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">typedef struct { 
    pmInDom     it_indom;       /* indom, filled in */ 
    int         it_numinst;     /* number of instances */ 
    pmdaInstid  *it_set;        /* instance identifiers */ 
} pmdaIndom;</pre></td></tr></table><br></div><p><a class="indexterm" name="IG31340177140"></a><a class="indexterm" name="IG31340177141"></a>The <tt>it_indom</tt> element contains a <tt>pmInDom</tt> that must be unique across every PMDA. The other fields of the <tt>pmdaIndom</tt> structure are the number of instances in the instance domain and a pointer to an array of instance descriptions.</p>
<p><a href="ch02.html#Z975964872sdc" title="Example 2-12. _pmInDom_int Structure in IRIX">Example 2-12</a> for IRIX and  <a href="ch02.html#Z1033578294tls" title="Example 2-13. _pmInDom_int Structure in Linux">Example 2-13</a> for Linux shows that the <tt>pmInDom</tt> can be safely cast to <tt>_pmInDom_int</tt>, which specifies the PMDA's domain and the instance number  within the PMDA:</p>
<div class="example"><a name="Z975964872sdc"></a><p><a name="Z975964872sdc"></a><b>Example 2-12. <tt>_pmInDom_int</tt> Structure in IRIX</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">typedef struct { 
        int             pad:2; 
        unsigned int    domain:8;   /* the administrative PMD */ 
        unsigned int    serial:22;  /* unique within PMD */ 
} _pmInDom_int;</pre></td></tr></table><br></div><p><div class="example"><a name="Z1033578294tls"></a><p><a name="Z1033578294tls"></a><b>Example 2-13. <tt>_pmInDom_int</tt> Structure in Linux</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">typedef struct { 
        unsigned int    serial:22;  /* unique within PMD */         
        unsigned int    domain:8;   /* the administrative PMD */ 
        int             pad:2;
} _pmInDom_int;</pre></td></tr></table><br></div><br></p>
<p>As with metrics, the PMDA domain number is not necessarily known until run time; so the <tt>domain</tt> field must be set up when the PMDA is initialized.</p>
<p><a class="indexterm" name="IG31340177142"></a>For information about how an instance domain may also be associated with more than one metric, see the <tt>pmdaInit(3)</tt> man page.</p>
<p>The  simple PMDA, shown in <a href="ch02.html#Z963524114sdc" title="Example 2-14. Simple PMDA">Example 2-14</a>, has five metrics and two instance domains of three instances.</p>
<div class="example"><a name="Z963524114sdc"></a><p><a name="Z963524114sdc"></a><b>Example 2-14. Simple PMDA</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">/* 
 * list of instances 
 */ 
static pmdaInstid color[] = {
    { 0, &#8220;red&#8221; }, { 1, &#8220;green&#8221; }, { 2, &#8220;blue&#8221; }
};
static pmdaInstid       *timenow = NULL;
static unsigned int     timesize = 0;
/*
 * list of instance domains
 */
static pmdaIndom indomtab[] = {
#define COLOR_INDOM     0
    { COLOR_INDOM, 3, color },
#define NOW_INDOM       1
    { NOW_INDOM, 0, NULL },
};
/*
 * all metrics supported in this PMDA - one table entry for each
 */
static pmdaMetric metrictab[] = {
/* numfetch */
    { NULL,
      { PMDA_PMID(0,0), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_INSTANT,
       PMDA_PMUNITS ( 0,0,0,0,0,0) }, },
/* color */
    { NULL,
      { PMDA_PMID(0,1), PM_TYPE_32, COLOR_INDOM, PM_SEM_INSTANT,
        PMDA_PMUNITS ( 0,0,0,0,0,0) }, },
/* time.user */
    { NULL,
      { PMDA_PMID(1,2), PM_TYPE_DOUBLE, PM_INDOM_NULL, PM_SEM_COUNTER,
        PMDA_PMUNITS ( 0, 1, 0, 0, PM_TIME_SEC, 0 ) }, },
/* time.sys */
    { NULL,
      { PMDA_PMID(1,3), PM_TYPE_DOUBLE, PM_INDOM_NULL, PM_SEM_COUNTER,
        PMDA_PMUNITS ( 0, 1, 0, 0, PM_TIME_SEC, 0 ) }, },
/* now */
    { NULL,
      { PMDA_PMID(2,4), PM_TYPE_U32, NOW_INDOM, PM_SEM_INSTANT,
        PMDA_PMUNITS { 0,0,0,0,0,0 } }, },
};</pre></td></tr></table><br></div><p><a class="indexterm" name="IG31340177143"></a>The metric <tt>simple.color</tt> is associated, via <tt>COLOR_INDOM</tt>,  with the first instance domain listed in <tt>indomtab</tt>. PMDA initialization assigns the correct domain portion of the instance domain identifier in <tt>indomtab[0].it_indom</tt> and <tt>metrictab[1].m_desc.indom</tt>. This instance domain has three instances: red, green, and blue.</p>
<p>The metric <tt>simple.now</tt> is associated, via <tt>NOW_INDOM</tt>, <a class="indexterm" name="IG31340177144"></a> with the second instance domain listed in <tt>indomtab</tt>. PMDA initialization assigns the correct domain portion of the instance domain identifier in <tt>indomtab[1].it_indom</tt> and <tt>metrictab[4].m_desc.indom</tt>. This instance domain is dynamic and initially has no instances.</p>
<p><a class="indexterm" name="IG31340177145"></a>All other metrics are singular, as specified by <tt>PM_INDOM_NULL</tt>.</p>
<p>In some cases an instance domain may vary dynamically after PMDA initialization (for example, <tt>simple.now</tt>), and this requires some refinement of the default functions and data structures of the <tt>libpcp_pmda</tt> library. Briefly, this involves providing new functions that act as wrappers for <tt>pmdaInstance</tt> and <tt>pmdaFetch</tt> while understanding the dynamics of the instance domain, and then overriding the instance and fetch methods in the <tt>pmdaInterface</tt> structure during PMDA initialization.</p>
<p>For the simple PMDA, the wrapper functions are <tt>simple_fetch</tt> and <tt>simple_instance</tt>, and defaults are over-ridden by the following assignments in the <tt>simple_init</tt> function:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">dp-&gt;version.two.fetch = simple_fetch;
dp-&gt;version.two.instance = simple_instance;</pre></td></tr></table><br></div></div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5191164"></a>2.4. Other Issues</h2></div></div>
<p>Other issues include extracting the information, latency and threads of control, Name Space , PMDA help text, and management of evolution within a PMDA.</p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5191177"></a>2.4.1. Extracting the Information</h3></div></div>
<p><a class="indexterm" name="IG31340177146"></a>A suggested approach to writing a PMDA is to write a standalone program to extract the values from the target domain and then incorporate this program into the PMDA framework. This approach avoids concurrent debugging of two distinct problems:<p><div class="itemizedlist"><ul type="disc"><li><p><a class="indexterm" name="IG31340177147"></a> Extraction of the data</p>
</li>
<li><p>Communication with PMCD</p>
</li>
</ul></div></p>
<p><a class="indexterm" name="IG31340177148"></a>These are some possible ways of exporting the data from the target domain:</p>
<div class="itemizedlist"><ul type="disc"><li><p>Accumulate the performance data in a public shared memory segment.</p>
</li>
<li><p>Write the performance data to the end of a log file.</p>
</li>
<li><p>Periodically rewrite a file with the most recent values for the performance data.</p>
</li>
<li><p>Implement a protocol that allows a third party to connect to the target application, send a request, and receive new performance data.</p>
</li>
<li><p>For IRIX, if the data is in the operating system kernel, provide a system call (preferred) or global data (for a <tt>/dev/kmem</tt> reader) to export the performance data.</p>
</li>
</ul></div><p>Most of these approaches require some further data processing by the PMDA.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5191305"></a>2.4.2. Latency and Threads of Control</h3></div></div>
<p><a class="indexterm" name="IG31340177149"></a><a class="indexterm" name="IG31340177150"></a><a class="indexterm" name="IG31340177151"></a>The PCP protocols expect PMDAs to return the current values for performance metrics when requested, and with short delay (low latency). For some target domains, access to the underlying instrumentation may be costly or involve unpredictable  delays (for example, if the real performance data is stored on some remote host or network device). In these cases, it may be necessary to separate probing for new performance data from servicing PMCD requests.</p>
<p><a class="indexterm" name="IG31340177152"></a>An architecture that has been used successfully for several PMDAs is to create one or more <tt>sproc</tt> child processes to  obtain information while the main process communicates with PMCD; see the <tt>sproc(2)</tt> man page.<div class="note"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/note.png" height="24" width="24"></td><td align="left" valign="top"><b>Note: </b>The <tt>sproc(2)</tt> function is not available on Linux. You can use the <tt>exec(2)</tt>/<tt>fork(2)</tt> and <tt>setgpid(2)</tt> calls as an alternative.
</td></tr></table><hr noshade="noshade"></div><br></p>
<p>At the simplest deployment of this arrangement, the two processes may execute without synchronization. Pthreads have also been used as a more portable multithreading mechanism; see the <tt>pthreads(5)</tt> man page.</p>
<p>By contrast, a complex deployment would be one in which the refreshing of the metric values must be atomic, and this may require double buffering of the data structures. It also requires coordination between parent and child processes.</p>
<div class="tip"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/tip.png" height="24" width="25"></td><td align="left" valign="top"><b>Tip: </b>Since PMAPI is not thread-safe, only one PMDA process or thread of control should call any PMAPI functions, and this would typically be the thread servicing requests from the PMCD.
</td></tr></table><hr noshade="noshade"></div><p><a class="indexterm" name="IG31340177153"></a>One caveat about this style of  caching PMDA--it is generally better if the PMDA converts counts to rates based upon consecutive periodic sampling from the underlying instrumentation. By exporting precomputed rate metrics with instantaneous semantics, the PMDA prevents the PCP monitor tools from computing their own rates upon consecutive PMCD fetches (which are likely to return identical values from a caching PMDA).</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="LE83854-PARENT"></a>2.4.3. Name Space</h3></div></div>
<p><a class="indexterm" name="IG31340177154"></a><a class="indexterm" name="IG31340177155"></a>The PMNS file defines the name space of the PMDA. It is a simple text file that is used during installation to expand the Name Space of the PMCD process. The format of this file is described by the <tt>pmns(4)</tt> man page.</p>
<p>Client processes will not be able to access the PMDA metrics if the PMNS file is not installed as part of the PMDA installation procedure on the collector host. The installed list of metric names and their corresponding PMIDs can be found in <tt>/var/pcp/pmns/root</tt>.</p>
<p><a class="indexterm" name="IG31340177156"></a><a href="ch02.html#Z963526380sdc" title="Example 2-15. pmns File for the Simple PMDA">Example 2-15</a> shows the simple PMDA, which has five metrics:<p><div class="itemizedlist"><ul type="disc"><li><p>Three metrics immediately under the <tt>simple</tt> node</p>
</li>
<li><p>Two metrics under another non-terminal node called <tt>simple.time</tt></p>
</li>
</ul></div></p>
<div class="example"><a name="Z963526380sdc"></a><p><a name="Z963526380sdc"></a><b>Example 2-15. <tt>pmns</tt> File for the Simple PMDA</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">simple {
    numfetch    SIMPLE:0:0
    color       SIMPLE:0:1
    time
    now         SIMPLE:2:4
}
simple.time {
    user        SIMPLE:1:2
    sys         SIMPLE:1:3
}</pre></td></tr></table><br></div><p>Metrics that have different clusters do not have to be specified in different subtrees of the PMNS.  <a href="ch02.html#Z976046292sdc" title="Example 2-16. Alternate pmns File for the Simple PMDA">Example 2-16</a> shows an alternative PMNS for the simple PMDA:</p>
<div class="example"><a name="Z976046292sdc"></a><p><a name="Z976046292sdc"></a><b>Example 2-16. Alternate <tt>pmns</tt> File for the Simple PMDA</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">simple { 
    numfetch    SIMPLE:0:0 
    color       SIMPLE:0:1 
    usertime    SIMPLE:1:2 
    systime     SIMPLE:1:3 
}</pre></td></tr></table><p>In this example, the <tt>SIMPLE</tt> macro is replaced by the domain number listed in <tt>/var/pcp/pmns/stdpmid</tt> for the corresponding PMDA during installation (for the simple PMDA, this would normally be the value 253).</p>
</div><br></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="LE72473-PARENT"></a>2.4.4. PMDA Help Text</h3></div></div>
<p><a class="indexterm" name="IG31340177157"></a><a class="indexterm" name="IG31340177158"></a>For each metric defined within a PMDA, the PMDA developer is strongly encouraged to provide both terse and extended help text to describe the metric, and perhaps provide hints about the expected value ranges.</p>
<p><a class="indexterm" name="IG31340177159"></a>The help text is used to describe each metric in the visualization tools and <tt>pminfo</tt> with the <tt>-T</tt> option. The help text, such as the help text for the simple PMDA in <a href="ch02.html#Z963526754sdc" title="Example 2-17. Help Text for the Simple PMDA">Example 2-17</a>, is specified in a specially formatted file, normally called <tt>help</tt>. This file is converted to the expected run-time format using the <tt>newhelp</tt> command; see the <tt>newhelp(1)</tt> man page. Converted help text files are usually placed in the PMDA's directory below <tt>/var/pcp/pmdas</tt> as part of the PMDA installation procedure.</p>
<div class="example"><a name="Z963526754sdc"></a><p><a name="Z963526754sdc"></a><b>Example 2-17. Help Text for the Simple PMDA</b></p>
<p>The two instance domains and five metrics have a short and a verbose description. Each entry begins with a line that starts with the character &#8220;@&#8221; and is followed by either the metric name (<tt>simple.numfetch</tt>) or a symbolic reference to the instance domain number (<tt>SIMPLE.1</tt>), followed by the short description. The verbose description is on the following lines, terminated by the next line starting with &#8220;@&#8221; or end of file:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">@ SIMPLE.1 Instance domain &#8220;colour&#8221; for simple PMDA
Universally 3 instances, &#8220;red&#8221; (0), &#8220;green&#8221; (1) and &#8220;blue&#8221; (3).

@ SIMPLE.2 Dynamic instance domain &#8220;time&#8221; for simple PMDA
An instance domain is computed on-the-fly for exporting current time
information. Refer to the help text for simple.now for more details.

@ simple.numfetch Number of pmFetch operations.
The cumulative number of pmFetch operations directed to &#8220;simple&#8221; PMDA.

This counter may be modified with pmstore(1).

@ simple.color Metrics which increment with each fetch
This metric has 3 instances, designated &#8220;red&#8221;, &#8220;green&#8221; and &#8220;blue&#8221;.

The value of the metric is monotonic increasing in the range 0 to
255, then back to 0.  The different instances have different starting
values, namely 0 (red), 100 (green) and 200 (blue).

The metric values my be altered using pmstore(1).

@ simple.time.user Time agent has spent executing user code
The time in seconds that the CPU has spent executing agent user code.

@ simple.time.sys Time agent has spent executing system code
The time in seconds that the CPU has spent executing agent system code.

@ simple.now Time of day with a configurable instance domain
The value reflects the current time of day through a dynamically
reconfigurable instance domain.  On each metric value fetch request,
the agent checks to see whether the configuration file in
/var/pcp/pmdas/simple/simple.conf has been modified - if it has then
the file is re-parsed and the instance domain for this metric is again
constructed according to its contents.

This configuration file contains a single line of comma-separated time
tokens from this set:
  &#8220;sec&#8221;  (seconds after the minute),
  &#8220;min&#8221;  (minutes after the hour),
  &#8220;hour&#8221; (hour since midnight).

An example configuration file could be:  sec,min,hour
and in this case the simple.now metric would export values for the
three instances &#8220;sec&#8221;, &#8220;min&#8221; and &#8220;hour&#8221; corresponding respectively to
the components seconds, minutes and hours of the current time of day.

The instance domain reflects each token present in the file, and the
values reflect the time at which the PMDA processes the fetch.</pre></td></tr></table><br></div><br></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5191869"></a>2.4.5. Management of Evolution within a PMDA</h3></div></div>
<p><a class="indexterm" name="IG31340177160"></a><a class="indexterm" name="IG31340177161"></a>Evolution of a PMDA, or more particularly the underlying instrumentation to which it provides access, over time naturally results in the appearance of new metrics and the disappearance of old metrics. This  creates potential problems for PMAPI clients and PCP tools that may be required to interact with both new and former versions of the PMDA.</p>
<p>The following guidelines are intended to help reduce the complexity of implementing a PMDA in the face of evolutionary change, while maintaining predictability and semantic coherence for tools using the PMAPI, and for end users of those tools.</p>
<div class="itemizedlist"><ul type="disc"><li><p><a class="indexterm" name="IG31340177162"></a>Try to  support as full a range of metrics as possible in every version of the PMDA. In this context, <i>support</i> means responding sensibly to requests, even if the underlying instrumentation is not available.</p>
</li>
<li><p><a class="indexterm" name="IG31340177163"></a><a class="indexterm" name="IG31340177164"></a><a class="indexterm" name="IG31340177165"></a>If a metric is not supported in a given version of the underlying instrumentation, the PMDA should respond to <tt>pmLookupDesc</tt> requests with a <tt>pmDesc</tt> structure whose <tt>type</tt> field has the special value  <tt>PM_TYPE_NOSUPPORT</tt>. Values of fields other than <tt>pmid</tt> and <tt>type</tt> are immaterial, but <a href="ch02.html#Z976047129sdc" title="Example 2-18.  Setting Values">Example 2-18</a> is typically benign:</p>
<div class="example"><a name="Z976047129sdc"></a><p><a name="Z976047129sdc"></a><b>Example 2-18.  Setting Values</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">pmDesc dummy = { 
     PMDA_PMID(3,0),        /* pmid, fill this in */
     PM_TYPE_NOSUPPORT,     /* this is the important part */
     PM_INDOM_NULL,         /* singular,causes no problems */
    0,                     /* no semantics */
     { 0, 0, 0, 0, 0, 0 }   /* no units */
};</pre></td></tr></table><br></div><br></li>
<li><p><a class="indexterm" name="IG31340177166"></a><a class="indexterm" name="IG31340177167"></a>If a metric lacks support in a particular version of the underlying instrumentation, the PMDA should respond to <tt>pmFetch</tt> requests with a <tt>pmResult</tt> in which no values are returned for the unsupported metric. This is marginally friendlier than the other semantically acceptable option of returning an illegal PMID error or <tt>PM_ERR_PMID</tt>.</p>
</li>
<li><p><a class="indexterm" name="IG31340177168"></a><a class="indexterm" name="IG31340177169"></a>Help text should be updated with annotations to describe different versions of the underlying product, or product configuration options, for which a specific metric is available. This is so <tt>pmLookupText</tt> can always respond correctly.</p>
</li>
<li><p><a class="indexterm" name="IG31340177170"></a><a class="indexterm" name="IG31340177171"></a>The <tt>pmStore</tt> operation should fail with return status of <tt>-EACCES</tt> if a user or application tries to amend the value of an unsupported metric.</p>
</li>
<li><p><a class="indexterm" name="IG31340177172"></a><a class="indexterm" name="IG31340177173"></a><a class="indexterm" name="IG31340177174"></a><a class="indexterm" name="IG31340177175"></a><a class="indexterm" name="IG31340177176"></a><a class="indexterm" name="IG31340177177"></a> The value extraction, conversion, and printing functions (<tt>pmExtractValue</tt>, <tt>pmConvScale</tt>, <tt>pmAtomStr</tt>, <tt>pmTypeStr</tt>, and <tt>pmPrintValue</tt>) return the  <tt>PM_ERR_CONV</tt> error or an appropriate diagnostic string, if an attempt is made to operate on a value for which <tt>type</tt> is <tt>PM_TYPE_NOSUPPORT</tt>.</p>
<p>If performance tools take note of the <tt>type</tt> field in the <tt>pmDesc</tt> structure, they should not manipulate values for unsupported metrics. Even if tools ignore <tt>type</tt> in the metric's description, following these development guidelines ensures that no misleading value is ever returned; so there is no reason to call the extraction, conversion, and printing functions.</p>
</li>
</ul></div></div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="LE21831-PARENT"></a>2.5. DSO Interface</h2></div></div>
<p><a class="indexterm" name="IG31340177178"></a>This section describes an interface for the request handling callbacks in a PMDA. This interface is used by PMCD for communicating with DSO PMDAs, and can also be used by daemon PMDAs with <tt>pmdaMain</tt>.</p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5192358"></a>2.5.1. Overview</h3></div></div>
<p>Both daemon and DSO PMDAs must handle multiple request types from PMCD. A daemon PMDA communicates with PMCD using the PDU protocol, while a DSO PMDA defines callbacks for each request type. To avoid duplicating this PDU processing (in the case of a PMDA that can be installed either as a daemon or as a DSO), and to allow a consistent framework, <tt>pmdaMain</tt> can be used by a daemon PMDA as a wrapper to handle the communication protocol using the same callbacks as a DSO PMDA. This allows a PMDA to be built as both a daemon and a DSO, and then to be installed as either.</p>
<p>To further simplify matters, default callbacks are declared in <tt>/usr/include/pcp/pmda.h</tt>:</p>
<div class="itemizedlist"><ul type="disc"><li><p><a class="indexterm" name="IG31340177179"></a><tt>pmdaFetch</tt></p>
</li>
<li><p><a class="indexterm" name="IG31340177180"></a><tt>pmdaProfile</tt></p>
</li>
<li><p><a class="indexterm" name="IG31340177181"></a> <tt>pmdaInstance</tt></p>
</li>
<li><p><a class="indexterm" name="IG31340177182"></a><tt>pmdaDesc</tt></p>
</li>
<li><p><a class="indexterm" name="IG31340177183"></a> <tt>pmdaText</tt></p>
</li>
<li><p><a class="indexterm" name="IG31340177184"></a> <tt>pmdaStore</tt></p>
</li>
</ul></div><p><a class="indexterm" name="IG31340177185"></a>Each callback takes a <tt>pmdaExt</tt> structure as its last argument. This structure contains all the information that is required by the default callbacks in most cases. The one exception is <tt>pmdaFetch</tt>, which needs an additional callback to instantiate the current value for each supported combination of a performance metric and an instance.</p>
<p>Therefore, for most PMDAs all the communication with PMCD is automatically handled by functions in <tt>libpcp.so</tt> and <tt>libpcp_pmda.so</tt>.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5192570"></a>2.5.1.1. Trivial PMDA</h4></div></div>
<p><a class="indexterm" name="IG31340177186"></a>The trivial PMDA uses all of the default callbacks as shown in <a href="ch02.html#Z964109292sdc" title="Example 2-19. Request Handing Callbacks in the Trivial PMDA">Example 2-19</a>. The additional callback for <tt>pmdaFetch</tt> is defined as <tt>trivial_fetchCallBack</tt>:</p>
<div class="example"><a name="Z964109292sdc"></a><p><a name="Z964109292sdc"></a><b>Example 2-19. Request Handing Callbacks in the Trivial PMDA</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">static int
trivial_fetchCallBack(pmdaMetric *mdesc, unsigned int inst, pmAtomValue *atom)
{
   __pmID_int          *idp = (__pmID_int *)&amp;(mdesc-&gt;m_desc.pmid);
   if (idp-&gt;cluster != 0 || idp-&gt;item != 0)
       return PM_ERR_PMID;
   else if (inst != PM_IN_NULL)
       return PM_ERR_INST;
   atom-&gt;l = time(NULL);
   return 0;
}</pre></td></tr></table><p><a class="indexterm" name="IG31340177187"></a>This function checks that the PMID and instance are valid, and then places the metric value for the current time into the <tt>pmAtomValue</tt> structure. The callback is set up by a call to <tt>pmdaSetFetchCallBack</tt> in <tt>trivial_init</tt>.</p>
</div><br></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5192681"></a>2.5.1.2. Simple PMDA</h4></div></div>
<p><a class="indexterm" name="IG31340177188"></a><a class="indexterm" name="IG31340177189"></a>The simple PMDA callback for <tt>pmdaFetch</tt> is more complicated because it must support more metrics, some metrics are instantiated with each fetch, and one instance domain is dynamic. The default <tt>pmdaFetch</tt> callback, shown in <a href="ch02.html#Z964110950sdc" title="Example 2-20. Request Handing Callbacks in the Simple PMDA">Example 2-20</a>, is replaced by <tt>simple_fetch</tt> in <tt>simple_init</tt>, which increments the number of fetches and updates the instance domain for<tt>INDOM_NOW</tt> before calling <tt>pmdaFetch</tt>:</p>
<div class="example"><a name="Z964110950sdc"></a><p><a name="Z964110950sdc"></a><b>Example 2-20. Request Handing Callbacks in the Simple PMDA</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">static int
simple_fetch(int numpmid, pmID pmidlist[], pmResult **resp, pmdaExt *pmda)
{
    numfetch++;
    simple_timenow_check();
    simple_timenow_refresh();
    return pmdaFetch(numpmid, pmidlist, resp, pmda);
}</pre></td></tr></table><br></div><p><a class="indexterm" name="IG31340177190"></a>The callback for <tt>pmdaFetch</tt> is defined as <tt>simple_fetchCallBack</tt>. The PMID is extracted from the <tt>pmdaMetric</tt> structure, and if valid, the appropriate field in the <tt>pmAtomValue</tt> structure is set.</p>
<p>The <tt>simple.numfetch</tt> metric has no instance domain and is easily handled first as shown in <a href="ch02.html#Z976306482sdc" title="Example 2-21. simple.numfetch Metric">Example 2-21</a>:</p>
<div class="example"><a name="Z976306482sdc"></a><p><a name="Z976306482sdc"></a><b>Example 2-21. <tt>simple.numfetch</tt> Metric</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">static int
simple_fetchCallBack(pmdaMetric *mdesc, unsigned int inst, pmAtomValue *atom)
{
   int                 i;
   static int          oldfetch = 0;
   static struct tms   tms;
   __pmID_int          *idp = (__pmID_int *)&amp;(mdesc-&gt;m_desc.pmid);
   if (inst != PM_IN_NULL &amp;&amp;
       !(idp-&gt;cluster == 0 &amp;&amp; idp-&gt;item == 1) &amp;&amp;
       !(idp-&gt;cluster == 2 &amp;&amp; idp-&gt;item == 4))
       return PM_ERR_INST;
   if (idp-&gt;cluster == 0) {
       if (idp-&gt;item == 0) {                   /* simple.numfetch */
           atom-&gt;l = numfetch;
       }</pre></td></tr></table><br></div><p><a class="indexterm" name="IG31340177191"></a>In <a href="ch02.html#Z976049747sdc" title="Example 2-22. simple.color Metric">Example 2-22</a>, the <tt>inst</tt> parameter is used to specify which instance is required for the <tt>simple.color</tt> metric:</p>
<div class="example"><a name="Z976049747sdc"></a><p><a name="Z976049747sdc"></a><b>Example 2-22. <tt>simple.color</tt> Metric</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">       else if (idp-&gt;item == 1) {              /* simple.color */
            switch (inst) {
            case 0:                             /* red */
                red = (red + 1) % 256;
                atom-&gt;l = red;
                break;
            case 1:                             /* green */
                green = (green + 1) % 256;
                atom-&gt;l = green;
                break;
            case 2:                             /* blue */
                blue = (blue + 1) % 256;
                atom-&gt;l = blue;
                break;
            default:
                return PM_ERR_INST;
            }
       }
       else
           return PM_ERR_PMID;</pre></td></tr></table><br></div><p><a class="indexterm" name="IG31340177192"></a>In <a href="ch02.html#Z976049353sdc" title="Example 2-23. simple.time Metric">Example 2-23</a>, the <tt>simple.time</tt> metric is in a second cluster and has a simple optimization to reduce the overhead of calling <tt>times</tt> twice on the same fetch and return consistent values from a single call to <tt>times</tt> when both metrics <tt>simple.time.user</tt> and <tt>simple.time.sys</tt> are requested in a single <tt>pmFetch</tt>. The previous fetch count is used to determine if the <tt>tms</tt> structure should be updated:</p>
<div class="example"><a name="Z976049353sdc"></a><p><a name="Z976049353sdc"></a><b>Example 2-23. <tt>simple.time</tt> Metric</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">   else if (idp-&gt;cluster == 1) {               /* simple.time */
       if (oldfetch &lt; numfetch) {
           times(&amp;tms);
           oldfetch = numfetch;
       }
       if (idp-&gt;item == 2)                     /* simple.time.user */
           atom-&gt;d = (tms.tms_utime / (double)CLK_TCK);
       else if (idp-&gt;item == 3)                /* simple.time.sys */
           atom-&gt;d = (tms.tms_stime / (double)CLK_TCK);
       else
           return PM_ERR_PMID;
    }</pre></td></tr></table><br></div><p><a class="indexterm" name="IG31340177193"></a>In <a href="ch02.html#Z976049020sdc" title="Example 2-24. simple.now Metric">Example 2-24</a>, the <tt>simple.now</tt> metric is in a third cluster and uses <tt>inst</tt> again to select a specific instance from the <tt>INDOM_NOW</tt> instance domain:</p>
<div class="example"><a name="Z976049020sdc"></a><p><a name="Z976049020sdc"></a><b>Example 2-24. <tt>simple.now</tt> Metric</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">    else if (idp-&gt;cluster == 2) {
        if (idp-&gt;item == 4) {                 /* simple.now */
            /* this loop will always match one of the named */
            /* time constants from the timeslices structure */
            for (i = 0; i &lt; num_timeslices; i++) {
                if (inst == timeslices[i].inst_id) {
                    atom-&gt;l = timeslices[i].tm_field;
                    break;
                }
            }
            if (i == num_timeslices)
                return PM_ERR_INST;
        }
        else 
            return PM_ERR_PMID;
    }</pre></td></tr></table><br></div><br></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5193108"></a>2.5.1.3. <tt>simple_store</tt> in the Simple PMDA</h4></div></div>
<p><a class="indexterm" name="IG31340177194"></a><a class="indexterm" name="IG31340177195"></a>The simple PMDA permits some of the metrics it supports to be modified by <tt>pmStore</tt> as shown in <a href="ch02.html#Z964111850sdc" title="Example 2-25. simple_store in the Simple PMDA">Example 2-25</a>. For additional information, see the <tt>pmstore(1)</tt> man page.</p>
<div class="example"><a name="Z964111850sdc"></a><p><a name="Z964111850sdc"></a><b>Example 2-25. <tt>simple_store</tt> in the Simple PMDA</b></p>
<p><a class="indexterm" name="IG31340177196"></a>The <tt>pmdaStore</tt> callback (which returns <tt>-EACCESS</tt> to indicate no metrics can be altered) is replaced by <tt>simple_store</tt> in <tt>simple_init</tt>. This replacement function must take the same arguments so that it can be assigned to the function pointer in the <tt>pmdaInterface</tt> structure.</p>
<p>The function traverses the <tt>pmResult</tt> and checks the cluster and unit of each PMID to ensure that it corresponds to a metric that can be changed. Checks are made on the values to ensure they are within range before being assigned to variables in the PMDA that hold the current values for exported metrics:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">static int
simple_store(pmResult *result, pmdaExt *pmda)
{
   int         i, j, val, sts = 0;
   pmAtomValue av;
   pmValueSet  *vsp = NULL;
   __pmID_int  *pmidp = NULL;
   for (i = 0; i &lt; result-&gt;numpmid; i++) {
       vsp = result-&gt;vset[i];
       pmidp = (__pmID_int *)&amp;vsp-&gt;pmid;
       if (pmidp-&gt;cluster == 0) {  /* storable metrics are cluster0 */
           switch (pmidp-&gt;item) {
               case 0:                           /* simple.numfetch */
                   val = vsp-&gt;vlist[0].value.lval;
                   if (val &lt; 0) {
                       sts = PM_ERR_SIGN;
                       val = 0;
                   }
                   numfetch = val;
                   break;
               case 1:                             /* simple.color */
                   for (j = 0; j &lt; vsp-&gt;numval &amp;&amp; sts == 0; j++) {
                       val = vsp-&gt;vlist[j].value.lval;
                       if (val &lt; 0) {
                           sts = PM_ERR_SIGN;
                           val = 0;
                       } if (val &gt; 255) {
                           sts = PM_ERR_CONV;
                           val = 255;
                       }</pre></td></tr></table><br></div><p><a class="indexterm" name="IG31340177197"></a>The <tt>simple.color</tt> metric has an instance domain that must be searched because any or all instances may be specified. Any instances that are not supported in this instance domain should cause an error value of <tt>PM_ERR_INST</tt> to be returned as shown in <a href="ch02.html#Z976051081sdc" title="Example 2-26. simple.color and PM_ERR_INST Errors">Example 2-26</a>:</p>
<div class="example"><a name="Z976051081sdc"></a><p><a name="Z976051081sdc"></a><b>Example 2-26. <tt>simple.color</tt> and <tt>PM_ERR_INST</tt> Errors</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">                       switch (vsp-&gt;vlist[j].inst) {
                           case 0:                         /* red */
                               red = val;
                               break;
                           case 1:                         /* green */
                               green = val;
                               break;
                           case 2:                         /* blue */
                               blue = val;
                               break;
                           default:
                               sts = PM_ERR_INST;
                       }</pre></td></tr></table><br></div><p><a class="indexterm" name="IG31340177198"></a>Any other PMIDs in cluster 0 that are not supported by the simple PMDA should result in an error value  of <tt>PM_ERR_PMID</tt> as shown in <a href="ch02.html#Z976307148sdc" title="Example 2-27. PM_ERR_PMID Errors">Example 2-27</a>:</p>
<div class="example"><a name="Z976307148sdc"></a><p><a name="Z976307148sdc"></a><b>Example 2-27. <tt>PM_ERR_PMID</tt> Errors</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">               default:
                   sts = PM_ERR_PMID;
                   break;
           }
       }</pre></td></tr></table><br></div><p>Any metrics that cannot be altered should generate an error value of <tt>-EACCES</tt>, and metrics not supported by the PMDA should result in an error value of <tt>PM_ERR_PMID</tt> as shown in <a href="ch02.html#Z976050822sdc" title="Example 2-28. -EACCES and PM_ERR_PMID Errors">Example 2-28</a>:</p>
<div class="example"><a name="Z976050822sdc"></a><p><a name="Z976050822sdc"></a><b>Example 2-28. <tt>-EACCES</tt> and <tt>PM_ERR_PMID</tt> Errors</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">       else if ((pmidp-&gt;cluster == 1 &amp;&amp;
                (pmidp-&gt;item == 2 || pmidp-&gt;item == 3)) ||
                (pmidp-&gt;cluster == 2 &amp;&amp; pmidp-&gt;item == 4)) {
           sts = -EACCES;
           break;
       }
       else {
           sts = PM_ERR_PMID;
           break;
       }
   }
   return sts;
}</pre></td></tr></table><p>The structure <tt>pmdaEx</tt><i>t</i> argument is not used by the <tt>simple_store</tt> function above.</p>
</div><br></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5193469"></a>2.5.1.4. Return Codes for <tt>pmdaFetch</tt> Callbacks</h4></div></div>
<p>In <tt>PMDA_INTERFACE_1</tt> and <tt>PMDA_INTERFACE_2</tt>, the return codes for the <tt>pmdaFetch</tt> callback function are defined:</p>
<div class="variablelist"><table border="0" cellspacing="3"><tr valign="top"><td><span class="term">Value</span></td><td width="10"> </td><td><p>Meaning</p>

</td></tr><tr valign="top"><td><span class="term">&lt; 0</span></td><td width="10"> </td><td><p>Error code (for example, <tt>PM_ERR_PMID</tt>, <tt>PM_ERR_INST</tt> or <tt>PM_ERR_AGAIN</tt>)</p>

</td></tr><tr valign="top"><td><span class="term">0</span></td><td width="10"> </td><td><p>Success</p>

</td></tr></table></div><p>In <tt>PMDA_INTERFACE_3</tt>, the return codes for the <tt>pmdaFetch</tt> callback function are defined:</p>
<div class="variablelist"><table border="0" cellspacing="3"><tr valign="top"><td><span class="term">Value</span></td><td width="10"> </td><td><p>Meaning</p>

</td></tr><tr valign="top"><td><span class="term">&lt; 0</span></td><td width="10"> </td><td><p>Error code (for example, <tt>PM_ERR_PMID</tt>, <tt>PM_ERR_INST</tt>)</p>

</td></tr><tr valign="top"><td><span class="term">0</span></td><td width="10"> </td><td><p>Metric value not currently available</p>

</td></tr><tr valign="top"><td><span class="term">&gt; 0</span></td><td width="10"> </td><td><p>Success</p>

</td></tr></table></div></div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5193658"></a>2.5.2. PMDA Structures</h3></div></div>
<p><a class="indexterm" name="IG31340177199"></a>PMDA structures used with the <tt>pcp_pmda</tt> library are defined in <tt>/usr/include/pcp/pmda.h</tt>.  <a href="ch02.html#Z964112160sdc" title="Example 2-29. pmdaInterface Structure">Example 2-29</a> and <a href="ch02.html#Z964117744sdc" title="Example 2-30. pmdaExt Stucture">Example 2-30</a> describe the <tt>pmdaInterface</tt> and <tt>pmdaExt</tt> structures.</p>
<div class="example"><a name="Z964112160sdc"></a><p><a name="Z964112160sdc"></a><b>Example 2-29. <tt>pmdaInterface</tt> Structure</b></p>
<p><a class="indexterm" name="IG31340177200"></a>The callbacks must be specified in a <tt>pmdaInterface</tt> structure:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">typedef struct {
   int domain;     /* set/return performance metrics domain id here */
   struct {
       unsigned int pmda_interface : 8;  /* PMDA DSO version */
       unsigned int pmapi_version : 8;   /* PMAPI version */
       unsigned int flags : 16;          /* usage TBD */
   } comm;             /* set/return communication and version info */
   int status;         /* return initialization status here */
   union {
/* 
* Interface Version 2 (PCP 2.0) or later 
* PMDA_INTERFACE2, PMDA_INTERFACE3, ...
*/ 
       struct {
           pmdaExt *ext;
           int     (*profile)(__pmProfile *, pmdaExt *);
           int     (*fetch)(int, pmID *, pmResult **, pmdaExt *);
           int     (*desc)(pmID, pmDesc *, pmdaExt *);
           int     (*instance)(pmInDom, int, char *, __pmInResult **,
                   pmdaExt *);
           int     (*text)(int, int, char **, pmdaExt *);
           int     (*store)(pmResult *, pmdaExt *);
       } two;
   } version;
} pmdainterface;</pre></td></tr></table><p>This structure is passed by PMCD to a DSO PMDA as an argument to the initialization function. This structure supports two versions--the second version adds support for the <tt>pmdaExt</tt> structure. Protocol version one is for backwards compatibility only, and should not be used in any new PMDA.</p>
</div><br><div class="example"><a name="Z964117744sdc"></a><p><a name="Z964117744sdc"></a><b>Example 2-30. <tt>pmdaExt</tt> Stucture</b></p>
<p><a class="indexterm" name="IG31340177201"></a>Additional PMDA information must be specified in a <tt>pmdaExt</tt> structure:</p>
<a name="Z964117899sdc"></a><table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">typedef struct {
   unsigned int e_flags;       /* used internally within libpcp_pmda */
   void        *e_ext;         /* used internally within libpcp_pmda */
   char        *e_sockname;    /* socket name to pmcd */
   char        *e_name;        /* name of this pmda */
   char        *e_logfile;     /* path to log file */
   char        *e_helptext;    /* path to help text */
   int         e_status;       /* =0 is OK */
   int         e_infd;         /* input file descriptor from pmcd */
   int         e_outfd;        /* output file descriptor to pmcd */
   int         e_port;         /* port to pmcd */
   int         e_singular;     /* =0 for singular values */
   int         e_ordinal;      /* &gt;=0 for non-singular values */
   int         e_direct;       /* =1 if pmid map to meta table */
   int         e_domain;       /* metrics domain */
   int         e_nmetrics;     /* number of metrics */
   int         e_nindoms;      /* number of instance domains */
   int         e_help;         /* help text comes via this handle */
   __pmProfile *e_prof;        /* last received profile */
   pmdaIoType  e_io;           /* connection type to pmcd */
   pmdaIndom   *e_indoms;      /* instance domain table */
   pmdaIndom   *e_idp;         /* instance domain expansion */
   pmdaMetric  *e_metrics;     /* metric description table */
   pmdaResultCallBack e_resultCallBack; /* to clean up pmResult after fetch */
   pmdaFetchCallBack  e_fetchCallBack;  /* to assign metric values in fetch */
   pmdaCheckCallBack  e_checkCallBack;  /* callback on receipt of a PDU */
   pmdaDoneCallBack   e_doneCallBack;   /* callback after PDU is processed */
} pmdaExt;</pre></td></tr></table><p><a class="indexterm" name="IG31340177202"></a><a class="indexterm" name="IG31340177203"></a><a class="indexterm" name="IG31340177204"></a><a class="indexterm" name="IG31340177205"></a><a class="indexterm" name="IG31340177206"></a>The <tt>pmdaExt</tt> structure contains filenames, pointers to tables, and some variables shared by several functions in the <tt>pcp_pmda </tt>library. All fields of the <tt>pmdaInterface</tt> and <tt>pmdaExt</tt> structures can be correctly set by PMDA initialization functions; see the <tt>pmdaDaemon(3)</tt>, <tt>pmdaDSO(3)</tt>, <tt>pmdaGetOpt(3)</tt>, <tt>
pmdaInit(3)</tt>, and <tt>pmdaConnect(3)</tt> man pages for a full description of how various fields in these structures may be set or used by <tt>pcp_pmda</tt> library functions.</p>
</div><br></div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="LE19047-PARENT"></a>2.6. Initializing a PMDA</h2></div></div>
<p> <a class="indexterm" name="IG31340177207"></a>Several functions are provided to simplify the initialization of a PMDA. These functions, if used, must be called in a strict order so that the PMDA can operate correctly.</p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5194056"></a>2.6.1. Overview</h3></div></div>
<p><a class="indexterm" name="IG31340177208"></a>The initialization process for a PMDA involves opening help text files, assigning callback function pointers, adjusting the metric and instance identifiers to the correct domains, and much more. The initialization of a daemon PMDA also differs significantly from a DSO PMDA, since the <tt>pmdaInterface</tt> structure is initialized by <tt>main</tt> or the PMCD process, respectively.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5194087"></a>2.6.2. Common Initialization</h3></div></div>
<p><a class="indexterm" name="IG31340177209"></a>As described in <a href="ch02.html#LE82676-PARENT" title="2.2.2. DSO PMDA">Section 2.2.2</a>, an initialization function is provided by a DSO PMDA and called by PMCD. Using the standard PMDA wrappers, the same function can also be used as part of the daemon PMDA initialization. This PMDA initialization function performs the following tasks:</p>
<div class="itemizedlist"><ul type="disc"><li><p>Assigning callback functions to the function pointer interface of <tt>pmdaInterface</tt></p>
</li>
<li><p>Assigning pointers to the metric and instance tables from <tt>pmdaExt</tt></p>
</li>
<li><p><a class="indexterm" name="IG31340177210"></a>Opening the help text files</p>
</li>
<li><p>Assigning the domain number to the instance domains</p>
</li>
<li><p>Correlating metrics with their instance domains</p>
</li>
</ul></div><p><a class="indexterm" name="IG31340177211"></a><a class="indexterm" name="IG31340177212"></a>If the PMDA uses the common data structures defined for the <tt>pcp_pmda</tt> library, most of these requirements can be handled by the default <tt>pmdaInit</tt> function; see the <tt>pmdaInit(3)</tt> man page.</p>
<p>Because the initialization function is the only initialization opportunity for a DSO PMDA, the common initialization function should also perform any DSO-specific functions that are required. A default implementation of this functionality is provided by the <tt>pmdaDSO</tt> function; see the <tt>pmdaDSO(3)</tt> man page.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5194313"></a>2.6.2.1. Trivial PMDA</h4></div></div>
<p><a class="indexterm" name="IG31340177213"></a><a class="indexterm" name="IG31340177214"></a><a class="indexterm" name="IG31340177215"></a><a href="ch02.html#Z976058585sdc" title="Example 2-31. Initialization in the Trivial PMDA">Example 2-31</a> shows the trivial PMDA, which has no instances (that is, all metrics have singular values) and a single callback. This callback is for the <tt>pmdaFetch</tt> function called <tt>trivial_fetchCallBack</tt>; see the <tt>pmdaFetch(3)</tt> man page:</p>
<div class="example"><a name="Z976058585sdc"></a><p><a name="Z976058585sdc"></a><b>Example 2-31. Initialization in the Trivial PMDA</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">void trivial_init(pmdaInterface *dp)
{
   pmdaSetFetchCallBack(dp, trivial_fetchCallBack);
   pmdaInit(dp, NULL, 0,
            metrictab, sizeof(metrictab)/sizeof(metrictab[0]));
}</pre></td></tr></table><br></div><p>The trivial PMDA is always installed as a daemon PMDA.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5194416"></a>2.6.2.2. Simple PMDA</h4></div></div>
<p><a class="indexterm" name="IG31340177216"></a><a class="indexterm" name="IG31340177217"></a><a class="indexterm" name="IG31340177218"></a><a class="indexterm" name="IG31340177219"></a>In <a href="ch02.html#Z976058770sdc" title="Example 2-32. Initialization in the Simple PMDA">Example 2-32</a>, the simple PMDA uses its own callbacks to handle <tt>PDU_FETCH</tt> and <tt>PDU_RESULT</tt> request PDUs (for <tt>pmFetch</tt> and <tt>pmStore</tt> operations respectively), as well as providing <tt>pmdaFetch</tt> with the callback <tt>simple_fetchCallBack</tt>.</p>
<div class="example"><a name="Z976058770sdc"></a><p><a name="Z976058770sdc"></a><b>Example 2-32. Initialization in the Simple PMDA</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">static int      isDSO = 1;              /* =0 I am a daemon */
void simple_init(pmdaInterface *dp)
{
   if (isDSO)
       pmdaDSO(dp, PMDA_INTERFACE_2, &#8220;simple DSO&#8221;,
               &#8220;/var/pcp/pmdas/simple/help&#8221;);
   if (dp-&gt;status != 0)
       return;
   dp-&gt;version.two.fetch = simple_fetch;
   dp-&gt;version.two.store = simple_store;
   dp-&gt;version.two.instance = simple_instance;
   pmdaSetFetchCallBack(dp, simple_fetchCallBack);
   pmdaInit(dp, indomtab, sizeof(indomtab)/sizeof(indomtab[0]),
            metrictab, sizeof(metrictab)/sizeof(metrictab[0]));
}</pre></td></tr></table><br></div><p>The simple PMDA may be installed either as a daemon PMDA or a DSO PMDA. The static variable <i>isDSO</i> indicates whether the PMDA is running as a DSO or as a daemon. A daemon PMDA should change the value of this variable to 0 in <tt>main</tt>.</p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5194563"></a>2.6.3. Daemon Initialization</h3></div></div>
<p>In addition to the initialization function that can be shared by a DSO and a daemon PMDA, a daemon PMDA must also meet the following requirements:</p>
<div class="itemizedlist"><ul type="disc"><li><p>Create the <tt>pmdaInterface</tt> structure that is passed to the initialization function</p>
</li>
<li><p>Parse any command-line arguments</p>
</li>
<li><p>Open a log file (a DSO PMDA uses PMCD's log file)</p>
</li>
<li><p>Set up the IPC connection between the PMDA and the PMCD process</p>
</li>
<li><p>Handle incoming PDUs</p>
</li>
</ul></div><p><a class="indexterm" name="IG31340177220"></a><a class="indexterm" name="IG31340177221"></a><a class="indexterm" name="IG31340177222"></a><a class="indexterm" name="IG31340177223"></a><a class="indexterm" name="IG31340177224"></a>All these requirements can be handled by default initialization functions in the <tt>pcp_pmda</tt> library; see the <tt>pmdaDaemon(3)</tt>, <tt>pmdaGetOpt(3)</tt>, <tt>pmdaOpenLog(3)</tt>, <tt>pmdaConnect(3)</tt>, and <tt>pmdaMain(3)</tt> man pages.</p>
<p><a class="indexterm" name="IG31340177225"></a>The simple PMDA requires no additional command-line arguments other than those handled by <tt>pmdaGetOpt</tt> as shown in <a href="ch02.html#Z964110483sdc" title="Example 2-33. main in the Simple PMDA">Example 2-33</a>. For additional information, see the <tt>pmdaGetOpt(3)</tt> man page.</p>
<div class="example"><a name="Z964110483sdc"></a><p><a name="Z964110483sdc"></a><b>Example 2-33. <tt>main</tt> in the Simple PMDA</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int
main(int argc, char **argv)
{
   int                 err = 0;
   pmdaInterface       dispatch;
   char                *p;
   /* trim cmd name of leading directory components */
   pmProgname = argv[0];
   for (p = pmProgname; *p; p++) {
       if (*p == `/')
           pmProgname = p+1;
   }
   isDSO = 0;
   pmdaDaemon(&amp;dispatch, PMDA_INTERFACE_2, pmProgname, SIMPLE,
              &#8220;simple.log&#8221;, &#8220;/var/pcp/pmdas/simple/help&#8221;);
   if (pmdaGetOpt(argc, argv, &#8220;D:d:i:l:pu:?&#8221;, &amp;dispatch, &amp;err)) != EOF)
       err++;
   if (err)
       usage();
   pmdaOpenLog(&amp;dispatch);
   simple_init(&amp;dispatch);
   simple_timenow_check();
   pmdaConnect(&amp;dispatch);
   pmdaMain(&amp;dispatch);
   exit(0);
   /*NOTREACHED*/
}</pre></td></tr></table><br></div><br></div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5194770"></a>2.7. Testing and Debugging a PMDA</h2></div></div>
<p>Ensuring the correct operation of a PMDA can be difficult, because the responsibility of providing metrics to the requesting PMCD process and simultaneously retrieving values from the target domain requires nearly real-time communication with two modules beyond the PMDA's control. Some tools are available to assist in this important task. <a class="indexterm" name="IG31340177226"></a> <a class="indexterm" name="IG31340177227"></a></p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5194836"></a>2.7.1. Overview</h3></div></div>
<p><a class="indexterm" name="IG31340177228"></a>Thoroughly testing a PMDA with PMCD is difficult, although testing a daemon PMDA is marginally simpler than testing a DSO PMDA. If a DSO PMDA exits, PMCD also exits because they share a single address space and control thread. If the PMDA dumps core, <tt>dbx</tt> and related tools on IRIX or <tt>gdb(1)</tt> on Linux cannot reasonably explore the generated core image, which includes the PMCD image and any other active DSO PMDAs. For more information, see the <tt>dbx(1)</tt> or <tt>gdb(1)</tt>man page.</p>
<p>The difficulty in using PMCD to test a daemon PMDA results from PMCD requiring timely replies from the PMDA in response to request PDUs. Although a timeout period can be set in <tt>/etc/config/pmcd.options</tt> on IRIX or <tt>/var/pcp/config/pmcd/pmcd.options</tt> on Linux, attaching <tt>dbx</tt> or <tt>gdb</tt> to the PMDA process (or any other long delay) might cause an already running PMCD to close its connection with the PMDA. If timeouts are disabled, PMCD could wait forever to connect with the PMDA.</p>
<p>If you suspect a PMDA has been terminated due to a timeout failure, check the PMCD log file, usually <tt>/var/adm/pcplog/pmcd.log</tt> for IRIX or <tt>/var/log/pcp/pmcd/pmcd.log</tt> for Linux.</p>
<p><a class="indexterm" name="IG31340177229"></a>A more robust way of testing a PMDA is to use the <tt>dbpmda</tt> tool, which is similar to PMCD except that <tt>dbpmda</tt> provides complete control over the PDUs that are sent to the PMDA, and there are no time limits--it is essentially an interactive debugger for exercising a PMDA. See the <tt>dbpmda(3)</tt> man page for details.</p>
<p><a class="indexterm" name="IG31340177230"></a>In addition, careful use of PCP debugging flags can produce useful information concerning a PMDA's behavior; see the <tt>pmapi(3)</tt> and <tt>pmdbg(1)</tt> man pages for a discussion of the PCP debugging and tracing framework.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5195016"></a>2.7.2. Debugging Information</h3></div></div>
<p><a class="indexterm" name="IG31340177231"></a><a class="indexterm" name="IG31340177232"></a><a class="indexterm" name="IG31340177233"></a>You can activate  debugging flags in PMCD and most other PCP tools with the <tt>-D</tt> command-line option. Supported flags can be listed with the <tt>pmdbg</tt> command; see the <tt>pmdbg(1)</tt> man page. Setting the debug flag for PMCD in <tt>/etc/config/pmcd.options</tt> on IRIX or <tt>/var/pcp/config/pmcd/pmcd.options</tt> on Linux might generate too much information to be useful, especially if there are other clients and PMDAs connected to the PMCD process.</p>
<p>The PMCD debugging flag can also be changed dynamically by storing a new value into the metric <tt>pmcd.control.debug</tt>:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting"># <span class="bold"><b>pmstore pmcd.control.debug 5</b></span></pre></td></tr></table><p>Most of the <tt>pcp_pmda</tt> library functions log additional information if the <tt>DBG_TRACE_LIBPMDA</tt> flag is set within the PMDA; see the <tt>pmda(3)</tt> man page. The command-line argument <tt>-D</tt> is trapped by <tt>pmdaGetOpt</tt> to set the global debugging control variable <tt>pmDebug</tt>. Adding tests within the PMDA for the <tt>DBG_TRACE_APPL0</tt>, <tt>DBG_TRACE_APPL1</tt>, and <tt>DBG_TRACE_APPL2</tt> trace flags permits different levels of information to be logged to the PMDA's log file.</p>
<p>All diagnostic, debugging, and tracing output from a PMDA should be written to the standard error stream. By convention, all debugging information is enclosed by preprocessor <tt>#ifdef</tt> <tt>DEBUG</tt> statements so that they can be compiled out of the program at a later stage, if required.</p>
<p><a class="indexterm" name="IG31340177234"></a>Adding this segment of code to the <tt>simple_store</tt> metric causes a log message to be sent to the current log file whenever <tt>pmstore</tt> attempts to change <tt>simple.numfetch</tt> and <tt>pmDebug</tt> has the <tt>DBG_TRACE_APPL0</tt> flag set as shown in <a href="ch02.html#Z976060060sdc" title="Example 2-34. simple.numfetch in the Simple PMDA">Example 2-34</a>:</p>
<div class="example"><a name="Z976060060sdc"></a><p><a name="Z976060060sdc"></a><b>Example 2-34. <tt>simple.numfetch</tt> in the Simple PMDA</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">   case 0: /* simple.numfetch */ 
       val = vsp-&gt;vlist[0].value.lval; 
       if (val &lt; 0) { 
           sts = PM_ERR_SIGN; 
           val = 0; 
       } 
#ifdef DEBUG 
       if (pmDebug &amp; DBG_TRACE_APPL0) { 
           fprintf(stderr,  
                &quot;simple: %d stored into numfetch&quot;, val); 
       } 
#endif 
       numfetch = val; 
       break;</pre></td></tr></table><br></div><p><a class="indexterm" name="IG31340177235"></a>For a description of <tt>pmstore</tt>, see the <tt>pmstore(1)</tt> man page.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5195283"></a>2.7.3. <tt>dbpmda</tt> Debug Utility</h3></div></div>
<p><a class="indexterm" name="IG31340177236"></a>The <tt>dbpmda</tt> utility provides a simple interface to the PDU communication protocol. It allows daemon and DSO PMDAs to be tested with most request types, while the PMDA process may be monitored with <tt>dbx</tt>, <tt>par</tt> on IRIX or <tt>gdb</tt>, <tt>strace</tt> on Linux, and other diagnostic tools. The <tt>dbpmda(1)</tt> man page contains a sample session with the <tt>simple</tt> PMDA.</p>
</div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5195340"></a>2.8. Integration of PMDA</h2></div></div>
<p><a class="indexterm" name="IG31340177237"></a>Several steps are required to install (or remove) a PMDA from a production PMCD environment without affecting the operation of other PMDAs or related visualization and logging tools.<a class="indexterm" name="IG31340177238"></a></p>
<p>The PMDA typically would have its own directory below <tt>/var/pcp/pmdas</tt> into which several files would be installed. In the description in <a href="ch02.html#LE55181-PARENT" title="2.8.1. Installing a PMDA">Section 2.8.1</a>, the PMDA of interest is assumed to be known by the name <tt>newbie</tt>, hence the PMDA directory would be <tt>/var/pcp/pmdas/newbie</tt>.</p>
<div class="note"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/note.png" height="24" width="24"></td><td align="left" valign="top"><b>Note: </b>Any installation or removal of a PMDA involves updating files and directories that are typically well protected. Hence the procedures described in this section must be executed as the superuser.
</td></tr></table><hr noshade="noshade"></div><br><div class="section"><div class="titlepage"><div><h3 class="title"><a name="LE55181-PARENT"></a>2.8.1. Installing a PMDA</h3></div></div>
<p>A PMDA is fully installed when these tasks are completed:</p>
<div class="itemizedlist"><ul type="disc"><li><p><a class="indexterm" name="IG31340177239"></a>Help text has been installed in a place where the PMDA can find it, usually in the PMDA directory <tt>/var/pcp/pmdas/newbie</tt>.</p>
</li>
<li><p>The name space has been updated in the <tt>/var/pcp/pmns</tt> directory.</p>
</li>
<li><p>The PMDA binary has been installed, usually in the directory <tt>/var/pcp/lib</tt> for a DSO PMDA, or in the PMDA directory <tt>/var/pcp/pmdas/newbie</tt> for a daemon PMDA.</p>
</li>
<li><p>The <tt>/etc/pmcd.conf</tt> file on IRIX or the <tt>/var/pcp/config/pmcd/pmcd.conf</tt> file on Linux has been updated.</p>
</li>
<li><p>The PMCD process has been restarted or notified (with a <tt>SIGHUP</tt> signal) that the new PMDA exists.</p>
</li>
</ul></div><p>The <tt>Makefile</tt> should include an <tt>install</tt> target to compile and link the PMDA (as a DSO, or a daemon or both) in the PMDA directory, and in the case of a DSO PMDA, install the shared library in <tt>/var/pcp/lib</tt> for IRIX and <tt>/usr/share/pcp/lib</tt> for Linux. The <tt>clobber</tt> target should remove any files created as a by-product of the <tt>install</tt> target.<a class="indexterm" name="IG31340177240"></a></p>
<p>You may wish to use <tt>/var/pcp/pmdas/simple/Makefile</tt> as a template for constructing a new PMDA <tt>Makefile</tt>; changing the assignment of <tt>IAM</tt> from <tt>simple</tt> to <tt>newbie</tt> would account for most of the required changes.</p>
<p>Since the object format of a DSO PMDA must match the object format of PMCD, which in turn must match the object format of the booted operating system kernel, there might be multiple DSO targets in the <tt>Makefile</tt>. For an example on IRIX, see targets <tt>mips_o32.pmda_$(IAM).so</tt>, <tt>mips_n32.pmda_$(IAM).so</tt>, and <tt>mips_64.pmda_$(IAM).so</tt> for the simple PMDA.</p>
<p>The <tt>Install</tt> script should make use of the generic procedures defined in the script <tt>/usr/pcp/lib/pmdaproc.sh</tt> on IRIX and <tt>/usr/share/pcp/lib/pmdaproc.sh</tt> on Linux, and may be as straightforward as the one used for the trivial PMDA, shown in <a href="ch02.html#Z976309325sdc" title="Example 2-35. Install Script for the Trivial PMDA">Example 2-35</a>:</p>
<div class="example"><a name="Z976309325sdc"></a><p><a name="Z976309325sdc"></a><b>Example 2-35. <tt>Install</tt> Script for the Trivial PMDA</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting"># Get the common procedures and variable assignments
#
. /usr/pcp/lib/pmdaproc.sh
# The name of the PMDA
#
iam=trivial
# Do it
#
pmdaSetup
pmdainstall
exit 0</pre></td></tr></table><br></div><p>The variables, shown in <a href="ch02.html#id5195779" title="Table 2-1. Variables to Control Behavior of Generic pmdaproc.sh Procedures">Table 2-1</a>, may be assigned values to modify the behavior of the <tt>pmdaSetup</tt> and <tt>pmdainstall</tt> procedures from <tt>/usr/pcp/lib/pmdaproc.sh</tt> or  <tt>/usr/share/pcp/lib/pmdaproc.sh</tt> on Linux.</p>
<div class="table"><a name="id5195779"></a><p><a name="id5195779"></a><b>Table 2-1. Variables to Control Behavior of Generic <tt>pmdaproc.sh</tt> Procedures</b></p>
<table summary="Variables to Control Behavior of Generic pmdaproc.sh Procedures" border="1"><colgroup><col><col><col></colgroup><thead><tr valign="top"><th scope="col" align="left" valign="bottom"><p>Shell Variable</p>
</th><th scope="col" align="left" valign="bottom"><p>Use</p>
</th><th scope="col" align="left" valign="bottom"><p>Default</p>
</th></tr></thead><tbody><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>$iam</tt></p>
</td><td align="left" valign="top"><p>Name of the PMDA; assignment to this variable is mandatory.</p>
<p>Example: <tt>iam=newbie</tt></p>
</td><td align="left" valign="top"><p> </p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>$dso_opt</tt></p>
</td><td align="left" valign="top"><p>Can this PMDA be installed as a DSO?</p>
</td><td align="left" valign="top"><p><tt>false</tt></p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>$daemon_opt</tt></p>
</td><td align="left" valign="top"><p>Can this PMDA be installed as a daemon?</p>
</td><td align="left" valign="top"><p><tt>true</tt></p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>$pipe_opt</tt></p>
</td><td align="left" valign="top"><p>If installed as a daemon PMDA, is the default IPC via pipes?</p>
</td><td align="left" valign="top"><p><tt>true</tt></p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>$socket_opt</tt></p>
</td><td align="left" valign="top"><p>If installed as a daemon PMDA, is the default IPC via an Internet socket?</p>
</td><td align="left" valign="top"><p><tt>false</tt></p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>$socket_inet_def</tt></p>
</td><td align="left" valign="top"><p>If installed as a daemon PMDA, and the IPC method uses an Internet socket, the default port number.</p>
</td><td align="left" valign="top"><p> </p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>$ipc_prot</tt></p>
</td><td align="left" valign="top"><p>IPC style for PDU exchanges involving a daemon PMDA; <tt>binary</tt> or <tt>text</tt>.</p>
</td><td align="left" valign="top"><p><tt>binary</tt></p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>$check_delay</tt></p>
</td><td align="left" valign="top"><p>Delay in seconds between installing PMDA and checking if metrics are available.</p>
</td><td align="left" valign="top"><p><tt>3</tt></p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>$args</tt></p>
</td><td align="left" valign="top"><p>Additional command-line arguments passed to a daemon PMDA.</p>
</td><td align="left" valign="top"><p> </p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>$pmda_interface</tt></p>
</td><td align="left" valign="top"><p>Version of the <tt>libpcp_pmda</tt> library required, used to determine the version for generating help text files.</p>
</td><td align="left" valign="top"><p><tt>1</tt></p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>$pmns_source</tt></p>
</td><td align="left" valign="top"><p>The name of the PMNS file (by default relative to the PMDA directory).</p>
</td><td align="left" valign="top"><p><tt>pmns</tt></p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>$pmns_name</tt></p>
</td><td align="left" valign="top"><p>First-level name for this PMDA's metrics in the PMNS.</p>
</td><td align="left" valign="top"><p><tt>$iam</tt></p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>$help_source</tt></p>
</td><td align="left" valign="top"><p>The name of the help file (by default relative to the PMDA directory).</p>
</td><td align="left" valign="top"><p><tt>help</tt></p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>$pmda_name</tt></p>
</td><td align="left" valign="top"><p>The name of the executable for a daemon PMDA.</p>
</td><td align="left" valign="top"><p><tt>pmda$iam</tt></p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>$dso_name</tt></p>
</td><td align="left" valign="top"><p>The name of the shared library for a DSO PMDA.</p>
</td><td align="left" valign="top"><p><tt>pmda$iam.so</tt></p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>$dso_entry</tt></p>
</td><td align="left" valign="top"><p>The name of the initialization function for a DSO PMDA.</p>
</td><td align="left" valign="top"><p><tt>${iam}_init</tt></p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>$domain</tt></p>
</td><td align="left" valign="top"><p>The numerical PMDA domain number (from <tt>domain.h</tt>).</p>
</td><td align="left" valign="top"><p> </p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>$SYMDOM</tt></p>
</td><td align="left" valign="top"><p>The symbolic name of the PMDA domain number (from <tt>domain.h</tt>).</p>
</td><td align="left" valign="top"><p> </p>
</td></tr></tbody></table></div><p>In addition, the variables <tt>do_pmda</tt> and <tt>do_check</tt> will be set to reflect the intention to install the PMDA (as opposed to install just the PMNS) and to check the availability of the metrics once the PMDA is installed. By default, each variable is <tt>true</tt>; however, the command-line options <tt>-N</tt> and <tt>-Q</tt> to <tt>Install</tt> may be used to set the variables to <tt>false</tt>, as follows: <tt>do_pmda</tt> (<tt>-N</tt>) and <tt>do_check</tt> (<tt>-N</tt> or <tt>-Q</tt>).</p>
<p>The variables may also have their assignments changed by the user's response to the common prompt as shown in <a href="ch02.html#Z976309844sdc" title="Example 2-36. Changing Variable Assignments">Example 2-36</a>:</p>
<div class="example"><a name="Z976309844sdc"></a><p><a name="Z976309844sdc"></a><b>Example 2-36. Changing Variable Assignments</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">You will need to choose an appropriate configuration for installation 
of the ... Performance Metrics Domain Agent (PMDA).
  collector   collect performance statistics on this system
  monitor     allow this system to monitor local and/or remote systems
  both        collector and monitor configuration for this system</pre></td></tr></table><br></div><p>Obviously, for anything but the most trivial PMDA, after calling the <tt>pmdaSetup</tt> procedure, the <tt>Install</tt> script should also prompt for any PMDA-specific parameters, which are typically accumulated in the <i>args</i> variable and used by the <tt>pmdainstall</tt> procedure.</p>
<p>The detailed operation of the <tt>pmdainstall</tt> procedure involves the following tasks:</p>
<div class="itemizedlist"><ul type="disc"><li><p>Using default assignments, and interaction where ambiguity exists, determine the PMDA type (DSO or daemon) and the IPC parameters, if any.</p>
</li>
<li><p>Copy the <tt>$pmns_source</tt> file, replacing symbolic references to <tt>SYMDOM</tt> by the desired numeric domain number from <tt>domain.</tt></p>
</li>
<li><p>Merge the PMDA's name space into the PCP name space at the non-leaf node identified by <tt>$pmns_name</tt>.</p>
</li>
<li><p>If any <tt>pmchart</tt> views can be found (files with names ending in &#8220;.pmchart&#8221;), copy these to the standard directory (<tt>/var/pcp/config/pmchart</tt>) with the &#8220;.pmchart&#8221; suffix removed.</p>
</li>
<li><p><a class="indexterm" name="IG31340177241"></a>Create new help files from <tt>$help_source</tt> after replacing symbolic references to <tt>SYMDOM</tt> by the desired numeric domain number from <tt>domain</tt>.</p>
</li>
<li><p>Terminate the old daemon PMDA, if any.</p>
</li>
<li><p>Use the <tt>Makefile</tt> to build the appropriate executables.</p>
</li>
<li><p>Add the PMDA specification to PMCD's configuration file (<tt>/etc/pmcd.conf</tt>).</p>
</li>
<li><p>Notify PMCD. To minimize the impact on the services PMCD provides, sending a <tt>SIGHUP</tt> to PMCD forces it to reread the configuration file and start, restart, or remove any PMDAs that have changed since the file was last read.</p>
</li>
<li><p>Check that the metrics from the new PMDA are available.</p>
</li>
</ul></div><p>There are some PMDA changes that may trick PMCD into thinking nothing has changed, and not restarting the PMDA. Most notable are changes to the PMDA executable. In these cases, you may need to explicitly remove the PMDA as described in <a href="ch02.html#Z976310185sdc" title="2.8.3. Removing a PMDA">Section 2.8.3</a>, or more drastically, restart PMCD on IRIX as follows: <a class="indexterm" name="IG31340177242"></a></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout"># <b><tt>/etc/init.d/pcp start</tt></b></pre></td></tr></table><p>Restart PMCD on Linux as follows:<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout"># <b><tt>/etc/rc.d/init.d/pcp start</tt></b></pre></td></tr></table><br></p>
<p><a class="indexterm" name="IG31340177243"></a>The files <tt>/var/pcp/pmdas/*/Install</tt> provide a wealth of examples that may be used to construct a new PMDA<tt>Install</tt> script.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5197100"></a>2.8.2. Upgrading a PMNS to Include Metrics from a New PMDA</h3></div></div>
<p><a class="indexterm" name="IG31340177244"></a><a class="indexterm" name="IG31340177245"></a><a class="indexterm" name="IG31340177246"></a>When invoked with a <tt>-N</tt> command-line option, the PMDA <tt>Install</tt> script may be used to update the PMNS without installing the PMDA. This is typically used on a monitoring system to populate the local PMNS with the names of the performance metrics from a PMDA installed on a remote host. The <tt>-N</tt> option also installs <tt>pmchart</tt> views useful on a monitoring system.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="Z976310185sdc"></a>2.8.3. Removing a PMDA</h3></div></div>
<p><a class="indexterm" name="IG31340177247"></a>The simplest way to stop a PMDA from running, apart from killing the process, is to remove the entry from <tt>/etc/pmcd.conf</tt> and signal PMCD (with <tt>SIGHUP</tt>) to reread its configuration file. To completely remove a PMDA requires the reverse process of the installation, including an update of the Performance Metrics Name Space (PMNS).</p>
<p><a class="indexterm" name="IG31340177248"></a>This typically involves a <tt>Remove</tt> script in the PMDA directory that uses the same common procedures as the <tt>Install</tt> script described <a href="ch02.html#LE55181-PARENT" title="2.8.1. Installing a PMDA">Section 2.8.1</a>.</p>
<p><a class="indexterm" name="IG31340177249"></a>The <tt>/var/pcp/pmdas/*/Remove</tt> files provide a wealth of examples that may be used to construct a new PMDA <tt>Remove</tt> script.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5197301"></a>2.8.4. Configuring PCP Tools</h3></div></div>
<p><a class="indexterm" name="IG31340177250"></a><a class="indexterm" name="IG31340177251"></a>Most PCP tools have their own configuration file format for specifying which metrics to view or to log. By using canned configuration files that monitor key metrics of the new PMDA, users can quickly see the performance of the target system, as characterized by key metrics in the new PMDA. </p>
<p>Any configuration files that are created should be kept with the PMDA and installed into the appropriate directories when the PMDA is installed.</p>
<p>As with all PCP customization, some of the most valuable tools can be created by defining views, scenes, and control-panel layouts that combine related performance metrics from multiple PMDAs or multiple hosts.</p>
<p><a class="indexterm" name="IG31340177252"></a><a class="indexterm" name="IG31340177253"></a>Parameterized alarm configurations can be created using the <tt>pmieconf</tt> facilities; see the <tt>pmieconf(1)</tt> and <tt>pmie(1)</tt> man pages. In addition, <tt>pmie</tt> rules involving metrics from the new PMDA may be created directly.</p>
<p><a class="indexterm" name="IG31340177254"></a><a class="indexterm" name="IG31340177255"></a>Daily logs can be specified in <tt>pmlogger</tt> configuration files, or with the <tt>pmlogger_daily</tt> mechanism; see the <tt>pmlogger(1)</tt> and <tt>pmlogger_daily(1)</tt> man pages. The services of <tt>pmsnap</tt> may be used to incorporate the new performance metrics into charts that may be periodically regenerated and published via a World Wide Web server.</p>
</div></div></div><!--CONTENT_END--><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch01.html">Prev</a> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Table of Contents</a></td><td width="40%" align="right"> <a accesskey="n" href="ch03.html">Next</a></td></tr><tr><td width="40%" align="left">Chapter 1. Programming Performance Co-Pilot </td><td width="20%" align="center"> </td><td width="40%" align="right">Chapter 3. PMAPI--The Performance Metrics API </td></tr></table></div></body></html>
