<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type"><title>Chapter 3. PMAPI--The Performance Metrics API</title><meta name="generator" content="DocBook XSL Stylesheets V1.51.1"><meta name="generator" content="SGI XSL DocBook Customization Stylesheets V1.1"><link rel="home" href="index.html" title="Performance Co-Pilot&#8482; Programmer's Guide"><link rel="up" href="index.html" title="Performance Co-Pilot&#8482; Programmer's Guide"><link rel="previous" href="ch02.html" title="Chapter 2. Writing a PMDA"><link rel="next" href="ch04.html" title="Chapter 4. Trace PMDA"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 3. PMAPI--The Performance Metrics API</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch04.html">Next</a></td></tr></table><hr></div><!--CONTENT_BEGIN--><a name="sgi_start_content"></a><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="LE97135-PARENT"></a>Chapter 3. PMAPI--The Performance Metrics API</h2></div></div>
<p><a class="indexterm" name="IG31340177256"></a><a class="indexterm" name="IG31340177257"></a>This chapter describes the Performance Metrics Application Programming Interface (PMAPI) provided with Performance Co-Pilot (PCP).</p>
<p><a class="indexterm" name="IG31340177258"></a>The PMAPI is a set of functions and data structure definitions that allow client applications to access performance data from one or more Performance Metrics Collection Daemons (PMCDs) or from PCP archive logs. The PCP utilities are all written using the PMAPI.</p>
<p>The most common use of PCP includes running performance monitoring utilities on a workstation (the monitoring system) while performance data is retrieved from one or more remote collector systems by a number of PCP processes. These processes execute on both the monitoring system and the collector systems. The collector systems are typically servers, and are the targets for the performance investigations.</p>
<p>In the development of the PMAPI the most important question has been, &#8220;How easily and quickly will this API enable the user to build new performance tools, or exploit existing tools for newly available performance metrics?&#8221; The PMAPI and the standard tools that use the PMAPI have enjoyed a symbiotic evolution throughout the development of PCP.</p>
<p>It will be convenient to differentiate between code that uses the PMAPI and code that implements the services of the PMAPI. The former will be termed &#8220;above the PMAPI&#8221; and the latter &#8220;below the PMAPI.&#8221;</p>
<div class="section"><div class="titlepage"><div><h2 class="title"><a name="LE87626-PARENT"></a>3.1. Naming and Identifying Performance Metrics</h2></div></div>
<p><a class="indexterm" name="IG31340177259"></a><a class="indexterm" name="IG31340177260"></a><a class="indexterm" name="IG31340177261"></a>Across all of the supported performance metric domains, there are a large number of performance metrics. Each metric has its own description, format, and semantics. PCP presents a uniform interface to these metrics above the PMAPI, independent of the source of the underlying metric data. For example, the performance metric <tt>hinv.physmem</tt> has a single 32-bit unsigned integer value, representing the number of megabytes of physical memory in the system, while the performance metric <tt>disk.dev.total</tt> has one 32-bit unsigned
integer value per disk spindle, representing the cumulative count of I/O operations involving each associated disk spindle. These concepts are described in greater detail in <a href="ch02.html#LE97285-PARENT" title="2.3. Domains, Metrics, and Instances">Section 2.3</a><a href="ch02.html#LE97285-PARENT"> in Chapter 2</a>.</p>
<p>For brevity and efficiency, internally PCP avoids using ASCII names for performance metrics, and instead uses an identification scheme that unambiguously associates a single integer with each known performance metric. This integer is known as a Performance Metric Identifier, or PMID. For functions using the PMAPI, a PMID is defined and manipulated with the typedef <tt>pmID</tt>.</p>
<p>Below the PMAPI, the integer value of the PMID has an internal structure that reflects the details of the PMCD and PMDA architecture, as described in <a href="ch02.html#LE98565-PARENT" title="2.3.3. Metrics">Section 2.3.3</a><a href="ch02.html#LE98565-PARENT"> in Chapter 2</a>.</p>
<p>Above the PMAPI, a Performance Metrics Name Space (PMNS) is used to provide a hierarchic classification of external metric names, and a one-to-one mapping of external names to internal PMIDs. A more detailed description of the PMNS can be found in the <i>Performance Co-Pilot User's and Administrator's Guide</i>.</p>
<p>Applications that use the PMAPI may have independent versions of a PMNS, constructed from an initialization file when the application starts. Not all PMIDs need be represented in the PMNS of every application. For example, an application that monitors disk traffic could use a Name Space that references only the PMIDs for I/O statistics. Other applications require a stable PMNS that can be assumed to be the same on all systems. The distributed implementation includes a default PMNS for just this purpose.</p>
<p>The vast majority of PCP users and applications using the PMAPI will choose to use the default PMNS.</p>
<p>As of PCP release 2.0 the default PMNS comes from the performance metrics source, either a PMCD process or a PCP archive. This PMNS always reflects the available metrics from the performance metrics source; so most applications never use the local version of a PMNS.</p>
</div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5197718"></a>3.2. Performance Metric Instances</h2></div></div>
<p><a class="indexterm" name="IG31340177262"></a>When performance metric values are returned across the PMAPI to a requesting application, there may be more than one value for a particular metric; for example, independent counts for each CPU, or each process, or each disk, or each system call type, and so on. This multiplicity of values is not enumerated in the Name Space, but rather when performance metrics are delivered across the PMAPI.</p>
<p>The notion of <tt>metric instances</tt> is really a number of related concepts, as follows:</p>
<div class="itemizedlist"><ul type="disc"><li><p>A particular performance metric may have a set of associated values or instances.</p>
</li>
<li><p>The instances are differentiated by an instance identifier.</p>
</li>
<li><p>An instance identifier has an internal encoding (an integer value) and an external encoding (a corresponding external name or label).</p>
</li>
<li><p>The set of all possible instance identifiers associated with a performance metric on a particular host constitutes an <i>instance domain</i>.</p>
</li>
<li><p>Several performance metrics may share the same instance domain.</p>
</li>
</ul></div><p>Consider <a href="ch03.html#Z976548024sdc" title="Example 3-1. Metrics Sharing the Same Instance Domain">Example 3-1</a>:</p>
<div class="example"><a name="Z976548024sdc"></a><p><a name="Z976548024sdc"></a><b>Example 3-1. Metrics Sharing the Same Instance Domain</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting"><b><tt>$ pminfo -f filesys.free</tt></b>

filesys.free
    inst [1 or &#8220;/dev/root&#8221;] value 1803
    inst [2 or &#8220;/dev/usr&#8221;] value 22140
    inst [3 or &#8220;/dev/dsk/dks0d2s0&#8221;] value 157938</pre></td></tr></table><br></div><p>The metric <tt>filesys.free</tt> has three values, currently 1803, 22140, and 157938. These values are respectively associated with the instances identified by the internal identifiers 1, 2 and 3, and the external identifiers <tt>/dev/root</tt>, <tt>/dev/usr</tt>, and <tt>/dev/dsk/dks0d2s0</tt>. These instances form an instance domain that is shared by the performance metrics <tt>filesys.capacity</tt>, <tt>filesys.used</tt>, <tt>filesys.free</tt>, <tt>filesys.mountdir</tt>, and so on.</p>
<p>Each performance metric is associated with an instance domain, while each instance domain may be associated with many performance metrics. Each instance domain is identified by a unique value, as defined by the following <tt>typedef</tt> declaration:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout"><tt>typedef unsigned long pmInDom;</tt></pre></td></tr></table><p><a class="indexterm" name="IG31340177263"></a>The special instance domain <tt>PM_INDOM_NULL</tt> is reserved to indicate that the metric has a single value (a singular instance domain). For example, the performance metric <tt>mem.freemem</tt> always has exactly one value. Note that this is semantically different to a performance metric like <tt>kernel.percpu.syscall</tt> that has a non-singular instance domain, but may have only one value available; for example, on a system with a single processor.</p>
<p><a class="indexterm" name="IG31340177264"></a>In the results returned above the PMAPI, each individual instance, within an instance domain, is identified by an internal integer instance identifier. The special instance identifier <tt>PM_IN_NULL</tt> is reserved for the single value in a singular instance domain. Performance metric values are delivered across the PMAPI as a set of instance identifier and value pairs.</p>
<p>The instance domain of a metric may change with time. For example, a machine may be shut down, have several disks added, and be rebooted. All performance metrics associated with the instance domain of disk devices would contain additional values after the reboot. The difficult issue of transient performance metrics means that repeated requests for the same PMID may return different numbers of values, or some changes in the particular instance identifiers returned. This means applications need to be aware that metric instantiation is guaranteed to be valid only at the time of collection.</p>
<div class="note"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/note.png" height="24" width="24"></td><td align="left" valign="top"><b>Note: </b>Some instance domains are more dynamic than others. For example, consider the instance domains behind the performance metrics <tt>proc.memory.physical.dat</tt> (one instance per process), <tt>swap.free</tt> (one instance per swap partition) and <tt>kernel.percpu.cpu.intr</tt> (one instance per CPU).
</td></tr></table><hr noshade="noshade"></div><br></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5198049"></a>3.3. Current PMAPI Context</h2></div></div>
<p><a class="indexterm" name="IG31340177265"></a>When performance metrics are retrieved across the PMAPI, they are delivered in the context of a particular source of metrics, a point in time, and a profile of desired instances. This means that the application making the request has already negotiated across the PMAPI to establish the context in which the request should be executed.</p>
<p><a class="indexterm" name="IG31340177266"></a>A metric's source may be the current performance data from a particular host (a live or real-time source), or an archive log of performance data collected by <tt>pmlogger</tt> at some remote host or earlier time (a retrospective or archive source). The metric's source is specified when the PMAPI context is created by calling the <tt>pmNewContext</tt> function.</p>
<p><a class="indexterm" name="IG31340177267"></a>The collection time for a performance metric is always the current time of day for a real-time source, or current position for an archive source. For archives, the collection time may be set to an arbitrary time within the bounds of the archive log by calling the <tt>pmSetMode</tt> function.</p>
<p>The last component of a PMAPI context is an instance profile that may be used to control which particular instances from an instance domain should be retrieved. When a new PMAPI context is created, the initial state expresses an interest in all possible instances, to be collected at the current time. The instance profile can be manipulated using the <tt>pmAddProfile</tt> and <tt>pmDelProfile</tt> functions.</p>
</div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="LE11914-PARENT"></a>3.4. Performance Metric Descriptions</h2></div></div>
<p><a class="indexterm" name="IG31340177268"></a>For each defined performance metric, there is associated metadata encoded in a performance metric description (<tt>pmDesc</tt> structure) that describes the format and semantics of the performance metric. The <tt>pmDesc</tt> structure, in <a href="ch03.html#Z976548425sdc" title="Example 3-2. pmDesc Structure">Example 3-2</a>, provides all of the information required to interpret and manipulate a performance metric through the PMAPI. It has the following declaration:</p>
<div class="example"><a name="Z976548425sdc"></a><p><a name="Z976548425sdc"></a><b>Example 3-2. <tt>pmDesc</tt> Structure</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">/* Performance Metric Descriptor */
typedef struct {
    pmID    pmid;   /* unique identifier */
    int     type;   /* base data type (see below) */
    pmInDom indom;  /* instance domain */
    int     sem;    /* semantics of value (see below) */
    pmUnits units;  /* dimension and units (see below) */
} pmDesc;</pre></td></tr></table><br></div><p>The <tt>type</tt> field in the <tt>pmDesc</tt> structure describes various encodings of a metric's value. Its value will be one of the following constants:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">/* pmDesc.type - data type of metric values */
#define PM_TYPE_NOSUPPORT -1   /* not in this version */
#define PM_TYPE_32        0    /* 32-bit signed integer */
#define PM_TYPE_U32       1    /* 32-bit unsigned integer */
#define PM_TYPE_64        2    /* 64-bit signed integer */
#define PM_TYPE_U64       3    /* 64-bit unsigned integer */
#define PM_TYPE_FLOAT     4    /* 32-bit floating point */
#define PM_TYPE_DOUBLE    5    /* 64-bit floating point */
#define PM_TYPE_STRING    6    /* array of char */
#define PM_TYPE_AGGREGATE 7    /* arbitrary binary data */
#define PM_TYPE_AGGREGATE_STATIC 8 /* static pointer to aggregate */
#define PM_TYPE_UNKNOWN        255 /* used in pmValueBlock, not pmDesc */</pre></td></tr></table><p><a class="indexterm" name="IG31340177269"></a>By convention <tt>PM_TYPE_STRING</tt> is interpreted as a classic C-style null byte terminated string.</p>
<p><a class="indexterm" name="IG31340177270"></a>If the value of a performance metric is of type <tt>PM_TYPE_AGGREGATE</tt> (or indeed <tt>PM_TYPE_STRING</tt>), the interpretation of that value is unknown to most PCP components. In these cases, the application using the value and the Performance Metrics Domain Agent (PMDA) providing the value must have some common understanding about how the value is structured and interpreted.</p>
<p><a class="indexterm" name="IG31340177271"></a><tt>PM_TYPE_NOSUPPORT</tt> indicates that the PCP collection framework knows about the metric, but the corresponding service or application is either not configured or is at a revision level that does not provide support for this performance metric.</p>
<p>The semantics of the performance metric is described by the <tt>sem</tt> field of a <tt>pmDesc</tt> structure and uses the following constants:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">/* pmDesc.sem - semantics of metric values */
#define PM_SEM_COUNTER 1  /* cumulative count, monotonic increasing */
#define PM_SEM_INSTANT 3 /* instant. value continuous domain */
#define PM_SEM_DISCRETE 4 /* instant. value discrete domain */</pre></td></tr></table><p><a class="indexterm" name="IG31340177272"></a><a class="indexterm" name="IG31340177273"></a>Each value for a performance metric is assumed to be drawn from a set of values that can be described in terms of their dimensionality and scale by a compact encoding, as follows:</p>
<div class="itemizedlist"><ul type="disc"><li><p>The dimensionality is defined by a power, or index, in each of three orthogonal dimensions: Space, Time, and Count (dimensionless). For example, I/O throughput is Space<sup>1</sup>.Time<sup>-1</sup>, while the running total of system calls is Count<sup>1</sup>, memory allocation is Space<sup>1</sup>, and average service time per event is Time<sup>1</sup>.Count<sup>-1</sup>.</p>
</li>
<li><p>In each dimension, a number of common scale values are defined that may be used to better encode ranges that might otherwise exhaust the precision of a 32-bit value. For example, a metric with dimension Space<sup>1</sup>.Time<sup>-1</sup> may have values encoded using the scale megabytes per second.</p>
</li>
</ul></div><p><a class="indexterm" name="IG31340177274"></a>This information is encoded in the <tt>pmUnits</tt> data structure, shown in <a href="ch03.html#Z976557554sdc" title="Example 3-3. pmUnits and pmDesc IRIX Structures">Example 3-3</a> and <a href="ch03.html#Z1034792511tls" title="Example 3-4. pmUnits and pmDesc Linux Structures">Example 3-4</a>. It is embedded in the <tt>pmDesc</tt> structure :</p>
<div class="example"><a name="Z976557554sdc"></a><p><a name="Z976557554sdc"></a><b>Example 3-3. <tt>pmUnits</tt> and <tt>pmDesc</tt> IRIX Structures</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">/*
* Encoding for the units (dimensions and
* scale) for Performance Metric Values
*
* For example, a pmUnits struct of
* { 1, -1, 0, PM_SPACE_MBYTE, PM_TIME_SEC, 0 }
* represents Mbytes/sec, while 
* { 0, 1, -1, 0, PM_TIME_HOUR, 6 }
* represents hours/million-events
*/
typedef struct {
    int dimSpace:4;   /* space dimension */
    int dimTime:4;    /* time dimension */
    int dimCount:4;   /* event dimension */
    int scaleSpace:4; /* one of PM_SPACE_* below */
    int scaleTime:4;  /* one of PM_TIME_* below */
    int scaleCount:4; /* one of PM_COUNT_* below */
    int pad:8;
  } pmUnits;   /* dimensional units and scale of value */
/* pmUnits.scaleSpace */
#define PM_SPACE_BYTE 0  /* bytes */
#define PM_SPACE_KBYTE 1 /* Kilobytes (1024) */
#define PM_SPACE_MBYTE 2 /* Megabytes (1024^2) */
#define PM_SPACE_GBYTE 3 /* Gigabytes (1024^3) */
#define PM_SPACE_TBYTE 4 /* Terabytes (1024^4) */
/* pmUnits.scaleTime */
#define PM_TIME_NSEC 0   /* nanoseconds */
#define PM_TIME_USEC 1   /* microseconds */
#define PM_TIME_MSEC 2   /* milliseconds */
#define PM_TIME_SEC 3    /* seconds */
#define PM_TIME_MIN 4    /* minutes */
#define PM_TIME_HOUR 5   /* hours */
/*
 * pmUnits.scaleCount (e.g. count events, syscalls,
 * interrupts, etc.) -- these are simply powers of 10,
 * and not enumerated here.
 * e.g. 6 for 10^6, or -3 for 10^-3
 */
#define PM_COUNT_ONE 0 /* 1 */</pre></td></tr></table><br></div><p>The strucutures in Linux are as follows:</p>
<div class="example"><a name="Z1034792511tls"></a><p><a name="Z1034792511tls"></a><b>Example 3-4. <tt>pmUnits</tt> and <tt>pmDesc</tt> Linux Structures</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">/*
* Encoding for the units (dimensions and
* scale) for Performance Metric Values
*
* For example, a pmUnits struct of
* { 1, -1, 0, PM_SPACE_MBYTE, PM_TIME_SEC, 0 }
* represents Mbytes/sec, while 
* { 0, 1, -1, 0, PM_TIME_HOUR, 6 }
* represents hours/million-events
*/
typedef struct {
    int pad:8;
    int scaleCount:4; /* one of PM_COUNT_* below */
 below */
    int scaleTime:4;  /* one of PM_TIME_* below */
    int scaleSpace:4; /* one of PM_SPACE_* below */    
 below */
    int dimCount:4;   /* event dimension */
    int dimTime:4;    /* time dimension */
    int dimSpace:4;   /* space dimension
 } pmUnits;   /* dimensional units and scale of value */
/* pmUnits.scaleSpace */
#define PM_SPACE_BYTE 0  /* bytes */
#define PM_SPACE_KBYTE 1 /* Kilobytes (1024) */
#define PM_SPACE_MBYTE 2 /* Megabytes (1024^2) */
#define PM_SPACE_GBYTE 3 /* Gigabytes (1024^3) */
#define PM_SPACE_TBYTE 4 /* Terabytes (1024^4) */
/* pmUnits.scaleTime */
#define PM_TIME_NSEC 0   /* nanoseconds */
#define PM_TIME_USEC 1   /* microseconds */
#define PM_TIME_MSEC 2   /* milliseconds */
#define PM_TIME_SEC 3    /* seconds */
#define PM_TIME_MIN 4    /* minutes */
#define PM_TIME_HOUR 5   /* hours */
/*
 * pmUnits.scaleCount (e.g. count events, syscalls,
 * interrupts, etc.) -- these are simply powers of 10,
 * and not enumerated here.
 * e.g. 6 for 10^6, or -3 for 10^-3
 */
#define PM_COUNT_ONE 0 /* 1 */</pre></td></tr></table><br></div><br></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="LE82331-PARENT"></a>3.5. Performance Metrics Values</h2></div></div>
<p><a class="indexterm" name="IG31340177275"></a><a class="indexterm" name="IG31340177276"></a>An application may fetch (or store) values for a set of performance metrics, each with a set of associated instances, using a single <tt>pmFetch</tt> (or <tt>pmStore</tt>) function call. To accommodate this, values are delivered across the PMAPI in the form of a tree data structure, rooted at a <tt>pmResult</tt> structure. This encoding is illustrated in <a href="ch03.html#id5198718" title="Figure 3-1. A Structured Result for Performance Metrics from pmFetch">Figure 3-1</a>, and uses the component data structures in <a href="ch03.html#Z976557818sdc" title="Example 3-5. pmValueBlock and pmValue Structures">Example 3-5</a>:</p>
<div class="example"><a name="Z976557818sdc"></a><p><a name="Z976557818sdc"></a><b>Example 3-5. <tt>pmValueBlock</tt> and <tt>pmValue</tt> Structures</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">typedef struct {
   int inst;                 /* instance identifier */
   union {
       pmValueBlock *pval;   /* pointer to value-block */
       int           lval;   /* integer value insitu */
   } value;
} pmValue;</pre></td></tr></table><br></div><p><div class="figure"><a name="id5198718"></a><p><a name="id5198718"></a><b>Figure 3-1. A Structured Result for Performance Metrics from <tt>pmFetch</tt></b></p>
<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/struct_results_frm_pmFetch.gif" alt="A Structured Result for Performance Metrics from pmFetch" height="397" width="449"></td></tr></table></div></div><br></p>
<p><a class="indexterm" name="IG31340177277"></a>The internal instance identifier is stored in the <tt>inst</tt> element. If a value for a particular metric-instance pair is a 32-bit integer (signed or unsigned), then it will be stored in the <tt>lval</tt> element. If not, the value will be in a <tt>pmValueBlock</tt> structure, as shown in <a href="ch03.html#Z976812872sdc" title="Example 3-6.  pmValueBlock Structure in IRIX">Example 3-6</a> and <a href="ch03.html#Z1034793414tls" title="Example 3-7. pmValueBlock Structure in Linux">Example 3-7</a>, and will be located via <tt>pval</tt>:</p>
<div class="example"><a name="Z976812872sdc"></a><p><a name="Z976812872sdc"></a><b>Example 3-6.  <tt>pmValueBlock</tt> Structure in IRIX</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">typedef struct {
   unsigned int    vtype : 8;    /* value type */
   unsigned int    vlen : 24;    /* bytes for vtype/vlen + vbuf */
   char            vbuf[1];      /* the value */
} pmValueBlock;</pre></td></tr></table><br></div><p>The <tt>pmValueBlock</tt> structure in Linux is as follows:<div class="example"><a name="Z1034793414tls"></a><p><a name="Z1034793414tls"></a><b>Example 3-7. <tt>pmValueBlock</tt> Structure in Linux</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">typedef struct {
   unsigned int    vlen : 24;    /* bytes for vtype/vlen + vbuf */
   unsigned int    vtype : 8;    /* value type */
   char            vbuf[1];      /* the value */
} pmValueBlock;</pre></td></tr></table><br></div><br></p>
<p><a class="indexterm" name="IG31340177278"></a>The length of the <tt>pmValueBlock</tt> (including the <tt>vtype</tt> and <tt>vlen</tt> fields) is stored in <tt>vlen</tt>. Despite the prototype declaration of <tt>vbuf</tt>, this array really accommodates <tt>vlen</tt> minus <tt>sizeof</tt>(<tt>vlen</tt>) bytes. The <tt>vtype</tt> field encodes the type of the value in the <tt>vbuf[]</tt> array, and is one of the <tt>PM_TYPE_*</tt> macros defined in <tt>/usr/include/pmapi.h</tt>.</p>
<p><a class="indexterm" name="IG31340177279"></a>A <tt>pmValueSet</tt> structure, as shown in <a href="ch03.html#Z976549488sdc" title="Example 3-8. pmValueSet Structure">Example 3-8</a>, contains all of the values to be returned from <tt>pmFetch</tt> for a single performance metric identified by the <tt>pmid</tt> field.</p>
<div class="example"><a name="Z976549488sdc"></a><p><a name="Z976549488sdc"></a><b>Example 3-8. <tt>pmValueSet</tt> Structure</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">typedef struct {
   pmID    pmid;          /* metric identifier */
   int     numval;        /* number of values */
   int     valfmt;        /* value style, insitu or ptr */
   pmValue vlist[1];      /* set of instances/values */ 
} pmValueSet;</pre></td></tr></table><br></div><p>If positive, the <tt>numval</tt> field identifies the number of value-instance pairs in the <tt>vlist</tt> array (despite the prototype declaration of size 1). If <tt>numval</tt> is zero, there are no values available for the associated performance metric and <tt>vlist</tt>[0] is undefined. A negative value for <tt>numval</tt> indicates an error condition (see the <tt>pmErrStr(3)</tt> man page) and <tt>vlist</tt>[0] is undefined. The <tt>valfmt</tt> field has the value <tt>PM_VAL_INSITU</tt> to indicate that the values for the performance metrics should be located directly via the <tt>lval</tt> member of the <tt>value</tt> union embedded in the elements of <tt>vlist</tt>; otherwise, metric values are located indirectly via the <tt>pval</tt> member of the elements of <tt>vlist</tt>.</p>
<p><a class="indexterm" name="IG31340177280"></a>The <tt>pmResult</tt> structure, as shown in <a href="ch03.html#Z976549833sdc" title="Example 3-9. pmResult Structure">Example 3-9</a>, contains a time stamp and an array of <tt>numpmid</tt> pointers to <tt>pmValueSet</tt>.</p>
<div class="example"><a name="Z976549833sdc"></a><p><a name="Z976549833sdc"></a><b>Example 3-9. <tt>pmResult</tt> Structure</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">/* Result returned by pmFetch() */
typedef struct {
   struct timeval timestamp;    /* stamped by collector */
   int            numpmid;      /* number of PMIDs */
   pmValueSet     *vset[1];     /* set of value sets */
} pmResult</pre></td></tr></table><br></div><p>There is one <tt>pmValueSet</tt> pointer per PMID, with a one-to-one correspondence to the set of requested PMIDs passed to <tt>pmFetch</tt>.</p>
<p>Along with the metric values, the PMAPI returns a time stamp with each <tt>pmResult</tt> that serves to identify when the performance metric values were collected. The time is in the format returned by <tt>gettimeofday</tt> and is typically very close to the time when the metrics are exported across the PMAPI.</p>
<div class="note"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/note.png" height="24" width="24"></td><td align="left" valign="top"><b>Note: </b>There is a question of exactly when individual metrics may have been collected, especially given their origin in potentially different performance metric domains, and variability in metric updating frequency by individual PMDAs. PCP uses a pragmatic approach, in which the PMAPI implementation returns all metrics with values accurate as of the time stamp, to the maximum degree possible, and PMCD demands that all PMDAs deliver values within a small realtime window. The resulting inaccuracy is small, and the additional burden of accurate individual timestamping for each returned metric value is neither warranted nor practical (from an implementation viewpoint).
</td></tr></table><hr noshade="noshade"></div><p>The PMAPI provides functions to extract, rescale, and print values from the above structures; refer to <a href="ch03.html#LE44064-PARENT" title="3.8. PMAPI Ancillary Support Services">Section 3.8</a>.</p>
</div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5199203"></a>3.6. PMAPI Programming Style and Interaction</h2></div></div>
<p><a class="indexterm" name="IG31340177281"></a>The following sections describe the PMAPI programming style:</p>
<div class="itemizedlist"><ul type="disc"><li><p>Variable length argument and results lists</p>
</li>
<li><p>PMAPI error handling</p>
</li>
</ul></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="LE37655-PARENT"></a>3.6.1. Variable Length Argument and Results Lists</h3></div></div>
<p><a class="indexterm" name="IG31340177282"></a><a class="indexterm" name="IG31340177283"></a>All arguments and results involving a &#8220;list of something&#8221; are encoded as an array with an associated argument or function value to identify the number of elements in the array. This encoding scheme avoids both the <tt>varargs</tt> approach and sentinel-terminated lists. Where the size of a result is known at the time of a call, it is the caller's responsibility to allocate (and possibly free) the storage, and the called function assumes that the resulting argument is of an appropriate size.</p>
<p><a class="indexterm" name="IG31340177284"></a><a class="indexterm" name="IG31340177285"></a><a class="indexterm" name="IG31340177286"></a><a class="indexterm" name="IG31340177287"></a><a class="indexterm" name="IG31340177288"></a><a class="indexterm" name="IG31340177289"></a><a class="indexterm" name="IG31340177290"></a>Where a result is of variable size and that size cannot be known in advance (for example, <tt>pmGetChildren</tt>, <tt>pmGetInDom</tt>,  <tt>pmNameInDom</tt>, <tt>pmNameID</tt>, <tt>pmLookupText</tt>, and <tt>pmFetch</tt>), the underlying implementation uses dynamic allocation through <tt>malloc</tt>
in the called function, with the caller responsible for subsequently calling <tt>free</tt> to release the storage when no longer required. In the case of the result from <tt>pmFetch</tt>, there is a function (<tt>pmFreeResult</tt>) to release the storage, due to the complexity of the data structure and the need to make multiple calls to <tt>free</tt> in the correct sequence. As a general rule, if the called function returns an error status, then no allocation is done, the pointer to the variable sized result is undefined, and <tt>free</tt> or <tt>pmFreeResult</tt> should not be called.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="LE62826-PARENT"></a>3.6.2. PMAPI Error Handling</h3></div></div>
<p><a class="indexterm" name="IG31340177291"></a>Where error conditions may arise, the functions that compose the PMAPI conform to a single, simple error notification scheme, as follows:</p>
<div class="itemizedlist"><ul type="disc"><li><p>The function returns an <tt>int</tt>. Values greater than or equal to zero indicate no error, and perhaps some positive status: for example, the number of items processed.</p>
</li>
<li><p>Values less than zero indicate an error, as determined by a global table of error conditions and messages.</p>
</li>
</ul></div><p>A PMAPI library function along the lines of <tt>strerror</tt> is provided to translate error conditions into error messages; see the <tt>pmErrStr(3)</tt> man page. The error condition is returned as the function value from a previous PMAPI call; there is no global error indicator (unlike <tt>errno</tt>). This is an attempt to anticipate and accommodate a programming environment that does not hinder the implementation of multi-threaded performance tools. The available error codes may be displayed with the following command:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting"><b><tt>pmerr -l</tt></b></pre></td></tr></table><br></div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5199561"></a>3.7. PMAPI Procedural Interface</h2></div></div>
<p>The following sections describe all of the PMAPI functions that provide access to the PCP infrastructure on behalf of a client application:</p>
<div class="itemizedlist"><ul type="disc"><li><p>PMAPI Name Space services</p>
</li>
<li><p>PMAPI metric description services</p>
</li>
<li><p>PMAPI instance domain services</p>
</li>
<li><p>PMAPI context services</p>
</li>
<li><p>PMAPI timezone services</p>
</li>
<li><p>PMAPI metrics services</p>
</li>
<li><p>PMAPI record-mode services</p>
</li>
<li><p>PMAPI archive-specific services</p>
</li>
<li><p>PMAPI time control services</p>
</li>
<li><p>PMAPI ancillary support services</p>
</li>
</ul></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="LE32034-PARENT"></a>3.7.1. PMAPI Name Space Services</h3></div></div>
<p>The functions described in this section provide Performance Metrics Application Programming Interface (PMAPI) Name Space services.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5199677"></a>3.7.1.1. <tt>pmGetChildren</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmGetChildren(const char *<i>name</i>, char ***<i>offspring</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177292"></a><a class="indexterm" name="IG31340177293"></a>Given a full pathname to a node in the current PMNS, as identified by <i>name</i>, return through <i>offspring</i> a list of the relative names of all the immediate descendents of <i>name</i> in the current PMNS. As a special case, if <i>name</i> is an empty string, (that is, <tt>&quot;&quot;</tt> but not <tt>NULL</tt> or <tt>(char *)0</tt>), the immediate descendents of the root node in the PMNS are returned.</p>
<p>Normally, <tt>pmGetChildren</tt> returns the number of descendent names discovered, or a value less than zero for an error. The value zero indicates that the <i>name</i> is valid, and associated with a leaf node in the PMNS.</p>
<p>The resulting list of pointers (<i>offspring</i>) and the values (relative metric names) that the pointers reference are allocated by <tt>pmGetChildren</tt> with a single call to <tt>malloc</tt>, and it is the responsibility of the caller to issue a <tt>free</tt><i>(offspring)</i> system call to release the space when it is no longer required. When the result of <tt>pmGetChildren</tt> is less than one, <i>offspring</i> is undefined (no space is allocated, and so calling <tt>free</tt> is counterproductive).</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5199872"></a>3.7.1.2. <tt>pmGetChildrenStatus</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int 
pmGetChildrenStatus(const char *<i>name</i>, char ***<i>offspring</i>, int **<i>status</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177294"></a>The <tt>pmGetChildrenStatus</tt> function is an extension of <tt>pmGetChildren</tt> that optionally returns status information about each of the descendent names.</p>
<p>Given a fully qualified pathname to a node in the current PMNS, as identified by <i>name</i>, <tt>pmGetChildrenStatus</tt> returns by means of <i>offspring</i> a list of the relative names of all of the immediate descendent nodes of <i>name</i> in the current PMNS. If <i>name</i> is the empty string (&#8221;&#8221;), it returns the immediate descendents of the root node in the PMNS.</p>
<p>If <i>status</i> is not NULL, then <tt>pmGetChildrenStatus</tt> also returns the status of each child by means of <i>status</i>. This refers to either a leaf node (with value <tt>PMNS_LEAF_STATUS</tt>) or a non-leaf node (with value <tt>PMNS_NONLEAF_STATUS</tt>).</p>
<p>Normally, <tt>pmGetChildrenStatus</tt> returns the number of descendent names discovered, or else a value less than zero to indicate an error. The value zero indicates that name is a valid metric name, being associated with a leaf node in the PMNS.</p>
<p>The resulting list of pointers (<i>offspring</i>) and the values (relative metric names) that the pointers reference are allocated by <tt>pmGetChildrenStatus</tt> with a single call to <tt>malloc</tt>, and it is the responsibility of the caller to <tt>free</tt>(<i>offspring</i>) to release the space when it is no longer required. The same holds true for the <i>status</i> array.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5200032"></a>3.7.1.3. <tt>pmGetPMNSLocation</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmGetPMNSLocation(void)</pre></td></tr></table><p><a class="indexterm" name="IG31340177295"></a>If an application needs to know where the origin of a PMNS is, <tt>pmGetPMNSLocation</tt> returns whether it is an archive (<tt>PMNS_ARCHIVE</tt>), a local PMNS file (<tt>PMNS_LOCAL</tt>), or a remote PMCD (<tt>PMNS_REMOTE</tt>). This information may be useful in determining an appropriate error message depending on PMNS location.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5200074"></a>3.7.1.4. <tt>pmLoadNameSpace</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmLoadNameSpace(const char *<i>filename</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177296"></a>Before requesting any services involving a local Performance Metrics Name Space (PMNS), the application must load the PMNS using <tt>pmLoadNameSpace</tt>.</p>
<p>The <i>filename</i> argument designates the PMNS of interest. For applications that do not require a tailored Name Space, the special value <tt>PM_NS_DEFAULT</tt> may be used for <i>filename</i>, to force a default local PMNS to be established. Externally, a PMNS may be stored in either an ASCII or binary format. The <tt>pmnscomp</tt> utility is used to create the binary format from the ASCII format.</p>
<div class="note"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/note.png" height="24" width="24"></td><td align="left" valign="top"><b>Note: </b>The distributed PMNS services in PCP 2.<i>x</i> avoid the need for a local PMNS in most cases; so applications typically would <span class="bold"><b>not</b></span> use <tt>pmLoadNameSpace</tt>. If applications do not call <tt>pmLoadNameSpace</tt>, the default PMNS is the one at the source of the performance metrics.
</td></tr></table><hr noshade="noshade"></div><br></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5200158"></a>3.7.1.5. <tt>pmLoadASCIINameSpace</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmLoadASCIINameSpace(const char *<i>filename</i>, int <i>dupok</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177297"></a>If the application wants to force using a local Performance Metrics Name Space (PMNS) instead of a distributed PMNS, it must load the PMNS using <tt>pmLoadASCIINameSpace</tt> or <tt>pmLoadNameSpace</tt>. If the application wants to use a distributed PMNS, then it should not make a call to load the PMNS explicitly.</p>
<p><tt>pmLoadASCIINameSpace</tt> is a variant of <tt>pmLoadNameSpace</tt>, which only processes an ASCII format PMNS. The <i>dupok</i> argument may be used to control the handling of multiple names in the PMNS that may be associated with a single Performance Metric Identifier (PMID). A value of 0 disallows duplicates; any other value allows duplicates.</p>
<p>The <i>filename</i> argument designates the PMNS of interest. For applications not requiring a tailored PMNS, the special value <tt>PM_NS_DEFAULT</tt> may be used for <i>filename</i>, to force the default local PMNS to be loaded. Since this PMNS exists in a binary format, <tt>pmLoadNameSpace</tt> is the more efficient function to use.</p>
<p>The default local PMNS is found in the <tt>/var/pcp/pmns/root</tt> file unless the <tt>PMNS_DEFAULT</tt> environment variable is set. Then the value is assumed to be the pathname to the file containing the default local PMNS.</p>
<p><tt>pmLoadASCIINameSpace</tt> returns zero on success.</p>
<p>Syntax and other errors in the parsing of the PMNS are reported on stderr with a message of the form:<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">Error Parsing ASCII PMNS: ....</pre></td></tr></table><br></p>
<p><tt>PM_ERR_DUPPMNS</tt> is an error to try and load more than one PMNS, or to call either <tt>pmLoadASCIINameSpace</tt> or <tt>pmLoadNameSpace</tt> more than once. <tt>PM_ERR_PMNS</tt> indicates a syntax error in an ASCII format PMNS.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5200342"></a>3.7.1.6. <tt>pmLookupName</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmLookupName(int <i>numpmid</i>, char *<i>namelist</i>[], pmID <i>pmidlist</i>[])</pre></td></tr></table><p><a class="indexterm" name="IG31340177298"></a>Given a list in <i>namelist</i> containing <i>numpmid</i> full pathnames for performance metrics from the current PMNS, <tt>pmLookupName</tt> returns the list of associated PMIDs through the <i>pmidlist</i> parameter. Invalid metrics names are translated to the error PMID value of <tt>PM_ID_NULL</tt>.</p>
<p>The result from <tt>pmLookupName</tt> is the number of names translated in the absence of errors, or an error indication. Note that argument definition and the error protocol guarantee a one-to-one relationship between the elements of <i>namelist</i> and <i>pmidlist</i>; both lists contain exactly <i>numpmid</i> elements.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5200423"></a>3.7.1.7. <tt>pmNameAll</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmNameAll(pmID <i>pmid</i>, char ***<i>nameset</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177299"></a>Given a performance metric ID in <i>pmid</i>, <tt>pmNameAll</tt> determines all the corresponding metric names, if any, in the PMNS, and returns these through <i>nameset</i>.</p>
<p>The resulting list of pointers <i>nameset</i> and the values (relative names) that the pointers reference are allocated by <tt>pmNameAll</tt> with a single call to <tt>malloc</tt>. It is the caller's responsibility to call <tt>free</tt> and release the space when it is no longer required.</p>
<p>In the absence of errors, <tt>pmNameAll</tt> returns the number of names in <tt>nameset</tt>.</p>
<p>For many PMNS instances, there is a 1:1 mapping between a name and a PMID, and under these circumstances, <tt>pmNameID</tt> provides a simpler interface in the absence of duplicate names for a particular PMID.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5200532"></a>3.7.1.8. <tt>pmNameID</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmNameID(pmID <i>pmid</i>, char **<i>name</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177300"></a>Given a performance metric ID in <i>pmid</i>, <tt>pmNameID</tt> determines the corresponding metric name, if any, in the current PMNS, and returns this through <i>name</i>.</p>
<p>In the absence of errors, <tt>pmNameID</tt> returns zero. The <i>name</i> argument is a null byte terminated string, allocated by <tt>pmNameID</tt> using <tt>malloc</tt>. It is the caller's responsibility to call <tt>free</tt> and release the space when it is no longer required.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5200683"></a>3.7.1.9. <tt>pmTraversePMNS</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmTraversePMNS(const char *<i>name</i>, void (*<tt>dometric</tt>)(const char *))</pre></td></tr></table><p><a class="indexterm" name="IG31340177301"></a>The function <tt>pmTraversePMNS</tt> may be used to perform a depth-first traversal of the PMNS. The traversal starts at the node identified by <i>name</i> --if <i>name</i> is an empty string, the traversal starts at the root of the PMNS. Usually, <i>name</i> would be the pathname of a non-leaf node in the PMNS.</p>
<p><a class="indexterm" name="IG31340177302"></a><a class="indexterm" name="IG31340177303"></a>For each leaf node (actual performance metrics) found in the traversal, the user-supplied function <tt>dometric</tt> is called with the full pathname of that metric in the PMNS as the single argument; this argument is a null byte-terminated string, and is constructed from a buffer that is managed internally to <tt>pmTraversePMNS</tt>. Consequently, the value is valid only during the call to <tt>dometric</tt>--if the pathname needs to be retained, it should be copied using <tt>strdup</tt> before returning from <tt>dometric</tt>; see the <tt>strdup(3C)</tt> man page.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5200806"></a>3.7.1.10. <tt>pmUnloadNameSpace</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmUnloadNameSpace(void)</pre></td></tr></table><p><a class="indexterm" name="IG31340177304"></a>If a local PMNS was loaded with <tt>pmLoadNameSpace</tt>, calling <tt>pmUnloadNameSpace</tt> frees up the memory associated with the PMNS and force all subsequent Name Space functions to use the distributed PMNS. If <tt>pmUnloadNameSpace</tt> is called before calling <tt>pmLoadNameSpace</tt>, it has no effect.</p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="LE89521-PARENT"></a>3.7.2. PMAPI Metrics Description Services</h3></div></div>
<p>The functions described in this section provide Performance Metrics Application Programming Interface (PMAPI) metric description services.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5200868"></a>3.7.2.1. <tt>pmLookupDesc</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmLookupDesc(pmID <i>pmid</i>, pmDesc *<i>desc</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177305"></a><a class="indexterm" name="IG31340177306"></a><a class="indexterm" name="IG31340177307"></a><a class="indexterm" name="IG31340177308"></a>Given a Performance Metric Identifier (PMID) as <i>pmid</i>, <tt>pmLookupDesc</tt> returns the associated <tt>pmDesc</tt> structure through the parameter <i>desc</i> from the current PMAPI context. For more information about <tt>pmDesc</tt>, see <a href="ch03.html#LE11914-PARENT" title="3.4. Performance Metric Descriptions">Section 3.4</a>.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5200999"></a>3.7.2.2. <tt>pmLookupInDomText</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int pmLookupInDomText(pmInDom <i>indom</i>, int <i>level</i>, char **<i>buffer</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177309"></a><a class="indexterm" name="IG31340177310"></a>Provided the source of metrics from the current PMAPI context is a host, retrieve descriptive text about the performance metrics instance domain identified by <i>indom</i>.</p>
<p><a class="indexterm" name="IG31340177311"></a>The <i>level</i> argument should be <tt>PM_TEXT_ONELINE</tt> for a one-line summary, or <tt>PM_TEXT_HELP</tt> for a more verbose description suited to a help dialogue. The space pointed to by <i>buffer</i> is allocated in <tt>pmLookupInDomText</tt> with <tt>malloc</tt>, and it is the responsibility of the caller to free unneeded space; see the <tt>malloc(3C)</tt> and<tt> free(3C)</tt> man pages.</p>
<p>The help text files used to implement <tt>pmLookupInDomText</tt> are created using <tt>newhelp</tt> and accessed by the appropriate PMDA response to requests forwarded to the PMDA by PMCD. Further details may be found in <a href="ch02.html#LE72473-PARENT" title="2.4.4. PMDA Help Text">Section 2.4.4</a><a href="ch02.html#LE72473-PARENT"> in Chapter 2</a>.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5201140"></a>3.7.2.3. <tt>pmLookupText</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int pmLookupText(pmID <i>pmid</i>, int <i>level</i>, char **<i>buffer</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177312"></a><a class="indexterm" name="IG31340177313"></a>Provided the source of metrics from the current PMAPI context is a host, retrieve descriptive text about the performance metric identified by <i>pmid</i>. The argument <i>level</i> should be <tt>PM_TEXT_ONELINE</tt> for a one-line summary, or <tt>PM_TEXT_HELP</tt> for a more verbose description, suited to a help dialogue.</p>
<p>The space pointed to by <i>buffer</i> is allocated in <tt>pmLookupText</tt> with <tt>malloc</tt>, and it is the responsibility of the caller to <tt>free</tt> the space when it is no longer required; see the <tt>malloc(3C)</tt> and <tt>free(3C)</tt> man pages.</p>
<p>The help text files used to implement <tt>pmLookupText</tt> are created using <tt>newhelp</tt> and accessed by the appropriate PMDA in response to requests forwarded to the PMDA by PMCD. Further details may be found in <a href="ch02.html#LE72473-PARENT" title="2.4.4. PMDA Help Text">Section 2.4.4</a><a href="ch02.html#LE72473-PARENT"> in Chapter 2</a>.</p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="LE27200-PARENT"></a>3.7.3. PMAPI Instance Domain Services</h3></div></div>
<p>The functions described in this section provide Performance Metrics Application Programming Interface (PMAPI) instance domain services.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5201278"></a>3.7.3.1. <tt>pmGetInDom</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmGetInDom(pmInDom <i>indom</i>, int **<i>instlist</i>, char ***<i>namelist</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177314"></a><a class="indexterm" name="IG31340177315"></a><a class="indexterm" name="IG31340177316"></a><a class="indexterm" name="IG31340177317"></a>In the current PMAPI context, locate the description of the instance domain <i>indom</i>, and return through <i>instlist</i> the internal instance identifiers for all instances, and through <i>namelist</i> the full external identifiers for all instances. The number of instances found is returned as the function value (or less than zero to indicate an error).</p>
<p>The resulting lists of instance identifiers (<i>instlist</i> and <i>namelist</i>), and the names that the elements of <i>namelist</i> point to, are allocated by <tt>pmGetInDom</tt> with two calls to <tt>malloc</tt>, and it is the responsibility of the caller to use <tt>free</tt><i>(instlist)</i> and <tt>free</tt><i>(namelist) </i>to release the space when it is no longer required. When the result of <tt>pmGetInDom</tt> is less than one, both <i>instlist</i> and <i>namelist</i> are undefined (no space is allocated, and so calling <tt>free</tt> is a bad idea); see the <tt>
malloc(3C)</tt> and <tt>free(3C)</tt> man pages.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5201511"></a>3.7.3.2. <tt>pmLookupInDom</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int pmLookupInDom(pmInDom <i>indom</i>, const char *<i>name</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177318"></a>For the instance domain <i>indom</i>, in the current PMAPI context, locate the instance with the external identification given by <i>name</i>, and return the internal instance identifier.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5201553"></a>3.7.3.3. <tt>pmNameInDom</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int pmNameInDom(pmInDom <i>indom</i>, int <i>inst</i>, char **<i>name</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177319"></a>For the instance domain <i>indom</i>, in the current PMAPI context, locate the instance with the internal instance identifier given by <i>inst</i>, and return the full external identification through <i>name</i>. The space for the value of <i>name</i> is allocated in <tt>pmNameInDom</tt> with <tt>malloc</tt>, and it is the responsibility of the caller to free the space when it is no longer required; see the <tt>malloc(3C)</tt> and <tt>free(3C)</tt> man pages.</p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="LE94187-PARENT"></a>3.7.4. PMAPI Context Services</h3></div></div>
<p><a class="indexterm" name="IG31340177320"></a><a class="indexterm" name="IG31340177321"></a><a href="ch03.html#id5201726" title="Table 3-1. Context Components of PMAPI Functions ">Table 3-1</a> shows which of the three components of a PMAPI context (metrics source, instance profile, and collection time) are relevant for various PMAPI functions. Those PMAPI functions not shown in this table either manipulate the PMAPI context directly, or are executed independently of the current PMAPI context.</p>
<div class="table"><a name="id5201726"></a><p><a name="id5201726"></a><b>Table 3-1. Context Components of PMAPI Functions </b></p>
<table summary="Context Components of PMAPI Functions " border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr valign="top"><th scope="col" align="left" valign="bottom"><p>Function Name</p>
</th><th scope="col" align="left" valign="bottom"><p>Metrics Source</p>
</th><th scope="col" align="left" valign="bottom"><p>Instance Profile</p>
</th><th scope="col" align="left" valign="bottom"><p>Collection Time</p>
</th><th scope="col" align="left" valign="bottom"><p>Notes</p>
</th></tr></thead><tbody><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmAddProfile</tt><a class="indexterm" name="IG31340177322"></a></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p> </p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmDelProfile<a class="indexterm" name="IG31340177323"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p> </p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmDupContext<a class="indexterm" name="IG31340177324"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmFetch<a class="indexterm" name="IG31340177325"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmFetchArchive<a class="indexterm" name="IG31340177326"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p>(1)</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmGetArchiveEnd<a class="indexterm" name="IG31340177327"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>(1)</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmGetArchiveLabel<a class="indexterm" name="IG31340177328"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>(1)</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmGetChildren<a class="indexterm" name="IG31340177329"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>(5)</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmGetChildrenStatus<a class="indexterm" name="IG31340177330"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>(5)</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmGetPMNSLocation<a class="indexterm" name="IG31340177331"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p> </p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmGetInDom<a class="indexterm" name="IG31340177332"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p>(2)</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmGetInDomArchive<a class="indexterm" name="IG31340177333"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>(1)</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmLookupDesc<a class="indexterm" name="IG31340177334"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>(3)</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmLookupInDom<a class="indexterm" name="IG31340177335"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p>(2)</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmLookupInDomArchive<a class="indexterm" name="IG31340177336"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>(1,2)</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmLookupInDomText<a class="indexterm" name="IG31340177337"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>(4)</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmLookupName<a class="indexterm" name="IG31340177338"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>(5)</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmLookupText<a class="indexterm" name="IG31340177339"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>(4)</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmNameAll</tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>(5)</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmNameID<a class="indexterm" name="IG31340177340"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>(5)</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmNameInDom<a class="indexterm" name="IG31340177341"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p>(2)</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmNameInDomArchive<a class="indexterm" name="IG31340177342"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>(1,2)</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmSetMode<a class="indexterm" name="IG31340177343"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmStore<a class="indexterm" name="IG31340177344"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>(6)</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmTraversePMNS<a class="indexterm" name="IG31340177345"></a></tt></p>
</td><td align="left" valign="top"><p>Yes</p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p> </p>
</td><td align="left" valign="top"><p>(5)</p>
</td></tr></tbody></table></div><p>Notes:</p>
<div class="orderedlist"><ol type="1"><li><p>Operation supported only for PMAPI contexts where the source of metrics is an archive.</p>
</li>
<li><p><a class="indexterm" name="IG31340177346"></a>A specific instance domain is included in the arguments to these functions, and the result is independent of the instance profile for any PMAPI context.</p>
</li>
<li><p>The metadata that describes a performance metric is sensitive to the source of the metrics, but independent of any instance profile and of the collection time.</p>
</li>
<li><p><a class="indexterm" name="IG31340177347"></a>Operation is supported only for PMAPI contexts where the source of metrics is a host. The text associated with a metric is assumed to be invariant with time and is definitely insensitive to the current members of the instance domain. In all cases this information is unavailable from an archive context (it is not included in the archive logs), and is directly available from a PMDA via PMCD in the other cases.</p>
</li>
<li><p>PMNS service functions using a local PMNS do <span class="bold"><b>not</b></span> depend on the PMAPI context, whereas PCP 2.<i>x</i> distributed PMNS services are dependent on the source of metrics.</p>
</li>
<li><p>This operation is supported only for contexts where the source of the metrics is a host. Further, the instance identifiers are included in the argument to the function, and the effects upon the current values of the metrics are immediate (retrospective changes are not allowed). Consequently, from the current PMAPI context, neither the instance profile nor the collection time influence the result of this function.</p>
</li>
</ol></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5203779"></a>3.7.4.1. <tt>pmNewContext</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int pmNewContext(int <i>type</i>, const char *<i>name</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177348"></a><a class="indexterm" name="IG31340177349"></a><a class="indexterm" name="IG31340177350"></a>The <tt>pmNewContext</tt> function may be used to establish a new PMAPI context. The source of metrics is identified by <i>name</i>, and may be a host name (<i>type</i> is <tt>PM_CONTEXT_HOST</tt>) or the basename of an archive log (<i>type</i> is <tt>PM_CONTEXT_ARCHIVE</tt>).</p>
<p>In the case where <i>type</i> is <tt>PM_CONTEXT_LOCAL</tt>, <i>name</i> is ignored, and the context uses a stand-alone connection to the PMDA methods used by PMCD. When this type of context is in effect, the range of accessible performance metrics is constrained to those from the operating system, and optionally the <tt>proc</tt> and <tt>sample</tt> PMDAs.</p>
<p><a class="indexterm" name="IG31340177351"></a><a class="indexterm" name="IG31340177352"></a>The initial instance profile is set up to select all instances in all instance domains, and the initial collection time is the current time at the time of each request for a host, or the time at the start of the log for an archive. In the case of archives, the initial collection time results in the earliest set of metrics being returned from the archive at the first <tt>pmFetch</tt>.</p>
<p>Once established, the association between a PMAPI context and a source of metrics is fixed for the life of the context; however, functions are provided to independently manipulate both the instance profile and the collection time components of a context.</p>
<p><a class="indexterm" name="IG31340177353"></a>The function returns a &#8220;handle&#8221; that may be used in subsequent calls to <tt>pmUseContext</tt>. This new PMAPI context stays in effect for all subsequent context sensitive calls across the PMAPI until another call to <tt>pmNewContext</tt> is made, or the context is explicitly changed with a call to <tt>pmDupContext</tt> or <tt>pmUseContext</tt>.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5203964"></a>3.7.4.2. <tt>pmDestroyContext</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int pmDestroyContext(int <i>handle</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177354"></a>The PMAPI context identified by <i>handle</i> is destroyed. Typically, this implies terminating a connection to PMCD or closing an archive file, and orderly clean-up. The PMAPI context must have been previously created using <tt>pmNewContext</tt> or <tt>pmDupContext</tt>.</p>
<p>On success, <tt>pmDestroyContext</tt> returns zero. If <i>handle</i> was the current PMAPI context, then the current context becomes undefined. This means the application must explicitly re-establish a valid PMAPI context with <tt>pmUseContext</tt>, or create a new context with <tt>pmNewContext</tt> or <tt>pmDupContext</tt>, before the next PMAPI operation requiring a PMAPI context.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5204063"></a>3.7.4.3. <tt>pmDupContext</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int pmDupContext(void)</pre></td></tr></table><p><a class="indexterm" name="IG31340177355"></a>Replicate the current PMAPI context (source, instance profile, and collection time). This function returns a handle for the new context, which may be used with subsequent calls to <tt>pmUseContext</tt>. The newly replicated PMAPI context becomes the current context.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5204116"></a>3.7.4.4. <tt>pmUseContext</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int pmUseContext(int <i>handle</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177356"></a>Calling <tt>pmUseContext</tt> causes the current PMAPI context to be set to the context identified by <i>handle</i>. The value of <i>handle</i> must be one returned from an earlier call to <tt>pmNewContext</tt> or <tt>pmDupContext</tt>.</p>
<p>Below the PMAPI, all contexts used by an application are saved in their most recently modified state, so <tt>pmUseContext</tt> restores the context to the state it was in the last time the context was used, not the state of the context when it was established.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5204177"></a>3.7.4.5. <tt>pmWhichContext</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int pmWhichContext(void)</pre></td></tr></table><p><a class="indexterm" name="IG31340177357"></a><a class="indexterm" name="IG31340177358"></a>Returns the handle for the current PMAPI context (source, instance profile, and collection time).</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5204210"></a>3.7.4.6. <tt>pmAddProfile</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int pmAddProfile(pmInDom <i>indom</i>, int <i>numinst</i>, int <i>instlist</i>[])</pre></td></tr></table><p><a class="indexterm" name="IG31340177359"></a><a class="indexterm" name="IG31340177360"></a><a class="indexterm" name="IG31340177361"></a>Add new instance specifications to the instance profile of the current PMAPI context. At its simplest, instances identified by the <i>instlist</i> argument for the <i>indom</i> instance domain are added to the instance profile. The list of instance identifiers contains <i>numinst</i> values.</p>
<p><a class="indexterm" name="IG31340177362"></a>If <i>indom</i> equals <tt>PM_INDOM_NULL</tt>, or <i>numinst</i> is zero, then all instance domains are selected. If <i>instlist</i> is NULL, then all instances are selected. To enable all available instances in all domains, use this syntax:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">pmAddProfile(PM_INDOM_NULL, 0, NULL).</pre></td></tr></table><br></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5204360"></a>3.7.4.7. <tt>pmDelProfile</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int pmDelProfile(pmInDom <i>indom</i>, int <i>numinst</i>, int <i>instlist</i>[])</pre></td></tr></table><p><a class="indexterm" name="IG31340177363"></a><a class="indexterm" name="IG31340177364"></a>Delete instance specifications from the instance profile of the current PMAPI context. In the simplest variant, the list of instances identified by the <i>instlist</i> argument for the <i>indom</i> instance domain is removed from the instance profile. The list of instance identifiers contains <i>numinst</i> values.</p>
<p>If <i>indom</i> equals <tt>PM_INDOM_NULL</tt>, then all instance domains are selected for deletion. If <i>instlist</i> is NULL, then all instances in the selected domains are removed from the profile. To disable all available instances in all domains, use this syntax:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">pmDelProfile(PM_INDOM_NULL, 0, NULL) </pre></td></tr></table><br></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5204444"></a>3.7.4.8. <tt>pmSetMode</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int pmSetMode(int <i>mode</i>, const struct timeval *<i>when</i>, int <i>delta</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177365"></a><a class="indexterm" name="IG31340177366"></a><a class="indexterm" name="IG31340177367"></a><a class="indexterm" name="IG31340177368"></a><a class="indexterm" name="IG31340177369"></a><a class="indexterm" name="IG31340177370"></a><a class="indexterm" name="IG31340177371"></a>This function defines the collection time and mode for accessing performance metrics and metadata in the current PMAPI context. This mode affects the semantics of subsequent calls to the following PMAPI functions: <tt>pmFetch</tt>, <tt>pmFetchArchive</tt>, <tt>pmLookupDesc</tt>, <tt>pmGetInDom</tt>, <tt>pmLookupInDom
</tt>, and <tt>pmNameInDom</tt>.</p>
<p>The <tt>pmSetMode</tt> function requires the current PMAPI context to be of type <tt>PM_CONTEXT_ARCHIVE</tt>.</p>
<p>The <i>when</i> parameter defines a time origin, and all requests for metadata (metrics descriptions and instance identifiers from the instance domains) are processed to reflect the state of the metadata as of the time origin. For example, use the last state of this information at, or before, the time origin.</p>
<p>If the <i>mode</i> is <tt>PM_MODE_INTERP</tt> then, in the case of <tt>pmFetch</tt>, the underlying code uses an interpolation scheme to compute the values of the metrics from the values recorded for times in the proximity of the time origin.</p>
<p>If the <i>mode</i> is <tt>PM_MODE_FORW</tt>, then, in the case of <tt>pmFetch</tt>, the collection of recorded metric values is scanned forward, until values for at least one of the requested metrics is located after the time origin. Then all requested metrics stored in the PCP archive at that time are returned with a corresponding time stamp. This is the default mode when an archive context is first established with <tt>pmNewContext</tt>.</p>
<p>If the <i>mode</i> is <tt>PM_MODE_BACK</tt>, then the situation is the same as for <tt>PM_MODE_FORW</tt>, except a <tt>pmFetch</tt> is serviced by scanning the collection of recorded metrics backward for metrics before the time origin.</p>
<p>After each successful <tt>pmFetch</tt>, the time origin is reset to the time stamp returned through the <tt>pmResult</tt>.</p>
<p>The <tt>pmSetMode</tt> parameter <i>delta</i> defines an additional number of time unit that should be used to adjust the time origin (forward or backward) after the new time origin from the <tt>pmResult</tt> has been determined. This is useful when moving through archives with a mode of <tt>PM_MODE_INTERP</tt>. The high-order bits of the <i>mode</i> parameter field is also used to optionally set the units of time for the <tt>delta</tt> field. To specify the units of time, use the <tt>PM_XTB_SET</tt> macro with one of the values <tt>PM_TIME_NSEC</tt>, <tt>PM_TIME_MSEC</tt>, <tt>PM_TIME_SEC</tt>, or so on as follows:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">PM_MODE_INTERP | PM_XTB_SET(PM_TIME_<i>XXXX)</i></pre></td></tr></table><p>If no units are specified, the default is to interpret <i>delta</i> as milliseconds.</p>
<p>Using these mode options, an application can implement replay, playback, fast forward, or reverse for performance metric values held in a PCP archive log by alternating calls to <tt>pmSetMode</tt> and <tt>pmFetch</tt>.</p>
<p>In <a href="ch03.html#Z976827209sdc" title="Example 3-10. Dumping Values in Temporal Sequence">Example 3-10</a>, the code fragment may be used to dump only those values stored in correct temporal sequence, for the specified performance metric <tt>my.metric.name</tt>:</p>
<div class="example"><a name="Z976827209sdc"></a><p><a name="Z976827209sdc"></a><b>Example 3-10. Dumping Values in Temporal Sequence</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int     sts;
pmID    pmid;
char    *name = &#8220;my.metric.name&#8221;;
    sts = pmNewContext(PM_CONTEXT_ARCHIVE, &#8220;myarchive&#8221;);
    sts = pmLookupName(1, &amp;name, &amp;pmid);
    for ( ; ; ) {
        sts = pmFetch(1, &amp;pmid, &amp;result);
        if (sts &lt; 0)
            break;
        /* dump value(s) from result-&gt;vset[0]-&gt;vlist[] */
        pmFreeResult(result);
   }</pre></td></tr></table><br></div><p><a class="indexterm" name="IG31340177372"></a>Alternatively, the code fragment in <a href="ch03.html#Z976827219sdc" title="Example 3-11. Replaying Interpolated Metrics">Example 3-11</a> may be used to replay interpolated metrics from an archive in reverse chronological order, at ten-second intervals (of recorded time):</p>
<div class="example"><a name="Z976827219sdc"></a><p><a name="Z976827219sdc"></a><b>Example 3-11. Replaying Interpolated Metrics</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int             sts;
pmID            pmid;
char            *name = &#8220;my.metric.name&#8221;;
struct timeval  endtime;
    sts = pmNewContext(PM_CONTEXT_ARCHIVE, &#8220;myarchive&#8221;);
    sts = pmLookupName(1, &amp;name, &amp;pmid);
    sts = pmGetArchiveEnd(&amp;endtime);
    sts = pmSetMode(PM_MODE_INTERP, &amp;endtime, -10000);
    while (pmFetch(1, &amp;pmid, &amp;result) != PM_ERR_EOL) {
        /*
         * process interpolated metric values as of result-&gt;timestamp
         */
        pmFreeResult(result);
   }</pre></td></tr></table><br></div><br></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5204926"></a>3.7.4.9. <tt>pmReconnectContext</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int pmReconnectContext(int <i>handle</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177373"></a><a class="indexterm" name="IG31340177374"></a>As a result of network, host, or PMCD (Performance Metrics Collection Daemon) failure, an application's connection to PMCD may be established and then lost.</p>
<p><a class="indexterm" name="IG31340177375"></a>The function <tt>pmReconnectContext</tt> allows an application to request that the PMAPI context identified by <i>handle</i> be re-established, provided the associated PMCD is accessible.</p>
<div class="note"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/note.png" height="24" width="24"></td><td align="left" valign="top"><b>Note: </b><i>handle</i> may or may not be the current context.
</td></tr></table><hr noshade="noshade"></div><p><a class="indexterm" name="IG31340177376"></a>To avoid flooding the system with reconnect requests, <tt>pmReconnectContext</tt> attempts a reconnection only after a suitable delay from the previous attempt. This imposed restriction on the reconnect re-try time interval uses a default exponential back-off so that the initial delay is 5 seconds after the first unsuccessful attempt, then 10 seconds, then 20 seconds, then 40 seconds, and then 80 seconds thereafter. The intervals between reconnection attempts may be modified using the environment variable <tt>PMCD_RECONNECT_TIMEOUT</tt> and the time to wait before an attempted connection is deemed to have failed is controlled by the <tt>PMCD_CONNECT_TIMEOUT</tt> environment variable;
see the <tt>PCPIntro(1)</tt> man page.</p>
<p>If the reconnection succeeds, <tt>pmReconnectContext</tt> returns <i>handle</i>. Note that even in the case of a successful reconnection, <tt>pmReconnectContext</tt> does not change the current PMAPI context.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5205074"></a>3.7.4.10. <tt>pmGetContextHostName</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">const char *pmGetContextHostName(int <i>id</i>)</pre></td></tr></table><p>Given a valid PCP context identifier previously created with <tt>pmNewContext</tt> or <tt>pmDupContext</tt>, the <tt>pmGetContextHostName</tt> function provides a possibility to retrieve a host name associated with a context regardless of the context type.</p>
<p>If <i>id</i> is not a valid PCP context identifier, this function returns a zero length string and therefore never fails.</p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="LE34685-PARENT"></a>3.7.5. PMAPI Timezone Services</h3></div></div>
<p>The functions described in this section provide Performance Metrics Application Programming Interface (PMAPI) timezone services.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5205140"></a>3.7.5.1. <tt>pmNewContextZone</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmNewContextZone(void)</pre></td></tr></table><p><a class="indexterm" name="IG31340177377"></a><a class="indexterm" name="IG31340177378"></a><a class="indexterm" name="IG31340177379"></a>If the current PMAPI context is an archive, the <tt>pmNewContextZone</tt> function uses the timezone from the archive label record to set the current reporting timezone. The current reporting timezone affects the timezone used by <tt>pmCtime</tt> and <tt>pmLocaltime</tt>.</p>
<p>If the current PMAPI context corresponds to a host source of metrics, <tt>pmNewContextZone</tt> executes a <tt>pmFetch</tt> to retrieve the value for the metric <tt>pmcd.timezone</tt> and uses that to set the current reporting timezone.</p>
<p>In both cases, the function returns a value to identify the current reporting timezone that may be used in a subsequent call to <tt>pmUseZone</tt> to restore this reporting timezone.</p>
<p><tt>PM_ERR_NOCONTEXT</tt> indicates the current PMAPI context is not valid. A return value less than zero indicates a fatal error from a system call, most likely <tt>malloc</tt>.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5205286"></a>3.7.5.2. <tt>pmNewZone</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmNewZone(const char *<i>tz</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177380"></a>The <tt>pmNewZone</tt> function sets the current reporting timezone, and returns a value that may be used in a subsequent call to <tt>pmUseZone</tt> to restore this reporting timezone. The current reporting timezone affects the timezone used by <tt>pmCtime</tt> and <tt>pmLocaltime</tt>.</p>
<p>The <i>tz</i> argument defines a timezone string, in the format described for the <tt>TZ</tt> environment variable. See the <tt>environ(5)</tt> man page.</p>
<p>A return value less than zero indicates a fatal error from a system call, most likely <tt>malloc</tt>.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5205362"></a>3.7.5.3. <tt>pmUseZone</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmUseZone(const int <i>tz_handle</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177381"></a>In the <tt>pmUseZone</tt> function, <i>tz_handle</i> identifies a reporting timezone as previously established by a call to <tt>pmNewZone</tt> or <tt>pmNewContextZone</tt>, and this becomes the current reporting timezone. The current reporting timezone effects the timezone used by <tt>pmCtime</tt> and <tt>pmLocaltime</tt>).</p>
<p>A return value less than zero indicates the value of <i>tz_handle</i> is not legal.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5205444"></a>3.7.5.4. <tt>pmWhichZone</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmWhichZone(char **<i>tz</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177382"></a>The <tt>pmWhichZone</tt> function returns the handle of the current timezone, as previously established by a call to <tt>pmNewZone</tt> or <tt>pmNewContextZone</tt>. If the call is successful (that is, there exists a current reporting timezone), a non-negative integer is returned and <i>tz</i> is set to point to a static buffer containing the timezone string itself. The current reporting timezone effects the timezone used by <tt>pmCtime</tt> and <tt>pmLocaltime</tt>.</p>
<p>A return value less than zero indicates there is no current reporting timezone.</p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="LE25844-PARENT"></a>3.7.6. PMAPI Metrics Services</h3></div></div>
<p>The functions described in this section provide Performance Metrics Application Programming Interface (PMAPI) metrics  services.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="Z1034802678tls"></a>3.7.6.1. <tt>pmFetch</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int pmFetch(int <i>numpmid</i>, pmID <i>pmidlist</i>[], pmResult **<i>result</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177383"></a><a class="indexterm" name="IG31340177384"></a><a class="indexterm" name="IG31340177385"></a>The most common PMAPI operation is likely to be calls to <tt>pmFetch</tt>, specifying a list of PMIDs (for example, as constructed by <tt>pmLookupName</tt>) through <i>pmidlist</i> and <i>numpmid</i>. The call to <tt>pmFetch</tt> is executed in the context of a source of metrics, instance profile, and collection time, previously established by calls to the functions described in <a href="ch03.html#LE94187-PARENT" title="3.7.4. PMAPI Context Services">Section 3.7.4</a>.</p>
<p>The principal result from <tt>pmFetch</tt> is returned as a tree structured <i>result</i>, described in the <a href="ch03.html#LE82331-PARENT" title="3.5. Performance Metrics Values">Section 3.5</a>.</p>
<p>If one value (for example, associated with a particular instance) for a requested metric is unavailable at the requested time, then there is no associated <tt>pmValue</tt> structure in the result. If there are no available values for a metric, then <i>numval</i> is zero and the associated <tt>pmValue</tt>[] instance is empty; <i>valfmt</i> is undefined in these circumstances, but <i>pmid</i> is correctly set to the PMID of the metric with no values.</p>
<p>If the source of the performance metrics is able to provide a reason why no values are available for a particular metric, this reason is encoded as a standard error code in the corresponding <i>numval</i>; see the <tt>pmerr(1)</tt> and <tt>pmErrStr(3)</tt> man pages. Since all error codes are negative, values for a requested metric are unavailable if <i>numval</i> is less than or equal to zero.</p>
<p>The argument definition and the result specifications have been constructed to ensure that for each PMID in the requested <i>pmidlist</i> there is exactly one <tt>pmValueSet</tt> in the result, and that the PMIDs appear in exactly the same sequence in both <i>pmidlist</i> and <i>result</i>. This makes the number and order of entries in <i>result</i> completely deterministic, and greatly simplifies the application programming logic after the call to <tt>pmFetch</tt>.</p>
<p><a class="indexterm" name="IG31340177386"></a>The result structure returned by <tt>pmFetch</tt> is dynamically allocated using one or more calls to <tt>malloc</tt> and specialized allocation strategies, and should be released when no longer required by calling <tt>pmFreeResult</tt>. Under no circumstances should <tt>free</tt> be called directly to release this space.</p>
<p>As common error conditions are encoded in the result data structure, only serious events (such as loss of connection to PMCD, <tt>malloc</tt> failure, and so on) would cause an error value to be returned by <tt><a class="indexterm" name="IG31340177387"></a>pmFetch</tt>. Otherwise, the value returned by the <tt>pmFetch</tt> function is zero.</p>
<p>In <a href="ch03.html#Z976559487sdc" title="Example 3-12. PMAPI Metrics Services">Example 3-12</a>, the code fragment dumps the values (assumed to be stored in the <i>lval</i> element of the <tt>pmValue</tt> structure) of selected performance metrics once every 10 seconds:</p>
<div class="example"><a name="Z976559487sdc"></a><p><a name="Z976559487sdc"></a><b>Example 3-12. PMAPI Metrics Services</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int       i, j, sts;
pmID      pmidlist[10];
pmResult  *result;
time_t    now;
/* set up PMAPI context, numpmid and pmidlist[] ... */
while ((sts = pmFetch(10, pmidlist, &amp;result)) &gt;= 0) {
    now = (time_t)result-&gt;timestamp.tv_sec;
    printf(&quot;\n@ %s&quot;, ctime(&amp;now));
    for (i = 0; i &lt; result-&gt;numpmid; i++) {
        printf(&quot;PMID: %s&quot;, pmIDStr(result-&gt;vset[i]-&gt;pmid));
        for (j = 0; j &lt; result-&gt;vset[i]-&gt;numval; j++) {
            printf(&quot; 0x%x&quot;, result-&gt;vset[i]-&gt;vlist[j].value.lval);
            putchar('\n');
        }
    }
    pmFreeResult(result);
    sleep(10);
}</pre></td></tr></table><br></div><br><div class="note"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/note.png" height="24" width="24"></td><td align="left" valign="top"><b>Note: </b><a class="indexterm" name="IG31340177388"></a><a class="indexterm" name="IG31340177389"></a>If a response is not received back from PMCD within 10 seconds, the <tt>pmFetch</tt> times out and returns <tt>PM_ERR_TIMEOUT</tt>. This is most likely to occur when the PMAPI client and PMCD are communicating over a slow network connection, but may also occur when one of the hosts is extremely busy. The time out period may be modified using the <tt>PMCD_REQUEST_TIMEOUT</tt> environment variable; see the <tt>PCPIntro(1)</tt> man page.
</td></tr></table><hr noshade="noshade"></div><br></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5205941"></a>3.7.6.2. <tt>pmFreeResult</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">void pmFreeResult(pmResult *<i>result</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177390"></a><a class="indexterm" name="IG31340177391"></a>Release the storage previously allocated for a result by <tt>pmFetch</tt>.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5206030"></a>3.7.6.3. <tt>pmStore</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int pmStore(const pmResult *<i>request</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177392"></a>In some special cases it may be helpful to modify the current values of performance metrics in one or more underlying domains, for example to reset a counter to zero, or to modify a <i>metric</i>, which is a control variable within a Performance Metric Domain.</p>
<p><a class="indexterm" name="IG31340177393"></a>The <tt>pmStore</tt> function is a lightweight inverse of <tt>pmFetch</tt>. The caller must build the <tt>pmResult</tt> data structure (which could have been returned from an earlier <tt>pmFetch</tt> call) and then call <tt>pmStore</tt>. It is an error to pass a <i>request</i> to <tt>pmStore</tt> in which the <tt>numval</tt> field within any of the <tt>pmValueSet</tt> structure has a value less than one.</p>
<p>The current PMAPI context must be one with a host as the source of metrics, and the current value of the nominated metrics is changed. For example, <tt>pmStore</tt> cannot be used to make retrospective changes to information in a PCP archive log.</p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="LE40692-PARENT"></a>3.7.7. PMAPI Record-Mode Services</h3></div></div>
<p>The functions described in this section provide Performance Metrics Application Programming Interface (PMAPI) record-mode  services.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="LE13213-PARENT"></a>3.7.7.1. <tt>pmRecordAddHost</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmRecordAddHost(const char *<i>host</i>, int <i>isdefault</i>, pmRecordHost **<i>rhp</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177394"></a><a class="indexterm" name="IG31340177395"></a><a class="indexterm" name="IG31340177396"></a>The <tt>pmRecordAddHost</tt> function adds hosts once <tt>pmRecordSetup</tt> has established a new recording session. The <tt>pmRecordAddHost</tt> function along with the <tt>pmRecordSetup</tt> and <tt>pmRecordControl</tt> functions are used to create a PCP archive.</p>
<p><tt>pmRecordAddHost</tt> is called for each host that is to be included in the recording session. A new <tt>pmRecordHost</tt> structure is returned via <i>rhp</i>. It is assumed that PMCD is running on the host as this is how <tt>pmlogger</tt> retrieves the required performance metrics.</p>
<p>If this host is the default host for the recording session, <i>isdefault</i> is nonzero. This ensures that the corresponding archive appears first in the PCP archive <i>folio</i>. Hence the tools used to replay the archive <i>folio</i> make the correct determination of the archive associated with the default host. At most one host per recording session may be nominated as the default host.</p>
<p>The calling application writes the desired <tt>pmlogger</tt> configuration onto the stdio stream returned via the <tt>f_config</tt> field in the <tt>pmRecordHost</tt> structure.</p>
<p><tt>pmRecordAddHost</tt> returns 0 on success and a value less than 0 suitable for decoding with <tt>pmErrStr</tt> on failure. The value <tt>EINVAL</tt> has the same interpretation as <tt>errno</tt> being set to <tt>EINVA</tt>.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="LE35969-PARENT"></a>3.7.7.2. <tt>pmRecordControl</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmRecordControl(pmRecordHost *<i>rhp</i>, int <i>request</i>, const char *<i>options</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177397"></a>Arguments may be optionally added to the command line that is used to launch <tt>pmlogger</tt> by calling the <tt>pmRecordControl</tt> function with a request of <tt>PM_REC_SETARG</tt>. The <tt>pmRecordControl</tt> along with the <tt>pmRecordSetup</tt> and <tt>pmRecordAddHost</tt> functions are used to create a PCP archive.</p>
<p>The argument is passed via <i>options</i> and one call to <tt>pmRecordControl</tt> is required for each distinct argument. An argument may be added for a particular <tt>pmlogger</tt> instance identified by <i>rhp</i>. If the <i>rhp</i> argument is NULL, the argument is added for all <tt>pmlogger</tt> instances that are launched in the current recording session.</p>
<p>Independent of any calls to <tt>pmRecordControl</tt> with a request of <tt>PM_REC_SETARG</tt>, each <tt>pmlogger</tt> instance is automatically launched with the following arguments: <tt>-c</tt>, <tt>-h</tt>, <tt>-l</tt>, <tt>-x</tt>, and the basename for the PCP archive log.</p>
<p>To commence the recording session, call <tt>pmRecordControl</tt> with a request of <tt>PM_REC_ON</tt>, and <i>rhp</i> must be NULL. This launches one <tt>pmlogger</tt> process for each host in the recording session and initializes the <tt>fd_ipc</tt>, <tt>logfile</tt>, <tt>pid</tt>, and <tt>status</tt> fields in the associated <tt>pmRecordHost</tt> structure(s).</p>
<p>To terminate a <tt>pmlogger</tt> instance identified by <i>rhp</i>, call <tt>pmRecordControl</tt> with a request of <tt>PM_REC_OFF</tt>. If the <i>rhp</i> argument to <tt>pmRecordControl</tt> is NULL, the termination request is broadcast to all <tt>pmlogger</tt> processes in the current recording session. An informative dialogue is generated directly by each <tt>pmlogger</tt> process.</p>
<p>To display the current status of the <tt>pmlogger</tt> instance identified by <i>rhp</i>, call <tt>pmRecordControl</tt> with a request of <tt>PM_REC_STATUS</tt>. If the <i>rhp</i> argument to <tt>pmRecordControl</tt> is NULL, the status request is broadcast to all <tt>pmlogger</tt> processes in the current recording session. The display is generated directly by each <tt>pmlogger</tt> process.</p>
<p>To detach a <tt>pmlogger</tt> instance identified by <i>rhp</i>, allow it to continue independent of the application that launched the recording session and call <tt>pmRecordControl</tt> with a request of <tt>PM_REC_DETACH</tt>. If the <i>rhp</i> argument to <tt>pmRecordControl</tt> is NULL, the detach request is broadcast to all <tt>pmlogger</tt> processes in the current recording session.</p>
<p><tt>pmRecordControl</tt> returns 0 on success and a value less than 0 suitable for decoding with <tt>pmErrStr</tt> on failure. The value <tt>EINVAL</tt> has the same interpretation as <tt>errno</tt> being set to <tt>EINVA</tt>.</p>
<p><tt>pmRecordControl</tt> returns <tt>PM_ERR_IPC</tt> if the associated <tt>pmlogger</tt> process has already exited.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5206798"></a>3.7.7.3. <tt>pmRecordSetup</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">FILE *pmRecordSetup(const char *<i>folio</i>, const char *<i>creator</i>, int <i>replay</i>) </pre></td></tr></table><p><a class="indexterm" name="IG31340177398"></a>The <tt>pmRecordSetup</tt> function along with the <tt>pmRecordAddHost</tt> and <tt>pmRecordControl</tt> functions may be used to create a PCP archive on the fly to support record-mode services for PMAPI client applications.</p>
<p>Each record mode session involves one or more PCP archive logs; each is created using a dedicated <tt>pmlogger</tt> process, with an overall Archive Folio format as understood by the <tt>pmafm</tt> command, to name and collect all of the archive logs associated with a single recording session.</p>
<p>The <tt>pmRecordHost</tt> structure is used to maintain state information between the creator of the recording session and the associated <tt>pmlogger</tt> process(es). The structure, shown in <a href="ch03.html#Z976560662sdc" title="Example 3-13. pmRecordHost Structure">Example 3-13</a>, is defined as:</p>
<div class="example"><a name="Z976560662sdc"></a><p><a name="Z976560662sdc"></a><b>Example 3-13. <tt>pmRecordHost</tt> Structure</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">typedef struct {
  FILE   *f_config;    /* caller writes pmlogger configuration here */
  int    fd_ipc;       /* IPC channel to pmlogger */
  char   *logfile;     /* full pathname for pmlogger error logfile */
  pid_t  pid;          /* process id for pmlogger */
  int    status;       /* exit status, -1 if unknown */
} pmRecordHost;</pre></td></tr></table><br></div><p>In <a href="ch03.html#id5206969" title="Procedure 3-1. Creating a Recording Session">Procedure 3-1</a>, the functions are used in combination to create a recording session.</p>
<div class="procedure"><a name="id5206969"></a><p><a name="id5206969"></a><b>Procedure 3-1. Creating a Recording Session</b></p><div class="orderedlist"><ol type="1"><li><p>Call <tt>pmRecordSetup</tt> to establish a new recording session. A new Archive Folio is created using the name <i>folio</i>. If the <i>folio</i> file or directory already exists, or if it cannot be created, this is an error. The application that is creating the session is identified by creator (most often this would be the same as the global PMAPI application name, <tt>pmProgname</tt>). If the application knows how to create its own configuration file to replay the recorded session, replay should be nonzero. The <tt>pmRecordSetup</tt> function returns a stdio stream onto which the application writes the text of any required replay configuration file.</p>
</li>
<li><p>For each host that is to be included in the recording session, call <tt>pmRecordAddHost</tt>. A new <tt>pmRecordHost</tt> structure is returned via <i>rhp</i>. It is assumed that PMCD is running on the host as this is how <tt>pmlogger</tt> retrieves the required performance metrics. See <a href="ch03.html#LE13213-PARENT" title="3.7.7.1. pmRecordAddHost Function">Section 3.7.7.1</a> for more information.</p>
</li>
<li><p>Optionally, add arguments to the command line that is used to launch <tt>pmlogger</tt> by calling <tt>pmRecordControl</tt> with a request of <tt>PM_REC_SETARG</tt>. The argument is passed via options and one call to <tt>pmRecordControl</tt> is required for each distinct argument. See <a href="ch03.html#LE35969-PARENT" title="3.7.7.2. pmRecordControl Function">Section 3.7.7.2</a> for more information.</p>
</li>
<li><p>To commence the recording session, call <tt>pmRecordControl</tt> with a request of <tt>PM_REC_ON</tt>, and <i>rhp</i> must be NULL.</p>
</li>
<li><p>To terminate a <tt>pmlogger</tt> instance identified by <i>rhp</i>, call <tt>pmRecordControl</tt> with a request of <tt>PM_REC_OFF</tt>.</p>
</li>
<li><p>To display the current status of the <tt>pmlogger</tt> instance identified by, <i>rhp</i>, call <tt>pmRecordControl</tt> with a request of <tt>PM_REC_STATUS</tt>.</p>
</li>
<li><p>To detach a <tt>pmlogger</tt> instance identified by <i>rhp</i>, allow it to continue independent of the application that launched the recording session, call <tt>pmRecordControl</tt> with a request of <tt>PM_REC_DETACH</tt>.</p>
</li>
</ol></div><ol type="1"></ol></div><p>The calling application should not close any of the returned stdio streams; <tt>pmRecordControl</tt> performs this task when recording is commenced.</p>
<p>Once <tt>pmlogger</tt> has been started for a recording session, <tt>pmlogger</tt> assumes responsibility for any dialogue with the user in the event that the application that launched the recording session should exit, particularly without terminating the recording session.</p>
<p>By default, information and dialogues from <tt>pmlogger</tt> is displayed using <tt>xconfirrn</tt>. This default is based on the assumption that most applications launching a recording session are GUI-based. In the event that <tt>xconfirm</tt> fails to display the information (for example, because the <tt>DISPLAY</tt> environment variable is not set), <tt>pmlogger</tt> writes on its own stderr stream (not the stderr stream of the launching process). The output is assigned to the <tt><i>XXXXXX</i>.host.log</tt> file. For convenience, the full pathname to this file is provided via the <tt>logfile</tt> field in the <tt>pmRecordHost</tt> structure.</p>
<p>If the <i>options</i> argument to <tt>pmRecordControl</tt> is not NULL, this string may be used to pass additional arguments to <tt>xconfirm</tt> in those cases where a dialogue is to be displayed. One use of this capability is to provide a -geometry string to control the placement of the dialogue.</p>
<p>Premature termination of a launched <tt>pmlogger</tt> process may be determined using the <tt>pmRecordHost</tt> structure, by calling <tt>select</tt> on the <tt>fd_ipc</tt> field or polling the <tt>status</tt> field that will contain the termination status from <tt>waitpid</tt> if known, or -1.</p>
<p>These functions create a number of files in the same directory as the <i>folio</i> file named in the call to <tt>pmRecordSetup</tt>. In all cases, the <i>XXXXXX</i> component is the result of calling <tt>mktemp</tt>.</p>
<div class="itemizedlist"><ul type="disc"><li><p>If replay is nonzero, <i>XXXXXX</i> is the creator's replay configuration file, else an empty control file, used to guarantee uniqueness.</p>
</li>
<li><p>The <i>folio</i> file is the PCP Archive Folio, suitable for use with the <tt>pmafm</tt> command.</p>
</li>
<li><p>The <tt><i>XXXXXX</i>.host.confi</tt>g file is the <tt>pmlogger</tt> configuration for each host. If the same host is used in different calls to <tt>pmRecordAddHost</tt> within the same recording session, one of the letters 'a' through 'z' is appended to the <i>XXXXXX</i> part of all associated file names to ensure uniqueness.</p>
</li>
<li><p><tt><i>XXXXXX</i>.host.log</tt> is stdout and stderr for the <tt>pmlogger</tt> instance for each host.</p>
</li>
<li><p>The <tt><i>XXXXXX</i>.host.{0,meta,index}</tt> files comprise a single PCP archive for each host.</p>
</li>
</ul></div><p><tt>pmRecordSetup</tt> may return NULL in the event of an error. Check <tt>errno</tt> for the real cause. The value <tt>EINVAL</tt> typically means that the order of calls to these functions is not correct; that is, there is an obvious state associated with the current recording session that is maintained across calls to the functions.</p>
<p>For example, calling <tt>pmRecordControl</tt> before calling <tt>pmRecordAddHost</tt> at least once, or calling <tt>pmRecordAddHost</tt> before calling <tt>pmRecordSetup</tt> would produce an <tt>EINVAL</tt> error.</p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="LE85604-PARENT"></a>3.7.8. PMAPI Archive-Specific Services</h3></div></div>
<p>The functions described in this section provide archive-specific services.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5207510"></a>3.7.8.1. <tt>pmGetArchiveLabel</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int pmGetArchiveLabel(pmLogLabel *<i>lp</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177399"></a><a class="indexterm" name="IG31340177400"></a><a class="indexterm" name="IG31340177401"></a>Provided the current PMAPI context is associated with a PCP archive log, the <tt>pmGetArchiveLabel</tt> function may be used to fetch the label record from the archive. The structure returned through <i>lp</i> is as shown in <a href="ch03.html#Z976561683sdc" title="Example 3-14. pmLogLabel Structure">Example 3-14</a>:</p>
<div class="example"><a name="Z976561683sdc"></a><p><a name="Z976561683sdc"></a><b>Example 3-14. <tt>pmLogLabel</tt> Structure</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">/*
* Label Record at the start of every log file - as exported above the PMAPI ...
*/
#define PM_TZ_MAXLEN                    40
#define PM_LOG_MAXHOSTLEN               64
#define PM_LOG_MAGIC    0x50052600
#define PM_LOG_VERS01   0x1
#define PM_LOG_VERS02   0x2
#define PM_LOG_VOL_TI   -2      /* temporal index */
#define PM_LOG_VOL_META -1      /* meta data */
typedef struct {
    int            ll_magic;          /* PM_LOG_MAGIC | log format version no. */
    pid_t          ll_pid;            /* PID of logger */
    struct timeval ll_start;          /* start of this log */
    char           ll_hostname[PM_LOG_MAXHOSTLEN]; /* name of collection host */
    char           ll_tz[PM_TZ_MAXLEN];            /* $TZ at collection host */
} pmLogLabel;</pre></td></tr></table><br></div><br></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5207673"></a>3.7.8.2. <tt>pmGetArchiveEnd</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int pmGetArchiveEnd(struct timeval *<i>tvp</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177402"></a><a class="indexterm" name="IG31340177403"></a><a class="indexterm" name="IG31340177404"></a>Provided the current PMAPI context is associated with a PCP archive log, <tt>pmGetArchiveEnd</tt> finds the logical end of file (after the last complete record in the archive), and returns the last recorded time stamp with <i>tvp</i>. This times tamp may be passed to <tt>pmSetMode</tt> to reliably position the context at the last valid log record, for example, in preparation for subsequent reading in reverse chronological order.</p>
<p>For archive logs that are not concurrently being written, the physical end of file and the logical end of file are co-incident. However, if an archive log is being written by <tt>pmlogger</tt> at the same time that an application is trying to read the archive, the logical end of file may be before the physical end of file due to write buffering that is not aligned with the logical record boundaries.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5207751"></a>3.7.8.3. <tt>pmGetInDomArchive</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int pmGetInDomArchive(pmInDom <i>indom</i>, int **<i>instlist</i>, char ***<i>namelist</i> )</pre></td></tr></table><p><a class="indexterm" name="IG31340177405"></a><a class="indexterm" name="IG31340177406"></a><a class="indexterm" name="IG31340177407"></a>Provided the current PMAPI context is associated with a PCP archive log, <tt>pmGetInDomArchive</tt> scans the metadata to generate the union of all instances for the instance domain <i>indom</i> that can be found in the archive log, and returns through <i>instlist</i> the internal instance identifiers, and through <i>namelist</i> the full external identifiers.</p>
<p><a class="indexterm" name="IG31340177408"></a>This function is a specialized version of the more general PMAPI function <tt>pmGetInDom</tt>.</p>
<p>The function returns the number of instances found (a value less than zero indicates an error).</p>
<p>The resulting lists of instance identifiers (<i>instlist</i> and <i>namelist</i>), and the names that the elements of <i>namelist</i> point to, are allocated by <tt>pmGetInDomArchive</tt> with two calls to <tt>malloc</tt>, and it is the responsibility of the caller to use <tt>free</tt><i>(instlist)</i> and <tt>free</tt><i>(namelist)</i> to release the space when it is no longer required; see the <tt>malloc(3C)</tt> and <tt>free(3C)</tt> man pages.</p>
<p>When the result of <tt>pmGetInDomArchive</tt> is less than one, both <i>instlist</i> and <i>namelist</i> are undefined (no space is allocated; so calling <tt>free</tt> is a singularly bad idea).</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5207937"></a>3.7.8.4. <tt>pmLookupInDomArchive</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmLookupInDomArchive(pmInDom <i>indom</i>, const char *<i>name</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177409"></a>Provided the current PMAPI context is associated with a PCP archive log, <tt>pmLookupInDomArchive</tt> scans the metadata for the instance domain <i>indom</i>, locates the first instance with the external identification given by <i>name</i>, and returns the internal instance identifier.</p>
<p>This function is a specialized version of the more general PMAPI function <tt>pmLookupInDom</tt>.</p>
<p>The <tt>pmLookupInDomArchive</tt> function returns a positive instance identifier on success.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5208032"></a>3.7.8.5. <tt>pmNameInDomArchive</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmNameInDomArchive(pmInDom <i>indom</i>, int <i>inst</i>, char **<i>name</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177410"></a>Provided the current PMAPI context is associated with a PCP archive log, <tt>pmNameInDomArchive</tt> scans the metadata for the instance domain <i>indom</i>, locates the first instance with the internal instance identifier given by <tt>inst</tt>, and returns the full external instance identification through <i>name</i>. This function is a specialized version of the more general PMAPI function <tt>pmNameInDom</tt>.</p>
<p>The space for the value of <i>name</i> is allocated in <tt>pmNameInDomArchive</tt> with <tt>malloc</tt>, and it is the responsibility of the caller to free the space when it is no longer required; see the <tt>malloc(3C)</tt> and<tt>free(3C)</tt> man pages.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5208144"></a>3.7.8.6. <tt>pmFetchArchive</tt> Function</h4></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmFetchArchive(pmResult **<i>result</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177411"></a><a class="indexterm" name="IG31340177412"></a>This is a variant of <tt>pmFetch</tt> that may be used only when the current PMAPI context is associated with a PCP archive log. The <i>result</i> is instantiated with all of the metrics (and instances) from the next archive record; consequently, there is no notion of a list of desired metrics, and the instance profile is ignored.</p>
<p>It is expected that <tt>pmFetchArchive</tt> would be used to create utilities that scan archive logs (for example, <tt>pmdumplog</tt>), and the more common access to the archives would be through the <tt>pmFetch</tt> interface.</p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="LE73955-PARENT"></a>3.7.9. PMAPI Time Control Services</h3></div></div>
<p><a class="indexterm" name="IG31340177413"></a><a class="indexterm" name="IG31340177414"></a>The PMAPI provides a common framework for client applications to control time and to synchronize time with other applications. The user interface component of this service is fully described in the companion <i>Performance Co-Pilot User's and Administrator's Guide</i>. See also the <tt>pmtime(1)</tt> man page.</p>
<p><a class="indexterm" name="IG31340177415"></a>This service is most useful when processing PCP archive logs, to control parameters such as the current archive position, update interval, replay rate, and timezone, but it can also be used in live mode to control a subset of these parameters. Applications such as <tt>pmchart</tt>, <tt>pmview</tt>, <tt>oview</tt>, and <tt>pmval</tt> use the time control services to connect to an instance of the time control server process, <tt>pmtime</tt>, which provides a uniform graphical user interface to the time control services.</p>
<p><a class="indexterm" name="IG31340177416"></a>A full description of the PMAPI time control functions along with code examples can be found in man pages as listed in <a href="ch03.html#id5208351" title="Table 3-2. Time Control Functions in PMAPI">Table 3-2</a>:</p>
<div class="table"><a name="id5208351"></a><p><a name="id5208351"></a><b>Table 3-2. Time Control Functions in PMAPI</b></p>
<table summary="Time Control Functions in PMAPI" border="1"><colgroup><col><col></colgroup><thead><tr valign="top"><th scope="col" align="left" valign="bottom"><p>Man Page</p>
</th><th scope="col" align="left" valign="bottom"><p>Synopsis of Time Control Function</p>
</th></tr></thead><tbody><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmCtime(3)</tt></p>
</td><td align="left" valign="top"><p>Formats the date and time for a reporting timezone.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmLocaltime(3)</tt></p>
</td><td align="left" valign="top"><p>Converts the date and time for a reporting timezone.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmParseTimeWindow(3)</tt></p>
</td><td align="left" valign="top"><p>Parses time window command line arguments.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmTimeConnect(3)</tt></p>
</td><td align="left" valign="top"><p>Connects to a time control server via a command socket.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmTimeDisconnect(3)</tt></p>
</td><td align="left" valign="top"><p>Closes the command socket to the time control server.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmTimeGetPort(3)</tt></p>
</td><td align="left" valign="top"><p>Obtains the port name of the current time control server.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmTimeRecv(3)</tt></p>
</td><td align="left" valign="top"><p>Blocks until the time control server sends a command message.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmTimeSendAck(3)</tt></p>
</td><td align="left" valign="top"><p>Acknowledges completion of the step command.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmTimeSendBounds(3)</tt></p>
</td><td align="left" valign="top"><p>Specifies beginning and end of archive time period.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmTimeSendMode(3)</tt></p>
</td><td align="left" valign="top"><p>Requests time control server to change to a new VCR mode.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmTimeSendPosition(3)</tt></p>
</td><td align="left" valign="top"><p>Requests time control server to change position or update intervals.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmTimeSendTimezone(3)</tt></p>
</td><td align="left" valign="top"><p>Requests time control server to change timezones.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmTimeShowDialog(3)</tt></p>
</td><td align="left" valign="top"><p>Changes the visibility of the time control dialogue.</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>pmTimeGetStatePixmap(3)</tt></p>
</td><td align="left" valign="top"><p>Returns array of pixmaps representing supplied time control state.</p>
</td></tr></tbody></table></div><br></div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="LE44064-PARENT"></a>3.8. PMAPI Ancillary Support Services</h2></div></div>
<p><a class="indexterm" name="IG31340177417"></a><a class="indexterm" name="IG31340177418"></a>The functions described in this section provide services that are complementary to, but not necessarily a part of, the distributed manipulation of performance metrics delivered by the PCP components.</p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5208965"></a>3.8.1. <tt>pmGetConfig</tt> Function</h3></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">char *pmGetConfig(const char <i>*variable</i>)</pre></td></tr></table><p>The <tt>pmGetConfig</tt> function searches for a variable first in the environment and then, if one is not found, in the PCP configuration file and returns the string result. If a variable is not already in the environment, it is added with a call to the <tt>putenv</tt> function before returning.</p>
<p>The default location of the PCP configuration file is <tt>/etc/pcp.conf</tt>, but this location may be changed by setting <tt>PCP_CONF</tt> in the environment to a new location, as described in the <tt>pcp_conf(4)</tt> man page.</p>
<p>If the variable is not found in either the environment or the PCP configuration file (or the PCP configuration file is not found and <tt>PCP_CONF</tt> is not set in the environment), then a fatal error message is printed and the process will exit. Although this sounds drastic, it is the only course of action available because the PCP configuration or installation is fatally flawed.</p>
<p>If this function returns, the returned value points to a string in the environment; and so although the function returns the same type as the <tt>getenv</tt> function (which should probably be a <tt>const char *</tt>), changing the content of the string is not recommended.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5209050"></a>3.8.2. <tt>pmErrStr</tt> Function</h3></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">char *pmErrStr(int <i>code</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177419"></a>This function translates an error code into a text string, suitable for generating a diagnostic message. By convention within PCP, all error codes are negative. The small values are assumed to be negated versions of the UNIX error codes as defined in <tt>errno.h</tt>, and the strings returned are according to <tt>strerror</tt>. The large, negative error codes are PMAPI error conditions, and <tt>pmErrStr</tt> returns an appropriate PMAPI error string, as determined by <i>code</i>.</p>
<p>The string value is held in a single static buffer; so the returned value is valid only until the next call to <tt>pmErrStr</tt>.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5209112"></a>3.8.3. <tt>pmExtractValue</tt> Function</h3></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmExtractValue(int <i>valfmt</i>, const pmValue *<i>ival</i>, int <i>itype</i>,
pmAtomValue *<i>oval</i>, int <i>otype</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177420"></a>The <tt>pmValue</tt> structure is embedded within the <tt>pmResult</tt> structure, which is used to return one or more performance metrics; see the <tt>pmFetch</tt> man page.</p>
<p>All performance metric values may be encoded in a <tt>pmAtomValue</tt> union, defined in <a href="ch03.html#Z976562908sdc" title="Example 3-15. pmAtomValue Structure">Example 3-15</a>:</p>
<div class="example"><a name="Z976562908sdc"></a><p><a name="Z976562908sdc"></a><b>Example 3-15. <tt>pmAtomValue</tt> Structure</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">/* Generic Union for Value-Type conversions */
typedef union {
    _int32_t   l;     /* 32-bit signed */
    _uint32_t  ul;    /* 32-bit unsigned */
    _int64_t   ll;    /* 64-bit signed */
    _uint64_t  ull;   /* 64-bit unsigned */
    float      f;     /* 32-bit floating point */
    double     d;     /* 64-bit floating point */
    char       *cp;   /* char ptr */
    void       *vp;   /* void ptr */
} pmAtomValue;</pre></td></tr></table><br></div><p>The <tt>pmExtractValue</tt> function provides a convenient mechanism for extracting values from the <tt>pmValue</tt> part of a <tt>pmResult</tt> structure, optionally converting the data type, and making the result available to the application programmer.</p>
<p><a class="indexterm" name="IG31340177421"></a>The <i>itype</i> argument defines the data type of the input value held in <i>ival</i> according to the storage format defined by <i>valfmt</i> (see the <tt>pmFetch</tt> man page). The <i>otype</i> argument defines the data type of the result to be placed in <i>oval</i>. The value for <i>itype</i> is typically extracted from a <tt>pmDesc</tt> structure, following a call to  <tt>pmLookupDesc</tt> for a particular performance metric.</p>
<p><a href="ch03.html#id5209524" title="Table 3-3. PMAPI Type Conversion">Table 3-3</a> defines the various possibilities for the type conversion. The input type (<i>itype</i>) is shown vertically, and the output type (<i>otype</i>) horizontally. The following rules apply:</p>
<div class="itemizedlist"><ul type="disc"><li><p>Y means the conversion is always acceptable.</p>
</li>
<li><p><a class="indexterm" name="IG31340177422"></a>N means conversion can never be performed (function returns <tt>PM_ERR_CONV</tt>).</p>
</li>
<li><p>P means the conversion may lose accuracy (but no error status is returned).</p>
</li>
<li><p><a class="indexterm" name="IG31340177423"></a>T means the result may be subject to high-order truncation (if this occurs the function returns <tt>PM_ERR_TRUNC</tt>).</p>
</li>
<li><p><a class="indexterm" name="IG31340177424"></a>S means the conversion may be impossible due to the sign of the input value (if this occurs the function returns <tt>PM_ERR_SIGN</tt>).</p>
</li>
</ul></div><p><a class="indexterm" name="IG31340177425"></a>If an error occurs, <i>oval</i> is set to zero (or NULL).</p>
<p><div class="note"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/note.png" height="24" width="24"></td><td align="left" valign="top"><b>Note: </b> Note that some of the conversions involving the <tt>PM_TYPE_STRING</tt> and <tt>PM_TYPE_AGGREGATE</tt> types are indeed possible, but are marked N; the rationale is that <tt>pmExtractValue</tt> should not attempt to duplicate functionality already available in the C library through <tt>sscanf</tt> and <tt>sprintf</tt>.
</td></tr></table><hr noshade="noshade"></div><br></p>
<div class="table"><a name="id5209524"></a><p><a name="id5209524"></a><b>Table 3-3. PMAPI Type Conversion</b></p>
<table summary="PMAPI Type Conversion" border="1"><colgroup><col><col><col><col><col><col><col><col><col></colgroup><thead><tr valign="top"><th scope="col" align="left" valign="bottom"><p>TYPE</p>
</th><th scope="col" align="left" valign="bottom"><p>32</p>
</th><th scope="col" align="left" valign="bottom"><p>U32</p>
</th><th scope="col" align="left" valign="bottom"><p>64</p>
</th><th scope="col" align="left" valign="bottom"><p>U64</p>
</th><th scope="col" align="left" valign="bottom"><p>FLOAT</p>
</th><th scope="col" align="left" valign="bottom"><p>DBLE</p>
</th><th scope="col" align="left" valign="bottom"><p>STRIN G</p>
</th><th scope="col" align="left" valign="bottom"><p>AGGR</p>
</th></tr></thead><tbody><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>32</tt></p>
</td><td align="left" valign="top"><p>Y</p>
</td><td align="left" valign="top"><p>S</p>
</td><td align="left" valign="top"><p>Y</p>
</td><td align="left" valign="top"><p>S</p>
</td><td align="left" valign="top"><p>P</p>
</td><td align="left" valign="top"><p>P</p>
</td><td align="left" valign="top"><p>N</p>
</td><td align="left" valign="top"><p>N</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>U32</tt></p>
</td><td align="left" valign="top"><p>T</p>
</td><td align="left" valign="top"><p>Y</p>
</td><td align="left" valign="top"><p>Y</p>
</td><td align="left" valign="top"><p>Y</p>
</td><td align="left" valign="top"><p>P</p>
</td><td align="left" valign="top"><p>P</p>
</td><td align="left" valign="top"><p>N</p>
</td><td align="left" valign="top"><p>N</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>64</tt></p>
</td><td align="left" valign="top"><p>T</p>
</td><td align="left" valign="top"><p>T,S</p>
</td><td align="left" valign="top"><p>Y</p>
</td><td align="left" valign="top"><p>S</p>
</td><td align="left" valign="top"><p>P</p>
</td><td align="left" valign="top"><p>P</p>
</td><td align="left" valign="top"><p>N</p>
</td><td align="left" valign="top"><p>N</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>u64</tt></p>
</td><td align="left" valign="top"><p>T</p>
</td><td align="left" valign="top"><p>T</p>
</td><td align="left" valign="top"><p>T</p>
</td><td align="left" valign="top"><p>Y</p>
</td><td align="left" valign="top"><p>P</p>
</td><td align="left" valign="top"><p>P</p>
</td><td align="left" valign="top"><p>N</p>
</td><td align="left" valign="top"><p>N</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>FLOAT</tt></p>
</td><td align="left" valign="top"><p>P, T</p>
</td><td align="left" valign="top"><p>P, T, S</p>
</td><td align="left" valign="top"><p>P, T</p>
</td><td align="left" valign="top"><p>P, T, S</p>
</td><td align="left" valign="top"><p>Y</p>
</td><td align="left" valign="top"><p>Y</p>
</td><td align="left" valign="top"><p>N</p>
</td><td align="left" valign="top"><p>N</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>DBLE</tt></p>
</td><td align="left" valign="top"><p>P, T</p>
</td><td align="left" valign="top"><p>P, T, S</p>
</td><td align="left" valign="top"><p>P, T</p>
</td><td align="left" valign="top"><p>P, T, S</p>
</td><td align="left" valign="top"><p>P</p>
</td><td align="left" valign="top"><p>Y</p>
</td><td align="left" valign="top"><p>N</p>
</td><td align="left" valign="top"><p>N</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>STRING</tt></p>
</td><td align="left" valign="top"><p>N</p>
</td><td align="left" valign="top"><p>N</p>
</td><td align="left" valign="top"><p>N</p>
</td><td align="left" valign="top"><p>N</p>
</td><td align="left" valign="top"><p>N</p>
</td><td align="left" valign="top"><p>N</p>
</td><td align="left" valign="top"><p>Y</p>
</td><td align="left" valign="top"><p>N</p>
</td></tr><tr valign="top"><td scope="row" align="left" valign="top"><p><tt>AGGR</tt></p>
</td><td align="left" valign="top"><p>N</p>
</td><td align="left" valign="top"><p>N</p>
</td><td align="left" valign="top"><p>N</p>
</td><td align="left" valign="top"><p>N</p>
</td><td align="left" valign="top"><p>N</p>
</td><td align="left" valign="top"><p>N</p>
</td><td align="left" valign="top"><p>N</p>
</td><td align="left" valign="top"><p>Y</p>
</td></tr></tbody></table></div><p>In the cases where multiple conversion errors could occur, the first encountered error is returned, and the order of checking is not defined.</p>
<p>If the output conversion is to one of the pointer types, such as <i>otype</i> <tt>PM_TYPE_STRING</tt> or <tt>PM_TYPE_AGGREGATE</tt>, then the value buffer is allocated by <tt>pmExtractValue</tt> using <tt>malloc</tt>, and it is the caller's responsibility to free the space when it is no longer required; see the <tt>malloc(3C)</tt> and <tt>free(3C)</tt> man pages.</p>
<p>Although this function appears rather complex, it has been constructed to assist the development of performance tools that convert values, whose type is known only through the <tt>type</tt> field in a <tt>pmDesc</tt> structure, into a canonical type for local processing.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5210752"></a>3.8.4. <tt>pmConvScale</tt> Function</h3></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int
pmConvScale(int <i>type</i>, const pmAtomValue *<i>ival</i>, const pmUnits *<i>iunit</i>,
pmAtomValue *<i>oval</i>, pmUnits *<i>ounit</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177426"></a>Given a performance metric value pointed to by <i>ival</i>, multiply it by a scale factor and return the value in <i>oval</i>. The scaling takes place from the units defined by <i>iunit</i> into the units defined by <i>ounit</i>. Both input and output units must have the same dimensionality.</p>
<p><a class="indexterm" name="IG31340177427"></a>The performance metric type for both input and output values is determined by <i>type</i>, the value for which is typically extracted from a <tt>pmDesc</tt> structure, following a call to <tt>pmLookupDesc</tt> for a particular performance metric.</p>
<p><a class="indexterm" name="IG31340177428"></a><tt>pmConvScale</tt> is most useful when values returned through <tt>pmFetch</tt> (and possibly extracted using <tt>pmExtractValue</tt>) need to be normalized into some canonical scale and units for the purposes of computation.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5210895"></a>3.8.5. <tt>pmUnitsStr</tt> Function</h3></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">const char *pmUnitsStr(const pmUnits *<i>pu</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177429"></a>As an aid to labeling graphs and tables, or for error messages, <tt>pmUnitsStr</tt> takes a dimension and scale specification as per <i>pu</i>, and returns the corresponding text string.</p>
<p><i>pu</i> is typically from a <tt>pmDesc</tt> structure, for example, as returned by <tt>pmLookupDesc</tt>.</p>
<p>If <i>*pu</i> were <tt>{1, -2, 0, PM_SPACE_MBYTE, PM_TIME_MSEC, 0}</tt>, then the result string would be <tt>Mbyte/sec^2</tt>.</p>
<p>The string value is held in a single static buffer; so concurrent calls to <tt>pmUnitsStr</tt> may not produce the desired results.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5210994"></a>3.8.6. <tt>pmIDStr</tt> Function</h3></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">const char *pmIDStr(pmID <i>pmid</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177430"></a>For use in error and diagnostic messages, return a human readable version of the specified PMID, with each of the internal <tt>domain</tt>, <tt>cluster</tt>, and <tt>item</tt> subfields appearing as decimal numbers, separated by periods.</p>
<p>The string value is held in a single static buffer; so concurrent calls to <tt>pmIDStr</tt> may not produce the desired results.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5211046"></a>3.8.7. <tt>pmInDomStr</tt> Function</h3></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">const char *pmInDomStr(pmInDom <i>indom</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177431"></a>For use in error and diagnostic messages, return a human readable version of the specified instance domain identifier, with each of the internal <tt>domain</tt> and <tt>serial</tt> subfields appearing as decimal numbers, separated by periods.</p>
<p>The string value is held in a single static buffer; so concurrent calls to <tt>pmInDomStr</tt> may not produce the desired results.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5211095"></a>3.8.8. <tt>pmTypeStr</tt> Function</h3></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">const char *pmTypeStr(int <i>type</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177432"></a>Given a performance metric type, produce a terse ASCII equivalent, appropriate for use in error and diagnostic messages.</p>
<p>Examples are &#8220;32&#8221; (for <tt>PM_TYPE_32</tt>), &#8220;U64&#8221; (for <tt>PM_TYPE_U64</tt>), &#8220;AGGREGATE&#8221; (for <tt>PM_TYPE_AGGREGATE</tt>), and so on.</p>
<p>The string value is held in a single static buffer; so concurrent calls to <tt>pmTypeStr</tt> may not produce the desired results.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5211169"></a>3.8.9. <tt>pmAtomStr</tt> Function</h3></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">const char *pmAtomStr(const pmAtomValue *<i>avp</i>, int <i>type</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177433"></a>Given the <tt>pmAtomValue</tt> identified by <i>avp</i>, and a performance metric <i>type</i>, generate the corresponding metric value as a string, suitable for diagnostic or report output.</p>
<p>The string value is held in a single static buffer; so concurrent calls to <tt>pmAtomStr</tt> may not produce the desired results.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5211303"></a>3.8.10. <tt>pmNumberStr</tt> Function</h3></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">const char *pmNumberStr(double <i>value</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177434"></a>The <tt>pmNumberStr</tt> function returns the address of a static 8-byte buffer that holds a null-byte terminated representation of value suitable for output with fixed-width fields.</p>
<p>The value is scaled using multipliers in powers of one thousand (the decimal kilo) and has a bias that provides greater precision for positive numbers as opposed to negative numbers. The format depends on the sign and magnitude of <i>value</i>.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5211350"></a>3.8.11. <tt>pmPrintValue</tt> Function</h3></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">void pmPrintValue(FILE *<i>f</i>, int <i>valfmt</i>, int <i>type</i>, const pmValue *<i>val</i>,
int <i>minwidth</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177435"></a><a class="indexterm" name="IG31340177436"></a>The value of a single performance metric (as identified by <i>val</i>) is printed on the standard I/O stream identified by <i>f</i>. The value of the performance metric is interpreted according to the format of <i>val</i> as defined by <i>valfmt</i> (from a <tt>pmValueSet</tt> within a <tt>pmResult</tt>) and the generic description of the metric's type from a <tt>pmDesc</tt> structure, passed in through.</p>
<p>If the converted value is less than <i>minwidth</i> characters wide, it will have leading spaces to pad the output to a width of <i>minwidth</i> characters.</p>
<p><a href="ch03.html#Z976565414sdc" title="Example 3-16. Using pmPrintValue to Print Values">Example 3-16</a> illustrates using <tt>pmPrintValue</tt> to print the values from a <tt>pmResult</tt> structure returned via <tt>pmFetch</tt>:</p>
<div class="example"><a name="Z976565414sdc"></a><p><a name="Z976565414sdc"></a><b>Example 3-16. Using <tt>pmPrintValue</tt> to Print Values</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">int         numpmid, i, j, sts;
pmID        pmidlist[10];
pmDesc      desc[10];
pmResult    *result;
/* set up PMAPI context, numpmid and pmidlist[] ... */
/* get metric descriptors */
for (i = 0; i &lt; numpmid; i++) {
    if ((sts = pmLookupDesc(pmidlist[i], &amp;desc[i])) &lt; 0) {
        printf(&quot;pmLookupDesc(pmid=%s): %s\n&quot;,
                      pmIDStr(pmidlist[i]), pmErrStr(sts));
        exit(1);
    }
}
if ((sts = pmFetch(numpmid, pmidlist, &amp;result)) &gt;= 0) {
    /* once per metric */
    for (i = 0; i &lt; result-&gt;numpmid; i++) {
        printf(&quot;PMID: %s&quot;, pmIDStr(result-&gt;vset[i]-&gt;pmid));
        /* once per instance for this metric */
        for (j = 0; j &lt; result-&gt;vset[i]-&gt;numval; j++) {
            printf(&quot; [%d]&quot;, result-&gt;vset[i]-&gt;vlist[j].inst);
            pmPrintValue(stdout, result-&gt;vset[i]-&gt;valfmt,
                                desc[i].type,
                                &amp;result-&gt;vset[i]-&gt;vlist[j],
                                8);
        }
        putchar('\n');
    }
    pmFreeResult(result);
}
else
   printf(&quot;pmFetch: %s\n&quot;, pmErrStr(sts));</pre></td></tr></table><br></div><br></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5211504"></a>3.8.12. <tt>pmflush</tt> Function</h3></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmflush(void);</pre></td></tr></table><p><a class="indexterm" name="IG31340177437"></a>The <tt>pmflush</tt> function causes the internal buffer which is shared with <tt>pmprintf</tt> to be either displayed in a window, printed on standard error, or flushed to a file and the internal buffer to be cleared.</p>
<p>The <tt>PCP_STDERR</tt> environment variable controls the output technique used by <tt>pmflush</tt>:</p>
<div class="itemizedlist"><ul type="disc"><li><p>If <tt>PCP_STDERR</tt> is unset, the text is written onto the stderr stream of the caller.</p>
</li>
<li><p>If <tt>PCP_STDERR</tt> is set to the literal reserved word <tt>DISPLAY</tt>, then the text is displayed as a GUI dialogue using <tt>xconfirm</tt>.</p>
</li>
</ul></div><p>The <tt>pmflush</tt> function returns a value of zero on successful completion. A negative value is returned if an error was encountered, and this can be passed to <tt>pmErrStr</tt> to obtain the associated error message.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5211641"></a>3.8.13. <tt>pmprintf</tt> Function</h3></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmprintf(const char *<i>fmt</i>, ... /*<i>args</i>*/);</pre></td></tr></table><p><a class="indexterm" name="IG31340177438"></a>The <tt>pmprintf</tt> function appends the formatted message string to an internal buffer shared by the <tt>pmprintf</tt> and <tt>pmflush </tt> functions, without actually producing any output. The <i>fmt</i> argument is used to control the conversion, formatting, and printing of the variable length <i>args</i> list.</p>
<p>The <tt>pmprintf</tt> function uses the <tt>tempnam</tt> function to create a temporary file, using the value of the global variable <i>pmProgname</i> as a prefix. This temporary file is deleted when <tt>pmflush</tt> is called.</p>
<p>On successful completion, <tt>pmprintf</tt> returns the number of characters transmitted. A negative value is returned if an error was encountered, and this can be passed to <tt>pmErrStr</tt> to obtain the associated error message.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5211762"></a>3.8.14. <tt>pmSortInstances</tt> Function</h3></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">void pmSortInstances(pmResult *<i>result</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177439"></a><a class="indexterm" name="IG31340177440"></a>The <tt>pmSortInstances</tt>  function may be used to guarantee that for each performance metric in the result from <tt>pmFetch</tt>, the instances are in ascending internal instance identifier sequence. This is useful when trying to compute rates from two consecutive <tt>pmFetch</tt> results, where the underlying instance domain or metric availability is not static.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5211834"></a>3.8.15. <tt>pmParseInterval</tt> Function</h3></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmParseInterval(const char *<i>string</i>, struct timeval *<i>rslt</i>,
char **<i>errmsg</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177441"></a>The <tt>pmParseInterval</tt> function parses the argument string specifying an interval of time and fills in the <tt>tv_sec</tt> and <tt>tv_usec</tt> components of the <tt>rslt</tt> structure to represent that interval. The input string is most commonly the argument following a <tt>-t</tt> command line option to a PCP application, and the syntax is fully described in the <tt>PCPIntro(1)</tt> man page.</p>
<p><tt>pmParseInterval</tt> returns 0 and <i>errmsg</i> is undefined if the parsing is successful. If the given string does not conform to the required syntax, the function returns -1 and a dynamically allocated error message string in <i>errmsg</i>.</p>
<p>The error message is terminated with a newline and includes the text of the input string along with an indicator of the position at which the error was detected as shown in the following example:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">              4minutes 30mumble
                         ^ -- unexpected value</pre></td></tr></table><p>In the case of an error, the caller is responsible for calling <tt>free </tt> to release the space allocated for <i>errmsg</i>.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5211943"></a>3.8.16. <tt>pmParseMetricSpec</tt> Function</h3></div></div>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">int pmParseMetricSpec(const char *<i>string</i>, int <i>isarch</i>, char *<i>source</i>, 
pmMetricSpec **<i>rsltp</i>, char **<i>errmsg</i>)</pre></td></tr></table><p><a class="indexterm" name="IG31340177442"></a>The <tt>pmParseMetricSpec</tt> function accepts a <i>string</i> specifying the name of a PCP performance metric, and optionally the source (either a hostname or a PCP archive log filename) and instances for that metric. The syntax is described in the <tt>PCPIntro(1)</tt> man page.</p>
<p>If neither host nor archive component of the metric specification is provided, the <tt>isarch</tt> and <tt>source</tt> arguments are used to fill in the returned <tt>pmMetricSpec</tt> structure. In <a href="ch03.html#Z976566126sdc" title="Example 3-17. pmMetricSpec Structure">Example 3-17</a>, the <tt>pmMetricSpec</tt> structure, which is returned via <i>rsltp,</i> represents the parsed string.</p>
<div class="example"><a name="Z976566126sdc"></a><p><a name="Z976566126sdc"></a><b>Example 3-17. <tt>pmMetricSpec</tt> Structure</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">typedef struct {
    int     isarch;      /* source type: 0 -&gt; host, 1 -&gt; archive */
    char    *source;     /* name of source host or archive */
    char    *metric;     /* name of metric */
    int     ninst;       /* number of instances, 0 -&gt; all */
    char    *inst[1];    /* array of instance  names */
} pmMetricSpec;</pre></td></tr></table><br></div><p>The <tt>pmParseMetricSpec</tt> function returns 0 if the given string was successfully parsed. In this case, all the storage allocated by <tt>pmParseMetricSpec</tt> can be released by a single call to the <tt>free</tt> function by using the address returned from <tt>pmMetricSpec</tt> via <i>rsltp</i>. The convenience macro <tt>pmFreeMetricSpec</tt> is a thinly disguised wrapper for <tt>free</tt>.</p>
<p>The <tt>pmParseMetricSpec</tt> function returns 0 if the given string was successfully parsed. It returns <tt>PM_ERR_GENERIC</tt> and a dynamically allocated error message string in <i>errmsg</i> if the given string does not parse.  In this situation, the error message string can be released with the <tt>free</tt> function.</p>
<p>In the case of an error, <i>rsltp</i> is undefined. In the case of success, <i>errmsg</i> is undefined. If <i>rsltp</i>-&gt;<i>ninst</i> is 0, then <i>rsltp</i>-&gt;<i>inst</i>[0] is undefined.</p>
</div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5212196"></a>3.9. PMAPI Programming Issues and Examples</h2></div></div>
<p><a class="indexterm" name="IG31340177443"></a><a class="indexterm" name="IG31340177444"></a><a class="indexterm" name="IG31340177445"></a>The following issues and examples are provided to enable you to create better custom performance monitoring tools.</p>
<p>The source code for a sample client (<tt>pmclient</tt>) using the PMAPI is shipped as part of the <tt>pcp.sw.demo</tt> subsystem of the PCP product. See the <tt>pmclient(1)</tt> man page, and the source code, located in <tt>/var/pcp/demos/pmclient</tt>.</p>
<p>On Linux, the <tt>pmclient</tt> demo appears in the <tt>pcp-2.3-<i>rev</i></tt> package at <tt>/var/share/pcp/demos/pmclient</tt>.</p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5212297"></a>3.9.1. Symbolic Association between a Metric's Name and Value</h3></div></div>
<p><a class="indexterm" name="IG31340177446"></a><a class="indexterm" name="IG31340177447"></a>A common problem in building specific performance tools is how to maintain the association between a performance metric's name, its access (instantiation) method, and the application program variable that contains the metric's value. Generally this results in code that is easily broken by bug fixes or changes in the underlying data structures. The PMAPI provides a uniform method for instantiating and accessing the values independent of the underlying implementation, although it does not solve the name-variable association problem. However, it does provide a framework within which a manageable solution may be developed.</p>
<p>Fundamentally, the goal is to be able to name a metric and reference the metric's value in a manner that is independent of the order of operations on other metrics; for example, to associate the <tt>BINGO</tt> macro with the name <tt>sys.statistic.bingo</tt>, and then be able to use <tt>BINGO</tt> to get at the value of the corresponding metric.</p>
<p><a class="indexterm" name="IG31340177448"></a><a class="indexterm" name="IG31340177449"></a>The one-to-one association between the ordinal position of the metric names is input to <tt>pmLookupName</tt> and the PMIDs returned by this function, and the one-to-one association between the PMIDs input to <tt>pmFetch</tt> and the values returned by this function provide the basis for an automated solution.</p>
<p>The tool <tt>pmgenmap</tt> takes the specification of a list of metric names and symbolic tags, in the order they should be passed to <tt>pmLookupName</tt> and <tt>pmFetch</tt>. For example:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting"># one line comment
mystuff {
    sys.statistic.bingo  BINGO
    sys.statistic.cache.miss  MISSED
}</pre></td></tr></table><p>This <tt>pmgenmap</tt> input produces the  C code, in <a href="ch03.html#Z976566536sdc" title="Example 3-18. C Code Produced by pmgenmap Input">Example 3-18</a>. It is suitable for including with the <tt>#include</tt> statement:</p>
<div class="example"><a name="Z976566536sdc"></a><p><a name="Z976566536sdc"></a><b>Example 3-18. C Code Produced by <tt>pmgenmap</tt> Input</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">/*
 * Performance Metrics Name Space Map
 * Built by pmgenmap from the file
 * /usr/people/kenmcd/swa/ptg/src/kstat.pcp/x
 * on Thu Feb 24 20:37:53 EST 1994
 *
 * Do not edit this file!
 */
/* one line comment */
char *mystuff[] = {
#define BINGO 0
    &quot;sys.statistic.bingo&quot;,
#define MISSED 1
   &quot;sys.statistic.cache.miss&quot;,
};</pre></td></tr></table><br></div><br></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5212519"></a>3.9.2. Initializing New Metrics</h3></div></div>
<p><a class="indexterm" name="IG31340177450"></a><a class="indexterm" name="IG31340177451"></a><a class="indexterm" name="IG31340177452"></a>Using the code generated by <tt>pmgenmap</tt>, you are now able to easily initialize the application's metric specifications as shown in <a href="ch03.html#Z976566793sdc" title="Example 3-19. Initializing Metric Specifications">Example 3-19</a>:</p>
<div class="example"><a name="Z976566793sdc"></a><p><a name="Z976566793sdc"></a><b>Example 3-19. Initializing Metric Specifications</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">#define MAX_MID 3
int       trip = 0;
int       numpmid = sizeof(mystuff)/sizeof(mystuff[0]);
double    duration;
pmResult  *resp;
pmResult  *prev;
pmID      pmidlist[MAX_MID];
pmLookupName(numpmid, mystuff, pmidlist);</pre></td></tr></table><br></div><p>At this stage, <tt>pmidlist</tt> contains the PMID for the two metrics of interest.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5212595"></a>3.9.3. Iterative Processing of Values</h3></div></div>
<p><a class="indexterm" name="IG31340177453"></a><a class="indexterm" name="IG31340177454"></a>Assuming the tool is required to report values every five seconds, use code similar to that in <a href="ch03.html#Z976567058sdc" title="Example 3-20. Iterative Processing">Example 3-20</a>:</p>
<div class="example"><a name="Z976567058sdc"></a><p><a name="Z976567058sdc"></a><b>Example 3-20. Iterative Processing</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">while (1) {
   pmFetch(numpmid, pmidlist, &amp;resp);
   if (trip) {
        /* see pmclient.c for tv_sub() declaration */
        duration = tv_sub(&amp;resp-&gt;timestamp, &amp;prev-&gt;timestamp);
        /*
         * sys.boring.bozo is an instantaneous value,
         * so report the most recent value
         * sys.statistic.cache.miss is a free running counter,
         * so report the rate over the last two samples
         */
        printf(&quot;%6d %5.2f\n&quot;, resp-&gt;vset[BOZO]-&gt;vlist[0].value.lval,
            (resp-&gt;vset[MISSED]-&gt;vlist[0].value.lval - 
             prev-&gt;vset[MISSED]-&gt;vlist[0].value.lval) / duration);
   }
   if (trip &gt;= 1)
       pmFreeResult(prev);
   else
       trip++;
   prev = resp;
   sleep(5);
}</pre></td></tr></table><br></div><br></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5212682"></a>3.9.4. Accommodating Program Evolution</h3></div></div>
<p><a class="indexterm" name="IG31340177455"></a><a class="indexterm" name="IG31340177456"></a>The flexibility provided by the PMAPI and the <tt>pmgenmap</tt> utility is demonstrated by <a href="ch03.html#Z976567218sdc" title="Example 3-21. Adding a Metric">Example 3-21</a>. Consider the requirement for reporting a third metric <tt>sys.boring.new</tt> (an instantaneous value) in the middle of the two already reported.  This example shows how to add the line to the middle of the specification file:</p>
<div class="example"><a name="Z976567218sdc"></a><p><a name="Z976567218sdc"></a><b>Example 3-21. Adding a Metric</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">sys.boring.new NEW </pre></td></tr></table><p>Then regenerate the <tt>#include</tt> file, and amend the <tt>printf</tt> statement as shown in </p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">printf(&quot;%6d %6d %5.2f\n&quot;,
    resp-&gt;vlist[BOZO]-&gt;vlist[0].value.lval,
    resp-&gt;vlist[NEW]-&gt;vlist[0].value.lval,
    (resp-&gt;vlist[MISSED]-&gt;vlist[0].value.lval -
        prev-&gt;vlist[MISSED]-&gt;vlist[0].value.lval) / duration);</pre></td></tr></table><br></div><br></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5212805"></a>3.9.5. Handling PMAPI Errors</h3></div></div>
<p><a class="indexterm" name="IG31340177457"></a><a class="indexterm" name="IG31340177458"></a>In <a href="ch03.html#id5212839" title="Example 3-22. PMAPI Error Handling">Example 3-22</a>, the simple but complete PMAPI application demonstrates the recommended style for handling PMAPI error conditions.</p>
<div class="example"><a name="id5212839"></a><p><a name="id5212839"></a><b>Example 3-22. PMAPI Error Handling</b></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">#include &lt;stdio.h&gt;
#include &lt;pcp/pmapi.h&gt;
int
main(int argc, char* argv[])
{
   int                 sts = 0;
   char                *host = &quot;localhost&quot;;
   char                *metric = &quot;mem.freemem&quot;;
   pmID                pmid;
   pmDesc              desc;
   pmResult            *result;

   sts = pmNewContext(PM_CONTEXT_HOST, host);
   if (sts &lt; 0) {
       fprintf(stderr, &quot;Error connecting to pmcd on %s: %s\n&quot;,
               host, pmErrStr(sts));
       exit(1);
   }
   sts = pmLookupName(1, &amp;metric, &amp;pmid);
   if (sts &lt; 0) {
       fprintf(stderr, &quot;Error looking up %s: %s\n&quot;, metric,
               pmErrStr(sts));
       exit(1);
   }
   sts = pmLookupDesc(pmid, &amp;desc);
   if (sts &lt; 0) {
       fprintf(stderr, &quot;Error getting descriptor for %s:%s: %s\n&quot;,
               host, metric, pmErrStr(sts));
       exit(1);
   }
   sts = pmFetch(1, &amp;pmid, &amp;result);
   if (sts &lt; 0) {
       fprintf(stderr, &quot;Error fetching %s:%s: %s\n&quot;, host, metric,
               pmErrStr(sts));
       exit(1);
   }
   sts = result-&gt;vset[0]-&gt;numval;
   if (sts &lt; 0) {
       fprintf(stderr, &quot;Error fetching %s:%s: %s\n&quot;, host, metric,
               pmErrStr(sts));
       exit(1);
   }
   fprintf(stdout, &quot;%s:%s = &quot;, host, metric);
   if (sts == 0)
       puts(&quot;(no value)&quot;);
   else {
       pmValueSet      *vsp = result-&gt;vset[0];
       pmPrintValue(stdout, vsp-&gt;valfmt, desc.type,
                            &amp;vsp-&gt;vlist[0], 5);
       printf(&quot; %s\n&quot;, pmUnitsStr(&amp;desc.units));
   }
   return 0;
}</pre></td></tr></table><br></div><br></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5212855"></a>3.9.6. Compiling and Linking PMAPI Applications</h3></div></div>
<p><a class="indexterm" name="IG31340177459"></a><a class="indexterm" name="IG31340177460"></a><a class="indexterm" name="IG31340177461"></a>Typical PMAPI applications require the following line to include the function prototype and data structure definitions used by the PMAPI. </p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="programlisting">#include &lt;pcp/pmapi.h&gt;</pre></td></tr></table><p>Some applications may also require these header files: <tt>pcp/impl.h</tt> and <tt>pcp/pmda.h</tt>.</p>
<p>The run-time environment of the PMAPI is mostly found in <tt>libpcp.so</tt>; so to link a generic PMAPI application requires something akin to the following command:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout"><b><tt>cc</tt></b> <i>mycode</i><b><tt>.c -lpcp</tt></b></pre></td></tr></table><br></div></div></div><!--CONTENT_END--><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02.html">Prev</a> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Table of Contents</a></td><td width="40%" align="right"> <a accesskey="n" href="ch04.html">Next</a></td></tr><tr><td width="40%" align="left">Chapter 2. Writing a PMDA </td><td width="20%" align="center"> </td><td width="40%" align="right">Chapter 4. Trace PMDA </td></tr></table></div></body></html>
