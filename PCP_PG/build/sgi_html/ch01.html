<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type"><title>Chapter 1. Programming Performance Co-Pilot</title><meta name="generator" content="DocBook XSL Stylesheets V1.51.1"><meta name="generator" content="SGI XSL DocBook Customization Stylesheets V1.1"><link rel="home" href="index.html" title="Performance Co-Pilot&#8482; Programmer's Guide"><link rel="up" href="index.html" title="Performance Co-Pilot&#8482; Programmer's Guide"><link rel="previous" href="pr02.html" title="About This Guide"><link rel="next" href="ch02.html" title="Chapter 2. Writing a PMDA"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 1. Programming Performance Co-Pilot</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="pr02.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch02.html">Next</a></td></tr></table><hr></div><!--CONTENT_BEGIN--><a name="sgi_start_content"></a><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="LE21795-PARENT"></a>Chapter 1. Programming Performance Co-Pilot</h2></div></div>
<p><a class="indexterm" name="IG313401770"></a>Performance Co-Pilot (PCP) provides a systems-level suite of tools that cooperate to deliver distributed, integrated performance management services. PCP is designed for the in-depth analysis and sophisticated control that are needed to understand and manage the hardest performance problems in our most complex systems.</p>
<p>PCP provides unparalleled power to quickly isolate and understand performance behavior, resource utilization, activity levels and performance bottlenecks.</p>
<p>Performance data may be collected and exported from multiple sources, most notably the hardware platform, the operating system kernel, layered services, and end-user applications.</p>
<p><a class="indexterm" name="IG313401771"></a> <a class="indexterm" name="IG313401772"></a>There are several ways to extend PCP by programming certain of its components:</p>
<div class="itemizedlist"><ul type="disc"><li><p><a class="indexterm" name="Z963349317sdc"></a><a class="indexterm" name="IG313401773"></a>By writing a  Performance Metrics Domain Agent (PMDA) to collect performance metrics from an uncharted performance domain (<a href="ch02.html" title="Chapter 2. Writing a PMDA">Chapter 2, &#8220;Writing a PMDA&#8221;</a>)</p>
</li>
<li><p><a class="indexterm" name="Z963349400sdc"></a><a class="indexterm" name="IG313401774"></a>By creating new analysis or visualization tools using documented functions from the  Performance Metrics Application Programming Interface (PMAPI) (<a href="ch03.html" title="Chapter 3. PMAPI--The Performance Metrics API">Chapter 3, &#8220;PMAPI--The Performance Metrics API&#8221;</a>)</p>
</li>
<li><p><a class="indexterm" name="IG313401775"></a><a class="indexterm" name="IG313401776"></a>By adding performance instrumentation to an application using the trace facilities of the PCP trace library (<tt><a name="Z963349455sdc"></a>libpcp_trace</tt>) and the trace PMDA (<a href="ch04.html" title="Chapter 4. Trace PMDA">Chapter 4, &#8220;Trace PMDA&#8221;</a>)</p>
</li>
</ul></div><p><a class="indexterm" name="IG313401777"></a>In addition, the topic of customizing a PCP installation is covered in the chapter on customizing and extending PCP service in the <i><i>Performance Co-Pilot for IRIX Advanced User's and Administrator's Guide</i></i> or in the <i>Performance Co-Pilot for IA-64 Linux User's and Administrator's Guide</i>.</p>
<div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5177140"></a>1.1. PCP Architecture</h2></div></div>
<p><a class="indexterm" name="IG313401778"></a>This section gives a brief overview of PCP architecture. For an explanation of terms and acronyms, refer to <a href="apa.html" title="Appendix A. Acronyms">Appendix A, &#8220;Acronyms&#8221;</a>.</p>
<p><a class="indexterm" name="IG313401779"></a></p>
<p><a class="indexterm" name="IG3134017710"></a><a class="indexterm" name="IG3134017711"></a><a class="indexterm" name="IG3134017712"></a>PCP consists of several monitoring and collecting tools. <tt>Monitoring tools</tt> such as <tt>pmval</tt> and <tt>pminfo</tt> visualize metrics, but have minimal interaction with target systems. <tt>Collection tools</tt>, called PMDAs, extract performance values from target systems, but do not provide graphical user interfaces.</p>
<p>Systems supporting PCP services are broadly classified into two categories:</p>
<div class="variablelist"><table border="0" cellspacing="3"><tr valign="top"><td><span class="term">Collector</span></td><td width="10"> </td><td><p>Hosts that have the PMCD and one or more PMDAs running to collect and export performance metrics</p>

</td></tr><tr valign="top"><td><span class="term">Monitor</span></td><td width="10"> </td><td><p>Hosts that import performance metrics from one or more collector hosts to be consumed by tools to monitor, manage, or record the performance of the collector hosts</p>

</td></tr></table></div><p>Each PCP enabled host can operate as a collector, or a monitor, or both.</p>
<p>There are separate node-locked licenses for additional tools when available on IRIX systems for collector and monitor functions.</p>
<p><a href="ch01.html#id5177328" title="Figure 1-1. PCP Global Process Architecture">Figure 1-1</a> shows the architecture of PCP. The monitoring tools consume and process performance data using a public interface, the Performance Metrics Application Programming Interface (PMAPI).</p>
<p><a class="indexterm" name="IG3134017713"></a><a class="indexterm" name="IG3134017714"></a>Below the PMAPI level is the PMCD process, which acts in a  coordinating role, accepting requests from clients, routing requests to one or more PMDAs, aggregating responses from the PMDAs, and responding to the requesting client.</p>
<p>Each performance metric domain (such as IRIX, Linux, or some Database Management System (DBMS)) has a well-defined name space for referring to the specific performance metrics it knows how to collect.</p>
<p><div class="figure"><a name="id5177328"></a><p><a name="id5177328"></a><b>Figure 1-1. PCP Global Process Architecture</b></p>
<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/PCP_glob_process_architec.gif" alt="PCP Global Process Architecture" height="440" width="441"></td></tr></table></div></div><br></p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5177343"></a>1.1.1. Distributed Collection</h3></div></div>
<p><a class="indexterm" name="IG3134017715"></a><a class="indexterm" name="IG3134017716"></a><a class="indexterm" name="IG3134017717"></a>The performance metrics collection architecture is distributed, in the sense that any monitoring tool may be executing remotely. However, a PMDA is expected to be running on the operating system for which it is collecting performance measurements; there are some notable PMDAs such as Cisco and Array that are exceptions, and collect performance data from remote systems.</p>
<p><a class="indexterm" name="IG3134017718"></a><a class="indexterm" name="IG3134017719"></a>As shown in <a href="ch01.html#id5177408" title="Figure 1-2. Process Structure for Distributed Operation">Figure 1-2</a>, monitoring tools communicate only with PMCD. The PMDAs are controlled by PMCD and respond to requests from the monitoring tools that are forwarded by PMCD to the relevant PMDAs on the  colllector host.</p>
<p><div class="figure"><a name="id5177408"></a><p><a name="id5177408"></a><b>Figure 1-2. Process Structure for Distributed Operation</b></p>
<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/process_struct_for_dist_op.gif" alt="Process Structure for Distributed Operation" height="351" width="604"></td></tr></table></div></div><br></p>
<p>The host running the monitoring tools does not require any collection tools, including PMCD, since all requests for metrics are sent to the PMCD process on the collector host.</p>
<p><a class="indexterm" name="IG3134017720"></a><a class="indexterm" name="IG3134017721"></a>The connections between monitoring tools and PMCD processes are managed in <tt>libpcp</tt>, below the PMAPI level; see the <tt>pmapi(3)</tt> man page. Connections between PMDAs and PMCD are managed by the PMDA functions; see the <tt>pmda(3)</tt> and <tt>pmcd(1)</tt> man pages. There can be multiple monitor clients and multiple PMDAs on the one host, but there may be only one PMCD process.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5177529"></a>1.1.2. Name Space</h3></div></div>
<p><a class="indexterm" name="IG3134017722"></a><a class="indexterm" name="IG3134017723"></a><a class="indexterm" name="IG3134017724"></a>Each PMDA provides a domain of metrics, whether they be for the operating system, a database manager, a layered service, or an application module. These metrics are referred to by name inside the user interface, and with a numeric  Performance Metric Identifier (PMID) within the underlying PMAPI.</p>
<p><a class="indexterm" name="IG3134017725"></a><a class="indexterm" name="IG3134017726"></a><a class="indexterm" name="IG3134017727"></a>The PMID consists of three fields: the domain, the cluster, and the item number of the metric. The domain is a unique number assigned to each PMDA. For example, two metrics with the same domain number must be from the same PMDA. The cluster and item numbers allow metrics to be easily organized into groups within the PMDA, and provide a hierarchical taxonomy to guarantee uniqueness within each PMDA.</p>
<p><a class="indexterm" name="IG3134017728"></a>The Performance Metrics Name Space (PMNS) describes the exported performance metrics, in particular the mapping from PMID to external name, and vice-versa.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5177616"></a>1.1.3. Distributed PMNS</h3></div></div>
<p> <a class="indexterm" name="IG3134017729"></a> As of release 2.0 release, PMNS operations by default are directed to the host or archive that is the source of the desired performance metrics.</p>
<p>In <a href="ch01.html#id5177408" title="Figure 1-2. Process Structure for Distributed Operation">Figure 1-2</a>, both Performance Metrics Collection Daemon (PMCD) processes would respond to PMNS queries from monitoring tools by referring to their local PMNS. If different PMDAs were installed on the two hosts, then the PMNS used by each PMCD would be different, to reflect variations in available metrics on the two hosts.</p>
<p>Distributed PMNS services necessitated changes to PCP protocols between client applications and PMCD, and to the internal format of PCP archive files.</p>
<p>The <tt>-n</tt> <i>pmnsfile </i>option may be used with all PCP monitoring tools to force use of the local PMNS in preference to the PMNS at the source of the metrics.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5177692"></a>1.1.4. Retrospective Sources of Performance Metrics</h3></div></div>
<p><a class="indexterm" name="IG3134017730"></a>The distributed collection architecture described in the previous section is used when PMAPI clients are requesting performance metrics from a real-time or live source.</p>
<p><a class="indexterm" name="IG3134017731"></a>The PMAPI also supports delivery of performance metrics from a historical source in the form of a PCP archive log. Archive logs  are created using the <tt>pmlogger</tt> utility, and are replayed in an architecture as shown in <a href="ch01.html#id5177742" title="Figure 1-3. Architecture for Retrospective Analysis">Figure 1-3</a>.</p>
<p><div class="figure"><a name="id5177742"></a><p><a name="id5177742"></a><b>Figure 1-3. Architecture for Retrospective Analysis</b></p>
<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td><img src="figures/retrospect_analysis_architec.gif" alt="Architecture for Retrospective Analysis" height="289" width="316"></td></tr></table></div></div><br></p>
</div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="LE13618-PARENT"></a>1.2. Overview of Component Software</h2></div></div>
<p><a class="indexterm" name="IG3134017732"></a><a class="indexterm" name="IG3134017733"></a>Performance Co-Pilot (PCP) is composed of text-based tools, optional graphical tools, and related commands. Each tool or command is fully documented by a man page. These man pages are named after the tools or commands they describe, and are accessible through the <tt>man</tt> command. For example, to see the <tt>pminfo(1)</tt> man page for the <tt>pminfo</tt> command, enter this command:<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout"><b><tt>man pminfo</tt></b></pre></td></tr></table><br></p>
<p>Many PCP tools and commands are accessible from an <b>Icon Catalog</b> on the IRIX desktop, grouped under <b>PerfTools</b>. In the <b>Toolchest</b> <b>Find</b> menu, choose <b>PerfTools</b>; an <b>Icon Catalog</b> appears, containing clickable PCP programs. To bring up a Web-based introduction to Performance Co-Pilot, click the <b>AboutPCP</b> icon.</p>
<p>A list of PCP tools and commands, grouped by functionality, is provided in the following sections.</p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5177879"></a>1.2.1. Application and Agent Development</h3></div></div>
<p><a class="indexterm" name="ITch01-114"></a><a class="indexterm" name="IG3134017734"></a>The following PCP tools aid the development of new programs to consume performance data, and new agents to export performance data within the PCP framework:</p>
<div class="variablelist"><table border="0" cellspacing="3"><tr valign="top"><td><span class="term"><tt>chkhelp</tt></span></td><td width="10"> </td><td><p><a class="indexterm" name="IG3134017735"></a>Checks the consistency of performance metrics help database files.</p>

</td></tr><tr valign="top"><td><span class="term"><tt>dbpmda</tt></span></td><td width="10"> </td><td><p><a class="indexterm" name="IG3134017736"></a>Allows PMDA behavior to be exercised and tested. It is an interactive debugger for PMDAs.</p>

</td></tr><tr valign="top"><td><span class="term"><tt>newhelp</tt></span></td><td width="10"> </td><td><p><a class="indexterm" name="IG3134017737"></a>Generates the database files for one or more source files of PCP help text.</p>

</td></tr><tr valign="top"><td><span class="term"><tt>pmapi</tt></span></td><td width="10"> </td><td><p><a class="indexterm" name="IG3134017738"></a><a class="indexterm" name="IG3134017739"></a><a class="indexterm" name="IG3134017740"></a>Defines a procedural interface for developing PCP client applications. It is the Performance Metrics Application Programming Interface (PMAPI).</p>

</td></tr><tr valign="top"><td><span class="term"><tt>pmclient</tt></span></td><td width="10"> </td><td><p><a class="indexterm" name="IG3134017741"></a>Is a simple client that uses the PMAPI to report some high-level system performance metrics. The source code for <tt>pmclient</tt> is included in the distribution.</p>

</td></tr><tr valign="top"><td><span class="term"><tt>pmda</tt></span></td><td width="10"> </td><td><p><a class="indexterm" name="IG3134017742"></a>Is a library used by many shipped PMDAs to communicate with a <tt>pmcd</tt> process. It can expedite the development of new and custom PMDAs.</p>

</td></tr><tr valign="top"><td><span class="term"><tt>pmgenmap</tt></span></td><td width="10"> </td><td><p><a class="indexterm" name="IG3134017743"></a>Generates C declarations and <tt>cpp</tt> macros to aid the development of customized programs that use the facilities of PCP. It is a program development tool.</p>

</td></tr></table></div></div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="LE16056-PARENT"></a>1.3. PMDA Development</h2></div></div>
<p><a class="indexterm" name="IG3134017744"></a>A collection of Performance Metrics Domain Agents (PMDAs) are provided with PCP to extract performance metrics. Each PMDA encapsulates domain-specific knowledge and methods about performance metrics that implement the uniform access protocols and functional semantics of the PCP. There is one PMDA for the operating system, another for process specific statistics, one each for common DBMS products, and so on. Thus, the range of performance metrics can be easily extended by implementing and integrating new PMDAs. <a href="ch02.html" title="Chapter 2. Writing a PMDA">Chapter 2, &#8220;Writing a PMDA&#8221;</a>, is a step-by-step guide to writing your own PMDA.</p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5178205"></a>1.3.1. Overview</h3></div></div>
<p>Once you are familiar with the PCP and PMDA frameworks, you can quickly implement a new PMDA with only a few data structures and functions. This book contains detailed discussions of PMDA architecture and the integration of PMDAs into the PCP framework. This includes integration with PMCD. However, details of extracting performance metrics from the underlying instrumentation vary from one domain to another and are not covered in this book.</p>
<p>A PMDA is responsible for a set of performance metrics, in the sense that it must respond to requests from PMCD for information about performance metrics, instance domains, and instantiated values. The PMCD process generates requests on behalf of monitoring tools that make requests using PMAPI functions.</p>
<p>You can incorporate new performance metrics into the PCP framework by creating a PMDA, then reconfiguring PMCD to communicate with the new PMDA.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5178242"></a>1.3.2. Building a PMDA</h3></div></div>
<p>A PMDA interacts with PMCD across one of several well-defined interfaces and protocol mechanisms. These implementation options are described in the <i>Performance Co-Pilot for IRIX Advanced User's and Administrator's Guide</i> or the <i>Performance Co-Pilot for IA-64 Linux User's and Administrator's Guide</i>.</p>
<p>It is strongly recommended that code for a new PMDA be based on the source of one of the demonstration PMDAs below the <tt>/var/pcp/pmdas</tt> directory.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5178295"></a>1.3.2.1. In-Process (DSO) Method</h4></div></div>
<p><a class="indexterm" name="IG3134017745"></a><a class="indexterm" name="IG3134017746"></a><a class="indexterm" name="IG3134017747"></a><a class="indexterm" name="IG3134017748"></a><a class="indexterm" name="IG3134017749"></a>This method of building a PMDA uses a Dynamic Shared Object (DSO) that is attached by PMCD, using <tt>dlopen</tt>, at initialization time. This is the highest performance option (there is no context switching and no interprocess communication (IPC)  between the PMCD and the PMDA), but is operationally intractable in some situations. For example, difficulties arise where special access permissions are required to read
the instrumentation behind the performance metrics, or where the performance metrics are provided by an existing process with a different protocol interface. The DSO PMDA effectively executes as part of PMCD; so care is required when crafting a PMDA in this manner.</p>
<p>When developing PMDAs for IRIX or Linux, multiple object code formats for the DSO may be required because  PMCD must execute with the same object code format as the running operating system kernel. This would be <tt>o32</tt> for some low-end platforms (IRIX 6.3 and earlier), <tt>n32</tt> for other low-end platforms (IRIX 6.5 and later), and <tt>n64</tt> for high-end platforms.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5178384"></a>1.3.2.2. Daemon Process Method</h4></div></div>
<p><a class="indexterm" name="IG3134017750"></a>Functionally, this method may be thought of as a DSO implementation with a standard <tt>main</tt> routine conversion wrapper so that communication with PMCD uses message passing rather than direct procedure calls. (See <tt>/var/pcp/pmdas/trivial/trivial.c</tt>  file.)</p>
<p>The daemon PMDA is actually the most common, because it allows multiple threads of control, permits linking with existing dynamic libraries, and provides more resilient error encapsulation than the DSO method.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5178420"></a>1.3.2.3. Shell Process Method</h4></div></div>
<p><a class="indexterm" name="IG3134017751"></a>This method offers the least performance, but may be well-suited for rapid prototyping of performance metrics, or for diagnostic metrics that are not going into production.</p>
<p>Implementation of the ASCII protocols is rather lengthy. The suggested approach is to take the <tt>/var/pcp/pmdas/news/pmdanews</tt> PMDA as an illustrative example, and adapt it for the particular metrics of interest.</p>
<div class="note"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/note.png" height="24" width="24"></td><td align="left" valign="top"><b>Note: </b>The ASCII protocols have not been extensively used; so their support may be discontinued in a future PCP release. Newer versions of the PMDA libraries have dramatically reduced the code development effort required for a new PMDA (either the DSO or daemon approach), thereby reducing the need for ASCII protocols.
</td></tr></table><hr noshade="noshade"></div><br></div></div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5178467"></a>1.4. Client Development and PMAPI</h2></div></div>
<p><a class="indexterm" name="IG3134017752"></a>Application developers are encouraged to create new PCP client applications to monitor, display, and analyze performance data in a manner suited to their particular site, application suite, or information processing environment.</p>
<p><a class="indexterm" name="IG3134017753"></a><a class="indexterm" name="IG3134017754"></a><a class="indexterm" name="IG3134017755"></a>PCP client applications are programmed using the Performance Metrics Application Programming Interface (PMAPI), documented in <a href="ch03.html" title="Chapter 3. PMAPI--The Performance Metrics API">Chapter 3, &#8220;PMAPI--The Performance Metrics API&#8221;</a>. The PMAPI, which provides performance tool developers with access to all of the distributed services of the Performance Metrics Collection Subsystem (PMCS), is the interface used by the standard PCP utilities.</p>
<p>Source for a sample IRIX PMAPI client may be found in the <tt>/var/pcp/demos/pmclient</tt> directory if the <tt>pcp.sw.demo</tt> subsystem has been installed. Source for a sample Linux PMAPI client may be found in the <tt>/usr/share/pcp/demos/pmclient</tt> directory.</p>
</div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5187605"></a>1.5. Library Reentrancy and Threaded Applications</h2></div></div>
<p><a class="indexterm" name="IG3134017756"></a><a class="indexterm" name="IG3134017757"></a><a class="indexterm" name="IG3134017758"></a>Most of the PCP libraries are not thread safe. This is a deliberate design decision to trade-off commonly required performance and efficiency against the less common requirement for multiple threads of control to call the PCP libraries.</p>
<p>The simplest and safest programming model is to designate at most one thread to make calls into the PCP libraries. This approach applies to both PMDAs using <tt>libpcp_pmda</tt> and monitoring applications using PMAPI and calling the <tt>libpcp</tt> library.</p>
<p>An important exception is the <tt>libpcp_trace</tt> library for instrumenting applications; it is thread safe.</p>
<p>Particular care should be taken with the utility functions in the <tt>libpcp</tt> library; for example, <tt>pmprintf</tt> and <tt>pmflush</tt> share a buffer that may be corrupted if calls to these functions from multiple threads are overlapped.</p>
</div></div><!--CONTENT_END--><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pr02.html">Prev</a> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Table of Contents</a></td><td width="40%" align="right"> <a accesskey="n" href="ch02.html">Next</a></td></tr><tr><td width="40%" align="left">About This Guide </td><td width="20%" align="center"> </td><td width="40%" align="right">Chapter 2. Writing a PMDA </td></tr></table></div></body></html>
