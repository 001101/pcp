<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1997, v.4001
<!DOCTYPE SGIDOCBK PUBLIC "-//Silicon Graphics, Inc.//DTD DocBook V2.3-based Subset V1.5//EN" [
<!ENTITY a12189 SYSTEM "online/a12189.gif" NDATA gif>
<!ENTITY c1pcp.sgml SYSTEM "c1pcp.sgml">
<!ENTITY c2pmda.sgml SYSTEM "c2pmda.sgml">
<!ENTITY c3pmapi.sgml SYSTEM "c3pmapi.sgml">
<!ENTITY c4pmda.sgml SYSTEM "c4pmda.sgml">
<!ENTITY appA.sgml SYSTEM "appA.sgml">
<!ENTITY PCP_glob_process_architec SYSTEM "online/PCP_glob_process_architec.gif" NDATA gif>
<!ENTITY process_struct_for_dist_op SYSTEM "online/process_struct_for_dist_op.gif" NDATA gif>
<!ENTITY retrospect_analysis_architec SYSTEM "online/retrospect_analysis_architec.gif" NDATA gif>
<!ENTITY struct_results_frm_pmFetch SYSTEM "online/struct_results_frm_pmFetch.gif" NDATA gif>
<!ENTITY trace_1 SYSTEM "online/trace_1.gif" NDATA gif>
<!ENTITY trace_buffer SYSTEM "online/trace_buffer.gif" NDATA gif>
<!ENTITY trace_example SYSTEM "online/trace_example.gif" NDATA gif>
<!ENTITY trace_libpcp SYSTEM "online/trace_libpcp.gif" NDATA gif>
<!ENTITY preface.sgml SYSTEM "preface.sgml">
<!ENTITY chap02.sgml SYSTEM "chap02.sgml">
<!ENTITY chap03.sgml SYSTEM "chap03.sgml">
<!ENTITY chap04.sgml SYSTEM "chap04.sgml">
<!ENTITY chapA.sgml SYSTEM "chapA.sgml">
<!ENTITY % public.private "INCLUDE">
<!ENTITY % proprietary "IGNORE">
<!ENTITY % private "IGNORE">
<!ENTITY % public "INCLUDE">
<!ENTITY % craysoft "IGNORE">
<!ENTITY standards SYSTEM "frontmatter/standards.sgml">
<!ENTITY machines.allcraysystems SYSTEM "frontmatter/machines.allcraysystems.sgml">
<!ENTITY machines.craympp SYSTEM "frontmatter/machines.craympp.sgml">
<!ENTITY conventions.ellipses SYSTEM "frontmatter/conventions.ellipses.sgml">
<!ENTITY conventions.brackets SYSTEM "frontmatter/conventions.brackets.sgml">
<!ENTITY conventions.userinput SYSTEM "frontmatter/conventions.userinput.sgml">
<!ENTITY conventions.variable SYSTEM "frontmatter/conventions.variable.sgml">
<!ENTITY conventions.manpage SYSTEM "frontmatter/conventions.manpage.sgml">
<!ENTITY conventions.command SYSTEM "frontmatter/conventions.command.sgml">
<!ENTITY ordering.pubs SYSTEM "frontmatter/ordering.pubs.sgml">
<!ENTITY reader.comments SYSTEM "frontmatter/reader.comments.sgml">
<!ENTITY manpage.section SYSTEM "frontmatter/manpage.section.sgml">
<!ENTITY unicos SYSTEM "frontmatter/unicos.sgml">
<!ENTITY trademarks SYSTEM "frontmatter/trademarks.sgml">
<!ENTITY disclaimer SYSTEM "frontmatter/disclaimer.sgml">
<!ENTITY rights SYSTEM "frontmatter/rights.sgml">
]>
-->
<?Pub UDT _nopagebreak _touchup KeepsKeep="yes" KeepsPrev="no" KeepsNext="no" KeepsBoundary="page">
<chapter id="LE21795-PARENT">
<title id="LE21795-TITLE">Programming Performance Co-Pilot</title>
<para><indexterm><primary>PCP</primary><secondary>description</secondary></indexterm>Performance Co-Pilot (PCP) provides a systems-level suite of tools that cooperate to deliver distributed, integrated performance management services. PCP is designed for the in-depth analysis and sophisticated control that are needed to understand and manage the hardest performance problems in our most complex systems.</para>
<para>PCP provides unparalleled power to quickly isolate and understand performance behavior, resource utilization, activity levels and performance bottlenecks.</para>
<para>Performance data may be collected and exported from multiple sources, most notably the hardware platform, the operating system kernel, layered services, and end-user applications.</para>
<para><indexterm><primary>programming components</primary></indexterm> <indexterm><primary>audience</primary></indexterm>There are several ways to extend PCP by programming certain of its components:</para>
<itemizedlist>
<listitem><para><indexterm id="Z963349317sdc"><primary>Performance Metrics Domain Agent </primary><see>PMDA</see></indexterm><indexterm><primary>PMDA</primary><secondary>introduction</secondary></indexterm>By writing a  Performance Metrics Domain Agent (PMDA) to collect performance metrics from an uncharted performance domain (<xref linkend="LE98072-PARENT">)</para>
</listitem>
<listitem><para><indexterm id="Z963349400sdc"><primary>Performance Metrics Application Programming Interface </primary><see>PMAPI</see></indexterm><indexterm><primary>PMAPI</primary><secondary>introduction</secondary></indexterm>By creating new analysis or visualization tools using documented functions from the  Performance Metrics Application Programming Interface (PMAPI) (<xref linkend="LE97135-PARENT">)</para>
</listitem>
<listitem><para><indexterm><primary>performance instrumentation</primary></indexterm><indexterm><primary>trace facilities</primary></indexterm>By adding performance instrumentation to an application using the trace facilities of the PCP trace library (<filename id="Z963349455sdc">libpcp_trace</filename>) and the trace PMDA (<xref linkend="LE25915-PARENT">)</para>
</listitem></itemizedlist>
<para><indexterm><primary>customization</primary></indexterm>In addition, the topic of customizing a PCP installation is covered in the chapter on customizing and extending PCP service in the <citetitle><citetitle>Performance Co-Pilot for IRIX Advanced User's and Administrator's Guide</citetitle></citetitle> or in the <citetitle>Performance Co-Pilot for IA-64 Linux User's and Administrator's Guide</citetitle>.</para>
<section>
<title>PCP Architecture</title>
<para><indexterm><primary>architecture</primary></indexterm>This section gives a brief overview of PCP architecture. For an explanation of terms and acronyms, refer to <xref linkend="LE54271-PARENT">.</para>
<para><indexterm><primary>pmchart command</primary></indexterm></para>
<para><indexterm><primary>pmview command</primary></indexterm><indexterm><primary>monitoring tools</primary></indexterm><indexterm><primary>collection tools</primary></indexterm>PCP consists of several monitoring and collecting tools. <filename>Monitoring tools</filename> such as <command>pmval</command> and <command>pminfo</command> visualize metrics, but have minimal interaction with target systems. <filename>Collection tools</filename>, called PMDAs, extract performance values from target systems, but do not provide graphical user interfaces.</para>
<para>Systems supporting PCP services are broadly classified into two categories:</para>
<deflist>
<deflistentry>
<term>Collector</term>
<listitem><para>Hosts that have the PMCD and one or more PMDAs running to collect and export performance metrics</para>
</listitem></deflistentry>
<deflistentry>
<term>Monitor</term>
<listitem><para>Hosts that import performance metrics from one or more collector hosts to be consumed by tools to monitor, manage, or record the performance of the collector hosts</para>
</listitem></deflistentry>
</deflist>
<para>Each PCP enabled host can operate as a collector, or a monitor, or both.</para>
<para>There are separate node-locked licenses for additional tools when available on IRIX systems for collector and monitor functions.</para>
<para><xref linkend="LE44051-TITLE"> shows the architecture of PCP. The monitoring tools consume and process performance data using a public interface, the Performance Metrics Application Programming Interface (PMAPI).</para>
<para><indexterm><primary>PMCD</primary><secondary>overview</secondary></indexterm><indexterm><primary>Performance Metrics Collection Daemon </primary><see>PMCD</see></indexterm>Below the PMAPI level is the PMCD process, which acts in a  coordinating role, accepting requests from clients, routing requests to one or more PMDAs, aggregating responses from the PMDAs, and responding to the requesting client.</para>
<para>Each performance metric domain (such as IRIX, Linux, or some Database Management System (DBMS)) has a well-defined name space for referring to the specific performance metrics it knows how to collect.</para>
<para><figure>
<graphic entityref="PCP_glob_process_architec" scale="NO" location="INLINE"></graphic>
<title id="LE44051-TITLE">PCP Global Process Architecture</title></figure></para>
<section>
<title>Distributed Collection</title>
<para><indexterm><primary>distributed performance management</primary><secondary>metrics collection</secondary></indexterm><indexterm><primary>Cisco PMDA</primary></indexterm><indexterm><primary>Array PMDA</primary></indexterm>The performance metrics collection architecture is distributed, in the sense that any monitoring tool may be executing remotely. However, a PMDA is expected to be running on the operating system for which it is collecting performance measurements; there are some notable PMDAs such as Cisco and Array that are exceptions, and collect performance data from remote systems.</para>
<?Pub _newpage>
<para><indexterm><primary>PMCD</primary><secondary>distributed collection</secondary></indexterm><indexterm><primary>collector hosts</primary></indexterm>As shown in <xref linkend="LE61231-TITLE">, monitoring tools communicate only with PMCD. The PMDAs are controlled by PMCD and respond to requests from the monitoring tools that are forwarded by PMCD to the relevant PMDAs on the  colllector host.</para>
<para><figure>
<graphic entityref="process_struct_for_dist_op" scale="NO" location="INLINE"></graphic>
<title id="LE61231-TITLE">Process Structure for Distributed Operation</title></figure></para>
<para>The host running the monitoring tools does not require any collection tools, including PMCD, since all requests for metrics are sent to the PMCD process on the collector host.</para>
<para><indexterm><primary>PMDA </primary><secondary>man page</secondary></indexterm><indexterm><primary>PMAPI</primary><secondary>man page</secondary></indexterm>The connections between monitoring tools and PMCD processes are managed in <filename>libpcp</filename>, below the PMAPI level; see the <command sectionref="3">pmapi</command> man page. Connections between PMDAs and PMCD are managed by the PMDA functions; see the <command sectionref="3">pmda</command> and <command sectionref="1">pmcd</command> man pages. There can be multiple monitor clients and multiple PMDAs on the one host, but there may be only one PMCD process.</para>
</section>
<?Pub _newpage>
<section>
<title>Name Space</title>
<para><indexterm><primary>name space</primary></indexterm><indexterm><primary>Performance Metric Identifier</primary><see>PMID</see></indexterm><indexterm><primary>PMID</primary><secondary>introduction</secondary></indexterm>Each PMDA provides a domain of metrics, whether they be for the operating system, a database manager, a layered service, or an application module. These metrics are referred to by name inside the user interface, and with a numeric  Performance Metric Identifier (PMID) within the underlying PMAPI.</para>
<para><indexterm><primary>clusters</primary></indexterm><indexterm><primary>item numbers</primary></indexterm><indexterm><primary>domains</primary><secondary>fields</secondary></indexterm>The PMID consists of three fields: the domain, the cluster, and the item number of the metric. The domain is a unique number assigned to each PMDA. For example, two metrics with the same domain number must be from the same PMDA. The cluster and item numbers allow metrics to be easily organized into groups within the PMDA, and provide a hierarchical taxonomy to guarantee uniqueness within each PMDA.</para>
<para><indexterm><primary>Performance Metrics Name Space</primary><see>PMNS</see></indexterm>The Performance Metrics Name Space (PMNS) describes the exported performance metrics, in particular the mapping from PMID to external name, and vice-versa.</para>
</section>
<section>
<title>Distributed PMNS</title>
<para> <indexterm><primary>PMNS</primary><secondary>distributed</secondary></indexterm> As of release 2.0 release, PMNS operations by default are directed to the host or archive that is the source of the desired performance metrics.</para>
<para>In <xref linkend="LE61231-TITLE">, both Performance Metrics Collection Daemon (PMCD) processes would respond to PMNS queries from monitoring tools by referring to their local PMNS. If different PMDAs were installed on the two hosts, then the PMNS used by each PMCD would be different, to reflect variations in available metrics on the two hosts.</para>
<para>Distributed PMNS services necessitated changes to PCP protocols between client applications and PMCD, and to the internal format of PCP archive files.</para>
<para>The <command>-n</command>&ensp;<replaceable>pmnsfile </replaceable>option may be used with all PCP monitoring tools to force use of the local PMNS in preference to the PMNS at the source of the metrics.</para>
</section>
<?Pub _newpage>
<section>
<title>Retrospective Sources of Performance Metrics</title>
<para><indexterm><primary>retrospective analysis</primary></indexterm>The distributed collection architecture described in the previous section is used when PMAPI clients are requesting performance metrics from a real-time or live source.</para>
<para><indexterm><primary>archive logs</primary><secondary>retrospective sources</secondary></indexterm>The PMAPI also supports delivery of performance metrics from a historical source in the form of a PCP archive log. Archive logs  are created using the <command>pmlogger</command> utility, and are replayed in an architecture as shown in <xref linkend="LE43402-TITLE">.</para>
<para><figure>
<graphic entityref="retrospect_analysis_architec" scale="no" location="INLINE"></graphic>
<title id="LE43402-TITLE">Architecture for Retrospective Analysis</title></figure></para>
</section>
</section>
<section id="LE13618-PARENT">
<title id="LE13618-TITLE">Overview of Component Software</title>
<para><indexterm><primary>software</primary></indexterm><indexterm><primary>component software</primary></indexterm>Performance Co-Pilot (PCP) is composed of text-based tools, optional graphical tools, and related commands. Each tool or command is fully documented by a man page. These man pages are named after the tools or commands they describe, and are accessible through the <command>man</command> command. For example, to see the <command sectionref="1">pminfo</command> man page for the <command>pminfo</command> command, enter this command:<literallayout><userinput>man pminfo</userinput></literallayout><?Pub Caret></para>
<para>Many PCP tools and commands are accessible from an <interface>Icon Catalog</interface> on the IRIX desktop, grouped under <interface>PerfTools</interface>. In the <interface>Toolchest</interface> <interface>Find</interface> menu, choose <interface>PerfTools</interface>; an <interface>Icon Catalog</interface> appears, containing clickable PCP programs. To bring up a Web-based introduction to Performance Co-Pilot, click the <interface>AboutPCP</interface> icon.</para>
<para>A list of PCP tools and commands, grouped by functionality, is provided in the following sections.</para>
<section>
<title>Application and Agent Development</title>
<para><indexterm id="ITch01-114"><primary>application programs</primary></indexterm><indexterm><primary>PCP</primary><secondary>tool summaries</secondary></indexterm>The following PCP tools aid the development of new programs to consume performance data, and new agents to export performance data within the PCP framework:</para>
<deflist>
<deflistentry>
<term><command>chkhelp</command></term>
<listitem><para><indexterm><primary>chkhelp tool</primary></indexterm>Checks the consistency of performance metrics help database files.</para>
</listitem></deflistentry>
<deflistentry>
<term><command>dbpmda</command></term>
<listitem><para><indexterm><primary></primary></indexterm>Allows PMDA behavior to be exercised and tested. It is an interactive debugger for PMDAs.</para>
</listitem></deflistentry>
<deflistentry>
<term><command>newhelp</command></term>
<listitem><para><indexterm><primary>newhelp tool</primary></indexterm>Generates the database files for one or more source files of PCP help text.</para>
</listitem></deflistentry>
<deflistentry>
<term><command>pmapi</command></term>
<listitem><para><indexterm><primary>pmclient tool</primary><secondary>brief description</secondary></indexterm><indexterm><primary>PMAPI</primary></indexterm><indexterm><primary>Performance Metrics Application Programming Interface </primary><see>PMAPI</see></indexterm>Defines a procedural interface for developing PCP client applications. It is the Performance Metrics Application Programming Interface (PMAPI).</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>pmclient</literal></term>
<listitem><para><indexterm><primary>pmclient tool</primary></indexterm>Is a simple client that uses the PMAPI to report some high-level system performance metrics. The source code for <command>pmclient</command> is included in the distribution.</para>
</listitem></deflistentry>
<deflistentry>
<term><command>pmda</command></term>
<listitem><para><indexterm><primary>pmda tool</primary><see>PMDA</see></indexterm>Is a library used by many shipped PMDAs to communicate with a <command>pmcd</command> process. It can expedite the development of new and custom PMDAs.</para>
</listitem></deflistentry>
<deflistentry>
<term><command>pmgenmap</command></term>
<listitem><para><indexterm><primary>pmgenmap tool</primary></indexterm>Generates C declarations and <literal>cpp</literal> macros to aid the development of customized programs that use the facilities of PCP. It is a program development tool.</para>
</listitem></deflistentry>
</deflist>
</section>
</section>
<section id="LE16056-PARENT">
<title id="LE16056-TITLE">PMDA Development</title>
<para><indexterm><primary>PMDA</primary><secondary>development</secondary></indexterm>A collection of Performance Metrics Domain Agents (PMDAs) are provided with PCP to extract performance metrics. Each PMDA encapsulates domain-specific knowledge and methods about performance metrics that implement the uniform access protocols and functional semantics of the PCP. There is one PMDA for the operating system, another for process specific statistics, one each for common DBMS products, and so on. Thus, the range of performance metrics can be easily extended by implementing and integrating new PMDAs. <xref linkend="LE98072-PARENT">, is a step-by-step guide to writing your own PMDA.</para>
<section>
<title>Overview</title>
<para>Once you are familiar with the PCP and PMDA frameworks, you can quickly implement a new PMDA with only a few data structures and functions. This book contains detailed discussions of PMDA architecture and the integration of PMDAs into the PCP framework. This includes integration with PMCD. However, details of extracting performance metrics from the underlying instrumentation vary from one domain to another and are not covered in this book.</para>
<para>A PMDA is responsible for a set of performance metrics, in the sense that it must respond to requests from PMCD for information about performance metrics, instance domains, and instantiated values. The PMCD process generates requests on behalf of monitoring tools that make requests using PMAPI functions.</para>
<para>You can incorporate new performance metrics into the PCP framework by creating a PMDA, then reconfiguring PMCD to communicate with the new PMDA.</para>
</section>
<section>
<title>Building a PMDA</title>
<para>A PMDA interacts with PMCD across one of several well-defined interfaces and protocol mechanisms. These implementation options are described in the <citetitle>Performance Co-Pilot for IRIX Advanced User's and Administrator's Guide</citetitle> or the <citetitle>Performance Co-Pilot for IA-64 Linux User's and Administrator's Guide</citetitle>.</para>
<para>It is strongly recommended that code for a new PMDA be based on the source of one of the demonstration PMDAs below the <filename>/var/pcp/pmdas</filename> directory.</para>
<section>
<title>In-Process (DSO) Method</title>
<para><indexterm><primary>DSO</primary><secondary>PMDA building</secondary></indexterm><indexterm><primary>dlopen man page</primary></indexterm><indexterm><primary>dynamic shared object</primary><see>DSO</see></indexterm><indexterm><primary>interprocess communication</primary><see>IPC</see></indexterm><indexterm><primary>IPC</primary><secondary>DSO</secondary></indexterm>This method of building a PMDA uses a Dynamic Shared Object (DSO) that is attached by PMCD, using <command>dlopen</command>, at initialization time. This is the highest performance option (there is no context switching and no interprocess communication (IPC)  between the PMCD and the PMDA), but is operationally intractable in some situations. For example, difficulties arise where special access permissions are required to read
the instrumentation behind the performance metrics, or where the performance metrics are provided by an existing process with a different protocol interface. The DSO PMDA effectively executes as part of PMCD; so care is required when crafting a PMDA in this manner.</para>
<para>When developing PMDAs for IRIX or Linux, multiple object code formats for the DSO may be required because  PMCD must execute with the same object code format as the running operating system kernel. This would be <literal>o32</literal> for some low-end platforms (IRIX 6.3 and earlier), <literal>n32</literal> for other low-end platforms (IRIX 6.5 and later), and <literal>n64</literal> for high-end platforms.</para>
</section>
<section>
<title>Daemon Process Method</title>
<para><indexterm><primary>daemon process method</primary></indexterm>Functionally, this method may be thought of as a DSO implementation with a standard <command>main</command> routine conversion wrapper so that communication with PMCD uses message passing rather than direct procedure calls. (See <filename>/var/pcp/pmdas/trivial/trivial.c</filename>  file.)</para>
<para>The daemon PMDA is actually the most common, because it allows multiple threads of control, permits linking with existing dynamic libraries, and provides more resilient error encapsulation than the DSO method.</para>
</section>
<section>
<title>Shell Process Method</title>
<para><indexterm><primary>shell process</primary></indexterm>This method offers the least performance, but may be well-suited for rapid prototyping of performance metrics, or for diagnostic metrics that are not going into production.</para>
<para>Implementation of the ASCII protocols is rather lengthy. The suggested approach is to take the <filename>/var/pcp/pmdas/news/pmdanews</filename> PMDA as an illustrative example, and adapt it for the particular metrics of interest.</para>
<note><para>The ASCII protocols have not been extensively used; so their support may be discontinued in a future PCP release. Newer versions of the PMDA libraries have dramatically reduced the code development effort required for a new PMDA (either the DSO or daemon approach), thereby reducing the need for ASCII protocols.</para>
</note>
</section>
</section>
</section>
<section>
<title>Client Development and PMAPI</title>
<para><indexterm><primary>client development</primary></indexterm>Application developers are encouraged to create new PCP client applications to monitor, display, and analyze performance data in a manner suited to their particular site, application suite, or information processing environment.</para>
<para><indexterm><primary>Performance Metrics Collection Subsystem</primary><seealso>PMCS</seealso></indexterm><indexterm><primary>PMCS</primary></indexterm><indexterm><primary>PMAPI</primary><secondary>client development</secondary></indexterm>PCP client applications are programmed using the Performance Metrics Application Programming Interface (PMAPI), documented in <xref linkend="LE97135-PARENT">. The PMAPI, which provides performance tool developers with access to all of the distributed services of the Performance Metrics Collection Subsystem (PMCS), is the interface used by the standard PCP utilities.</para>
<para>Source for a sample IRIX PMAPI client may be found in the <filename>/var/pcp/demos/pmclient</filename> directory if the <filename>pcp.sw.demo</filename> subsystem has been installed. Source for a sample Linux PMAPI client may be found in the <filename>/usr/share/pcp/demos/pmclient</filename> directory.</para>
</section>
<section>
<title>Library Reentrancy and Threaded Applications</title>
<para><indexterm><primary>threaded applications</primary></indexterm><indexterm><primary>multiple threads</primary></indexterm><indexterm><primary>library reentrancy</primary></indexterm>Most of the PCP libraries are not thread safe. This is a deliberate design decision to trade-off commonly required performance and efficiency against the less common requirement for multiple threads of control to call the PCP libraries.</para>
<para>The simplest and safest programming model is to designate at most one thread to make calls into the PCP libraries. This approach applies to both PMDAs using <filename>libpcp_pmda</filename> and monitoring applications using PMAPI and calling the <filename>libpcp</filename> library.</para>
<para>An important exception is the <filename>libpcp_trace</filename> library for instrumenting applications; it is thread safe.</para>
<para>Particular care should be taken with the utility functions in the <filename>libpcp</filename> library; for example, <command>pmprintf</command> and <command>pmflush</command> share a buffer that may be corrupted if calls to these functions from multiple threads are overlapped.</para>
</section>
</chapter>
<?Pub *0000025525 0>
