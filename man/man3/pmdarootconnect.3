'\"macro stdmacro
.\"
.\" Copyright (c) 2014-2015 Red Hat.
.\" 
.\" This program is free software; you can redistribute it and/or modify it
.\" under the terms of the GNU General Public License as published by the
.\" Free Software Foundation; either version 2 of the License, or (at your
.\" option) any later version.
.\" 
.\" This program is distributed in the hope that it will be useful, but
.\" WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
.\" or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
.\" for more details.
.\" 
.\"
.TH PMDAROOTCONNECT 3 "PCP" "Performance Co-Pilot"
.SH NAME
\f3pmdaRootConnect\f1,
\f3pmdaRootShutdown\f1,
\f3pmdaEnterProcessNameSpaces\f1,
\f3pmdaEnterContainerNameSpaces\f1,
\f3pmdaLeaveNameSpaces\f1 \- privileged PCP collector services
.SH "C SYNOPSIS"
.ft 3
#include <pcp/pmapi.h>
.br
#include <pcp/pmda.h>
.sp
.ad l
.hy 0
.in +8n
.ti -8n
int pmdaRootConnect(void);
.br
.ti -8n
void pmdaRootShutdown(int \fIfd\fP);
.br
.ti -8n
void pmdaEnterContainerNameSpaces(int \fIfd\fP, const char *\fIname\fP, int \fInsflags\fP);
.br
.ti -8n
void pmdaEnterProcessNameSpaces(int \fIfd\fP, int \fIpid\fP, int \fInsflags\fP);
.br
.ti -8n
void pmdaLeaveNameSpaces(int \fIfd\fP, int \fInsflags\fP);
.sp
.in
.hy
.ad
cc ... \-lpcp_pmda \-lpcp
.ft 1
.SH DESCRIPTION
.B pmdaRootConnect
initializes an IPC channel between a PCP collector process \- either a
.BR PMDA (3)
or
.BR pmcd (1)
itself \- and the
.BR pmdaroot (1)
server.
.PP
On success, the return value from
.B pmdaRootConnect
is a
.BR unix (7)
domain socket file descriptor, which can be subsequently passed to
each of the other APIs described here.
This channel can be used to perform limited privilege escalation
for specific scenarios needed by PCP collector services.
The channel is deactivated using the
.B pmdaRootShutdown
interface.
.PP
Currently, these services allow modification of one of more of a
processes namespaces via the
.BR setns (3)
system call on Linux.
This provides a facility whereby a PMDA can access and export metric
values as if it were running within a container, without the need to
actually be within the container and without the need to run as root.
.PP
A PMDA using this facility can access it in one of two ways \- either
directly, using the process identifier of another process running
in those namespaces, via
.BR pmdaEnterProcessNameSpaces ,
or indirectly, using the
.I name
of a container (which is mapped to PID one for that container,
internally, before the namespace change operation).
.BB
The
.I name
of the container is interpreted by
.BR pmdaroot (1),
which attempts to match up the specified name with one of the
implementations of containers that it is aware of (hence, the
.I name
argument is potentially interpreted differently, depending on the
container driver that claims it within
.BR pmdaroot (1)).
.PP
In the case of Docker containers, for example, a valid container
name can be the unique hash identifier, the human-readable name,
or any unique identifier substring \- this is a similar algorithm
to that used by the Docker tools themselves.
.PP
Every call to enter a namespace must be paired with a subsequent
call to leave it, returning the collector process to its original
state.
This is achieved via the
.B pmdaLeaveNameSpaces
interface.
.PP
The
.I nsflags
parameter specified the namespaces which are to be entered.
This is a bitwise OR of one of more of the namespace macros,
representing the equivalent Linux kernel namespaces of course \-
PMDA_NAMESPACE_IPC (inter-process communication names),
PMDA_NAMESPACE_UTS (system names), PMDA_NAMESPACE_NET
(network interface names), PMDA_NAMESPACE_MNT (filesystem
mount names), PMDA_NAMESPACE_USER (user account names).
.SH SEE ALSO
.BR pmcd (1),
.BR pmdaroot (1),
.BR PMDA (3),
.BR setns (3)
and
.BR unix (7).
