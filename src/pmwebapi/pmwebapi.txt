pmwebapi: a http/json binding to PMAPI, API summary

HTTP GET/POST URL patterns:

* context creation: pmNewContext

  /pmapi/context                          [done]
  /pmapi/context?hostname=STRING          [done]
  /pmapi/context?archivefile=ARCHIVE      [done]

  The result, if successful, is a application/json form: 
     { "context": NNNN }
  where the NNNN number is used in other pmwebapi URLs to identify the
  context.  Upon an error, no result is printed.

* metric metadata/listing: pmLookupName/pmLookupDesc

  /pmapi/NNNN/_metric                     [done]
  /pmapi/NNNN/_metric?prefix=NAME         [done]
  /pmapi/NNNN/_metric?pmids=ID1,ID2

  The result, if successful, is a application/json form to provide full
  metric metadata:
     { "metrics": [ 
         { "name": "foo.bar", "pmID":PPPP, "indom":DDDD,
           "type":"32", "sem":"instant", "units": "MHz",
           "text-oneline":"foo bar", "text-help":"blah blah blah"
         { "name": "foo.bar2", ... } 
         ...
     ] }
         
  where metric names are used in other pmwebapi URLs to identify the
  metric.  PMID numbers are not used.  Upon an error, no result is
  printed.

* metric value fetching: pmFetch
  These calls use pmns/metric names (URL-encoded) and/or pmids.

  /pmapi/NNNN/_fetch?names=NAME1,NAME2     [done]
  /pmapi/NNNN/_fetch?pmids=PPPP1,PPPP2     [done]

  The result, if successful, is a application/json form to provide metric
  { "timestamp": { "s":SEC, "us":USEC },
    "values": [
         { "pmid":PPPP1, "name":NAME1,
           "instances:" [
               { "instance":IIII, "value":VALUE }
          -or- { "instance":IIII, "binary":"base64value" }
          -or- { "instance":IIII, "events":[ { ... } ] }
             ...
             ] },
         { "pmid":PPPP2, "name":NAME2, ... }
         ...
     ] }
         
  In the case of a mixture of bad and good pmids/names, the good ones
  will be returned.

* metric instance metadata: pmGetInDom,pmNameInDom/pmLookupInDom
  These calls use instance names (URL-encoded) and/or instance identifiers,
  associated with instance-domain numbers or metric names.

  /pmapi/NNNN/_indom?indom=DDDD [done]
  /pmapi/NNNN/_indom?indom=DDDD,instance=IIII,JJJJ [done]
  /pmapi/NNNN/_indom?indom=DDDD,iname=INAME,INAME2 [done]
  /pmapi/NNNN/_indom?name=NAME [done]
  /pmapi/NNNN/_indom?name=NAME,instance=IIII,JJJJ [done]
  /pmapi/NNNN/_indom?name=NAME,iname=INAME,INAME2 [done]

  The result, if successful, is a application/json form to provide metric
  values:
     [{ "indom":DDDD, "instances": [ { "instance":IIII, "name":NNNN } ... ] } ...]

* metric instance profile management: pmAddProfile/pmDelProfile (pmLookupInDom)
  These calls use instance names (URL-encoded) and/or instance identifiers.

  /pmapi/NNNN/_profile_reset?
  /pmapi/NNNN/_profile_reset?indom=DDDD
  /pmapi/NNNN/_profile_add?indom=DDDD,instance=IIII,JJJJ
  /pmapi/NNNN/_profile_add?indom=DDDD,iname=IIII,JJJJ
  /pmapi/NNNN/_profile_del?indom=DDDD,instance=JJJJ
  /pmapi/NNNN/_profile_del?indom=DDDD,iname=INAME1,INAME2

* metric derivation management:

  /pmapi/NNNN/_derive?name=NAME,expr=EXPRESSION



--------------------------------------------------------------------------------

todos:

- missing APIs
- load control / attack detection (tarpot invalid webapi# pollers)
- pmReconnectContext() if pmUseContext etc. return PM_ERR_IPC || PM_ERR_TIMEOUT
- serialize webapi connection state & profile data,
            for possible restoring if pmwebapi is killed/restarted
