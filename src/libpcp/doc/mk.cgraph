#!/bin/sh
#
# Make a call graph from one routine using cscope
#
# Assumes libpcp source and cscope index are in ../src
#

tmp=/var/tmp/$$
trap "rm -f $tmp.*; exit \$sts" 0 1 2 3 15

sts=1
recursive=true
do_unlock=true
verbose=false

_usage()
{
    echo "Usage: mk.cgraph [options] function ..."
    echo "Options"
    echo "-e	ignore PM_UNLOCK (assume on error branch)"
    echo "-R	NO recursive descent"
    echo "-v	verbose"
    exit
}

while getopts "eRv?" c
do
    case $c
    in
	e)
	    # assume PM_UNLOCK is really on erro branch
	    do_unlock=false
	    ;;
	R)
	    # no recursive descent, thanks
	    recursive=false
	    ;;

	v)
	    verbose=true
	    ;;

	?)
	    _usage
	    # NOTREACHED
	    ;;
    esac
done
shift `expr $OPTIND - 1`

if [ $# -lt 1 ]
then
    _usage
    # NOTREACHED
fi

rm -f $tmp.l_libpcp	# exists when __pmLock_libpcp is locked
rm -f $tmp.l_derived	# exists when registered.mutex is locked

echo 0 >$tmp.n

_doedge()
{
    locks=''
    if [ -e $tmp.l_libpcp ]
    then
	locks=libpcp
    fi
    if [ -e $tmp.l_derived ]
    then
	if [ -z "$locks" ]
	then
	    locks=derived
	else
	    locks="$locks\\nderived"
	fi
    fi
    if [ -n "$locks" ]
    then
	n=`cat $tmp.n`
	echo `expr $n + 1` >$tmp.n
	echo "    $1_$n [label=\"$locks\",shape=box,color=red,height=0.1];"
	echo "    $1 -> $1_$n [arrowhead=none];"
	echo "    $1_$n -> $2;"
    else
	echo "    $1 -> $2;"
    fi
}

_dofunc()
{
    func=$1
    $verbose && echo >&2 $func:
    echo
    rm -f $tmp.calls
    ( cd ../src; cscope -I../include/pcp -L -2"$func" ) >$tmp.tmp 2>$tmp.err
    if [ -s $tmp.err ]
    then
	echo "Unexpected errors from cscope(1) ..."
	cat $tmp.err
	echo "... skipping $func"
	continue
    fi

    # expecting lines like this from cscope(1) ...
    # access.c PM_LOCK 1274 PM_LOCK(__pmLock_libpcp);
    # access.c getmyhostid 1276 getmyhostid();
    # access.c PM_UNLOCK 1280 PM_UNLOCK(__pmLock_libpcp);
    #

    sed <$tmp.tmp \
	-e 's/;$/ ;/' \
    | awk '
$2 == "PM_INIT_LOCKS"	{ next }
$2 == "PM_TPD"		{ next }
$2 == "PM_LOCK"		{ print $4; next }
$2 == "PM_UNLOCK"	{ print $4; next }
			{ # omit repeated function calls
			  if (seen[$2] == 1) next
			  seen[$2] = 1
			  print $2
			}' \
    | sed \
	-e '/LOCK(/{
s/PM_//
s/(/ /
s/)//
}' \
    | while read calls param
    do
	case "$calls"
	in
	    LOCK)
		echo "    #LOCK $param"
		case "$param"
		in
		    __pmLock_libpcp)
			touch $tmp.l_libpcp
			;;
		    registered.mutex)
			touch $tmp.l_derived
			;;
		    *)
			echo >&2 "Bad LOCK: $param"
			exit
			;;
		esac
		continue
		;;

	    UNLOCK)
		if $do_unlock
		then
		    echo "    #UNLOCK $param"
		    case "$param"
		    in
			__pmLock_libpcp)
			    rm -f $tmp.l_libpcp
			    ;;
			registered.mutex)
			    rm -f $tmp.l_derived
			    ;;
			*)
			    echo >&2 "Bad UNLOCK: $param"
			    exit
			    ;;
		    esac
		else
		    echo "    #UNLOCK $param ... ignored due to -e"
		fi
		continue
		;;

	esac

	if grep "^$calls\$" glibc.safe >/dev/null
	then
	    # glibc, thread-safe
	    echo "    $calls [fontcolor=blue,color=blue,style=filled,fillcolor=\"lightgrey\"];"
	    _doedge $func $calls
	elif grep "^$calls\$" posix.unsafe >/dev/null
	then
	    # posix, not thread-safe
	    echo "    $calls [fontcolor=red,color=red,style=filled,fillcolor=\"lightgrey\"];"
	    _doedge $func $calls
	elif grep "^$calls\$" glibc.unsafe >/dev/null
	then
	    # glibc, not thread-safe
	    echo "    $calls [fontcolor=red,color=red,style=filled,fillcolor=\"lightgrey\"];"
	    _doedge $func $calls
	else
	    # assumed to be in libpcp
	    _doedge $func $calls
	    echo $calls >>$tmp.calls
	fi
    done
}

rm -f $tmp.done
for i
do
    echo $i >>$tmp.todo
done

while [ -s $tmp.todo ]
do
    func=`head -1 $tmp.todo`
    _dofunc $func
    $recursive || break
    echo $func >>$tmp.done
    sed -e 1d <$tmp.todo >$tmp.tmp
    mv $tmp.tmp $tmp.todo
    if [ -s $tmp.calls ]
    then
	# some libpcp calls from here
	for calls in `cat $tmp.calls`
	do
	    if grep "^$calls\$" <$tmp.done >/dev/null
	    then
		# already done
		:
	    elif grep "^$calls\$" <$tmp.todo >/dev/null
	    then
		# already pending
		:
	    else
		echo $calls >>$tmp.todo
	    fi
	done
    fi
done

sts=0
