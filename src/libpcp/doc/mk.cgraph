#!/bin/sh
#
# Make a call graph from one routine using cscope
#
# Assumes libpcp source and cscope index are in ../src
#

tmp=/var/tmp/$$
trap "rm -f $tmp.*; exit \$sts" 0 1 2 3 15

sts=1
recursive=true
oflag=false
verbose=false

_usage()
{
    echo "Usage: mk.cgraph [options] function ..."
    echo "Options"
    echo "-o    omit external thread-safe routines"
    echo "-R	NO recursive descent"
    echo "-v	verbose"
    exit
}

while getopts "oRv?" c
do
    case $c
    in
	o)
	    oflag=true
	    ;;

	R)
	    # no recursive descent, thanks
	    recursive=false
	    ;;

	v)
	    verbose=true
	    ;;

	?)
	    _usage
	    # NOTREACHED
	    ;;
    esac
done
shift `expr $OPTIND - 1`

if [ $# -lt 1 ]
then
    _usage
    # NOTREACHED
fi

_dofunc()
{
    func=$1
    $verbose && echo >&2 $func:
    rm -f $tmp.calls $tmp.output
    ( cd ../src; cscope -I../include/pcp -L -2"$func" ) >$tmp.tmp 2>$tmp.err
    if [ -s $tmp.err ]
    then
	echo >&2 "Unexpected errors from cscope(1) ..."
	cat >&2 $tmp.err
	echo >&2 "... skipping $func"
	continue
    fi

    # expecting lines like this from cscope(1) ...
    # access.c PM_LOCK 1274 PM_LOCK(__pmLock_libpcp);
    # access.c getmyhostid 1276 getmyhostid();
    # access.c PM_UNLOCK 1280 PM_UNLOCK(__pmLock_libpcp);
    #
    rm -f $tmp.locks

    sed <$tmp.tmp \
	-e 's/;$/ ;/' \
    | awk '
$2 == "PM_INIT_LOCKS"	{ next }
$2 == "PM_TPD"		{ next }
$2 == "defined"		{ next }	# cscope botch on #if defined()?
$2 == "PM_UNLOCK"	{ next }
$2 == "PM_LOCK"		{ print $4; next }
			{ # omit repeated function calls
			  if (seen[$2] == 1) next
			  seen[$2] = 1
			  print $2
			}' \
    | sed \
	-e '/LOCK(/{
s/PM_//
s/(/ /
s/)//
}' \
    | while read calls param
    do
	case "$calls"
	in
	    LOCK)
		echo "    #LOCK $param"
		touch $tmp.output
		case "$param"
		in
		    __pmLock_libpcp)
			echo libpcp >>$tmp.locks
			;;
		    registered.mutex)
			echo derived >>$tmp.locks
			;;
		    *)
			echo >&2 "Bad LOCK: $param"
			exit
			;;
		esac
		continue
		;;

	esac

	if grep "^$calls\$" glibc.safe >/dev/null
	then
	    # glibc, thread-safe
	    if $oflag
	    then
		# do not include thread-safe routines in graph
		:
	    else
		echo "    $calls [fontcolor=blue,color=blue,style=filled,fillcolor=\"lightgrey\"];"
		echo "    $func -> $calls;"
		touch $tmp.output
	    fi
	elif grep "^$calls\$" posix.unsafe >/dev/null
	then
	    # posix, not thread-safe
	    echo "    $calls [fontcolor=red,color=red,style=filled,fillcolor=\"lightgrey\"];"
	    echo "    $func -> $calls;"
	    touch $tmp.output
	elif grep "^$calls\$" glibc.unsafe >/dev/null
	then
	    # glibc, not thread-safe
	    echo "    $calls [fontcolor=red,color=red,style=filled,fillcolor=\"lightgrey\"];"
	    echo "    $func -> $calls;"
	    touch $tmp.output
	else
	    # assumed to be in libpcp
	    echo "    $func -> $calls;"
	    touch $tmp.output
	    echo $calls >>$tmp.calls
	fi
    done

    if [ -s $tmp.locks ]
    then
	echo "    $func [label=\"$func\\\\n`sort <$tmp.locks | uniq | tr '[\012]' '[ ]' | sed -e 's/ /\\\\n/g' -e 's/\\\\n\$//'`\",shape=box,fontcolor=red,color=red];"
    fi

    [ -f $tmp.output ] && echo

}

rm -f $tmp.done
for i
do
    echo $i >>$tmp.todo
done

while [ -s $tmp.todo ]
do
    func=`head -1 $tmp.todo`
    _dofunc $func
    $recursive || break
    echo $func >>$tmp.done
    sed -e 1d <$tmp.todo >$tmp.tmp
    mv $tmp.tmp $tmp.todo
    if [ -s $tmp.calls ]
    then
	# some libpcp calls from here
	for calls in `cat $tmp.calls`
	do
	    if grep "^$calls\$" <$tmp.done >/dev/null
	    then
		# already done
		:
	    elif grep "^$calls\$" <$tmp.todo >/dev/null
	    then
		# already pending
		:
	    else
		echo $calls >>$tmp.todo
	    fi
	done
    fi
done

sts=0
