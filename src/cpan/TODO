Getting to a basic working state
--------------------------------

o  Need to devise a way to plug into pmdaGetOpt(3) and be good citizens
   in the PMDA command line argument handling world.  Note: -d is debug
   mode in Perl, but domain number in the PMDA world.  D'oh.

o  Add a PCP::PMDA->log() routine, simple interface to __pmNotifyErr();

o  Fully investigate Perl<->C value conversion used in the fetch callback
	- probably some lurking issues here (32/u32/64/u64,etc);
	- works for the simple cases I've used so far (see pmdasimple.pl
	  and the less-than-useful pmdanews.pl);
	- to test this exhaustively, we should build a Perl pmdasample
	  and then run the PCP QA suite against it;

o  Figure out whether cvalue.c in the "make test" step is going to
   pick up any problems, and if so figure out how to get the binary
   built as part of the "make test" step (remove current hack, should
   generate a target from Makefile.PL);

o  Use PerlPOD(1) directives in the PCP::PMDA module to interface to
   perldoc(1) - discuss the Perl routines where we have extended or
   changed the semantics of the equivalent libpcp_pmda functionality
   especially; but in most routines simply refer to PMDA(3).

o  Many Perl PMDAs will want to have an interface that allows them to
   get hold of the last data written to a file, as it is written there
   (ala. tail -f).  So, need to implement this missing pieces of the
   MODE_TAIL (see PMDA.xs comments).
 
o  Need an atexit(3) handler to pclose MODE_PIPE processes.

o  Need an add_timer() interface, see PMDA.xs comments.

o  Need POD updates to document all APIs.


More interesting stuff
----------------------

o  Extend the PCP::PMDA->add_metric() routine to allow help text and
   metric name to be passed in
	- this would allow us to generate help files and pmns files
	  automagically;
	- would prevent the way we replicate PMID data in two places
	  (currently PMDA binary and PMNS must agree on all of the
	  PMID except for the domain number part);
	- an alternative to generating external files would be to
	  investigate the way libpcp_pmda interfaces to the help/
	  pmns files and see whether we can do this ourselves;
	- this may turn out to be optimal, may not, but would
	  simplify PMDA development & maintenance;
	- see also `database interfaces' below;

o  Add routine(s) to PCP::PMDA module which take over functionality
   currently performed by the Install and Remove scripts?
	- might be possible to have a single Perl script do
	  everything that currently requires multiple scripts &
	  numerous files;
	- in this case, /var/pcp/pmdas/*/Makefile would no longer
	  be necessary and README could go away too since POD
	  would be a better and more appropriate  way to do this
	  (would also get out of README<->man page mismatch
	  problems altogether)
	- In this case, point one of this doc may be invalidated
	  and we don't need to grok the standard command line
	  args (no help file?) ... or allow both?


Even more interesting stuff
---------------------------

o  database interfaces
	- If we can pass in the metric name to PCP::PMDA->add_metric,
	  then we may be able to do tricky things in the fun-filled
	  world of database monitoring (these tend to use metric
	  names with embedded database names, e.g. oracle.BOB.locks)
	  which requires the pmns file to be post-processed currently
	  (yuk!) ... would be able to cleanly resolve this;
	- we should be able to use DBI to hide the changing database 
	  client libraries, hiding different binary formats, etc.

o  generic database ping PMDA
	- We've traditionally had separate oraping, sybping,
	  infmxping, etc PMDAs to measure database availability 
	  and response - dbpingpmda/dbprobe are an initial stab
	  at providing a unified database response time measure
	  PMDA

o  generic SNMP PMDA
	- might be an idea to have an easily modified snmppmda
	  which could be easily configured to import arbitrary
	  SNMP data using the perl SNMP module

