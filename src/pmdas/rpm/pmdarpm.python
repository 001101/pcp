'''
Python implementation of the "rpm" Performance Metrics Domain Agent.
'''
#
# Copyright (c) 2013 Red Hat.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#

from subprocess import Popen, PIPE, STDOUT
from threading import Thread
from posixpath import getmtime
import rpm
from ctypes import c_int, POINTER, cast
import cpmapi as c_api
from pcp.pmda import PMDA, pmdaMetric, pmdaIndom
from pcp.pmapi import pmUnits, pmContext as PCP


class setup_indom(Thread):
    '''
    Thread to create an indom whose components are the current rpm package list
    '''

    def __init__(self, pmda, name):
        Thread.__init__(self)
        self.pmda = pmda
        self.name = name

    def run(self):
        package_list = self.pmda.rpm_handle.dbMatch()
        rpms = {}
        i = 0
        replace_indom = False

        # Get current package list
        for package in package_list:
            if replace_indom == False and package not in rpms:
                replace_indom = True
            rpms[package['name']] = c_int(i)
            i += 1

        # Rebuild if a package was added or a package was removed
        if replace_indom == True or len(rpms) != len(self.pmda.rpms_by_n):
            self.pmda.log("Updated indom with " + str(i) + " packages")
            self.pmda.replace_indom(self.pmda.source_indom, rpms)

            for (k, v) in rpms.iteritems():
                nv = int (v.value)
                self.pmda.rpms_by_n[nv] = k


class RpmPMDA(PMDA):
    '''
    A Performance Metrics Domain Agent for rpm metrics.
    '''

    source = {}
    state = {}

    # rpm.numfetch properties
    numfetch = 0
    oldfetch = -1


    rpm_metrics = (
#        Name, Cluster, Item (assigned), Tag from rpm.py
        ['.name', 0, 0, "RPMTAG_NAME"], \
        ['.sourcerpm', 0, 0, "RPMTAG_SOURCERPM"], \
        ['.summary', 0, 0, "RPMTAG_SUMMARY"], \
        ['.size', 0, 0, "RPMTAG_SIZE"], \
        ['.description', 0, 0, "RPMTAG_DESCRIPTION"], \
        ['.arch', 0, 0, "RPMTAG_ARCH"], \
        ['.release', 0, 0, "RPMTAG_RELEASE"], \
        ['.version', 0, 0, "RPMTAG_VERSION"], \
        ['.url', 0, 0, "RPMTAG_URL"], \
        ['.basenames', 0, 0, "RPMTAG_BASENAMES"], \
        ['.dirnames', 0, 0, "RPMTAG_DIRNAMES"], \
        ['.distribution', 0, 0, "RPMTAG_DISTRIBUTION"], \
        ['.evr', 0, 0, "RPMTAG_EVR"], \
        ['.group', 0, 0, "RPMTAG_GROUP"], \
        ['.list', 0, 0, "RPMTAG_FILENAMES"], \
        ['.instfilenames', 0, 0, "RPMTAG_INSTFILENAMES"], \
        ['.license', 0, 0, "RPMTAG_LICENSE"], \
        ['.platform', 0, 0, "RPMTAG_PLATFORM"], \
        ['.obsoletes', 0, 0, "RPMTAG_OBSOLETES"], \
        ['.provides', 0, 0, "RPMTAG_PROVIDES"], \
        ['.requires', 0, 0, "RPMTAG_REQUIRES"], \
        ['.buildtime', 0, 0, "RPMTAG_BUILDTIME"], \
        ['.file.class', 9, 0, "RPMTAG_FILECLASS"], \
        ['.file.linktos', 9, 0, "RPMTAG_FILELINKTOS"], \
        ['.file.names', 9, 0, "RPMTAG_FILENAMES"], \
        ['.file.md5s', 9, 0, "RPMTAG_FILEMD5S"], \
        ['.file.modes', 9, 0, "RPMTAG_FILEMODES"], \
        ['.file.require', 9, 0, "RPMTAG_FILEREQUIRE"], \
        ['.file.sizes', 9, 0, "RPMTAG_FILESIZES"], \
    )
    def rpm_instance(self, serial):
        '''
        Called once per instance request; to check if package list has changed.
        '''

        # Wait on setup_indom thread if it is actively updating the indom
        if self.updating_indom == True:
            self.indom_thread.join()
            self.updating_indom = False

        # If the rpm database has changed then reload the package list
        rpmdb_mtime = getmtime("/var/lib/rpm/Packages")
        if (self.rpmdb_mtime != rpmdb_mtime):
            self.rpmdb_mtime = rpmdb_mtime
            self.updating_indom = True
            self.indom_thread = setup_indom(self, self.myname)
            self.indom_thread.start()


    def rpm_fetch_callback(self, cluster, item, inst):
        '''
        Main fetch callback
        Get metric rpm.cluster.item for instance inst;
        e.g. get the filename list (.list) for the python instance
        '''

        qtype = ""
        # Get the metric rpm.cluster.item
        for m in self.rpm_metrics:
            if (cluster == m[1] and item == m[2]):
                qtype = m[3]
        if len(qtype) == 0:
            return [c_api.PM_ERR_PMID, 0]

        instp = self.inst_lookup(self.source_indom, inst)
        if (instp == None)
            return [c_api.PM_ERR_INST, 0]
        valuep = cast(instp, POINTER(c_int))
        try:
            rpm_name = self.rpms_by_n[valuep.contents.value]
        except KeyError:
            self.log("Key %s/%#x not in rpms list %s/%s/%s" % (str(instp.value),valuep.contents.value,str(cluster),str(item),str(inst)))
            return [c_api.PM_ERR_INST, 0]

        # Get the metric for this inst
        package_list = self.rpm_handle.dbMatch('name', rpm_name)
        for package in package_list:
            metric_value = str(package[eval("rpm." + qtype)])

        return [metric_value, 1]


    def __init__(self, name, domain):
        PMDA.__init__(self, name, domain)

        self.configfile = PCP.pmGetConfig('PCP_PMDAS_DIR')
        self.configfile += '/' + name + '/' + name + '.conf'

        self.source_indom = self.indom(0)
        self.add_indom(pmdaIndom(self.source_indom, self.source))

        self.myname = name
        self.rpm_handle = rpm.TransactionSet()

        self.rpmdb_mtime = getmtime("/var/lib/rpm/Packages")
        self.rpms_by_n = {}
        self.indom_thread = setup_indom(self, name)
        self.updating_indom = True
        self.indom_thread.start()

        cluster = -1
        for m in self.rpm_metrics:
            if cluster != m[1]:
                cluster = m[1]
                item = 0
            item += 1
            m[2] = item
            self.add_metric(name + m[0], pmdaMetric(self.pmid(cluster, item), \
                                                    c_api.PM_TYPE_STRING, self.source_indom, \
                                                    c_api.PM_SEM_INSTANT, pmUnits(0, 0, 0, 0, 0, 0)))

        self.set_instance(self.rpm_instance)
        self.set_fetch_callback(self.rpm_fetch_callback)
        self.set_user(PCP.pmGetConfig('PCP_USER'))


if __name__ == '__main__':

    RpmPMDA('rpm', 255).run()
