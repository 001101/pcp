'''
Performance Metrics Domain Agent exporting Gluster filesystem metrics.
'''
#
# Copyright (c) 2013 Red Hat.
# 
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
# 

import cpmapi as c_api
from pcp.pmapi import pmUnits
from pcp.pmda import PMDA, pmdaMetric, pmdaIndom
from ctypes import c_int, POINTER, cast, Structure
from socket import getfqdn
from os import getenv

VOL_LIST_COMMAND = 'gluster --xml volume list'
VOL_PROFILE_COMMAND = 'gluster --xml volume profile %s'

FILEOPS = [    # append only, do not change the order (changes PMID)
    'ACCESS', 'CREATE', 'DISCARD', 'ENTRYLK', 'FALLOCATE', 'FENTRYLK',
    'FGETXATTR', 'FINODELK', 'FLUSH', 'FREMOVEXATTR', 'FSETATTR',
    'FSETXATTR', 'FSTAT', 'FSYNC', 'FSYNCDIR', 'FTRUNCATE', 'FXATTROP',
    'GETSPEC', 'GETXATTR', 'INODELK', 'LINK', 'LK', 'LOOKUP', 'MKDIR',
    'MKNOD', 'OPEN', 'OPENDIR', 'RCHECKSUM', 'READDIR', 'READDIRP',
    'READLINK', 'READV', 'REMOVEXATTR', 'RENAME', 'RMDIR', 'SETATTR',
    'SETXATTR', 'STAT', 'STATFS', 'SYMLINK', 'TRUNCATE', 'UNLINK',
    'WRITEV', 'XATTROP',
]
LATENCY_STATS_COUNT = len(FILEOPS) * 4	# (avg,min,max,count)

class GlusterBrickLatencies(Structure):
    ''' 2D array of latecy stats (avg,min,max,count) vs file operation '''
    _fields_ = [("values", c_int * LATENCY_STATS_COUNT)]

class GlusterPMDA(PMDA):
    '''
    Performance Metrics Domain Agent exporting gluster brick metrics.
    Install it and make basic use of it if you use glusterfs, as follows:

    # $PCP_PMDAS_DIR/gluster/Install
    $ pminfo -fmdtT gluster
    '''

    # restrict to local volumes/bricks
    hostname = getfqdn()

    # volumes and bricks instance domains
    volumes = {}
    bricks = {}

    def gluster_refresh(self):
        ''' Refresh the values and instances for gluster volumes and bricks '''
        # run: self.vol_list 
        # run: self.vol_profile


    def gluster_instance(self, serial):
        ''' Called once per "instance request" PDU '''
        self.log("instance update for %d" % serial)
        if (serial == 0 or serial == 1):
            self.gluster_fetch()

    def gluster_fetch(self):
        ''' Called once per "fetch" PDU '''
        self.log("fetching values")
        self.bricks.clear()
        self.volumes.clear()
        self.gluster_refresh()
        self.replace_indom(self.brick_indom, self.bricks)
        self.replace_indom(self.volume_indom, self.volumes)


    def gluster_fetch_latency_callback(self, item, inst):
        '''
        Returns a list of value,status (single pair) for latency cluster
        Helper for the fetch callback
        '''
        if (item >= 0 and item < LATENCY_STATS_COUNT):
            voidp = self.inst_lookup(self.brick_indom, inst)
            if (voidp == None):
                return [c_api.PM_ERR_INST, 0]
            valuep = cast(voidp, POINTER(GlusterBrickLatencies))
            return [valuep.contents.value.values[item], 1]
        return [c_api.PM_ERR_PMID, 0]

    def gluster_fetch_volumes_callback(self, item, inst):
        '''
        Returns a list of value,status (single pair) for volumes cluster
        Helper for the fetch callback
        '''
        if (item == 0):
            voidp = self.inst_lookup(self.volumes_indom, inst)
            if (voidp == None):
                return [c_api.PM_ERR_INST, 0]
            valuep = cast(voidp, POINTER(c_int))
            return [valuep.contents.value, 1]
        return [c_api.PM_ERR_PMID, 0]

    def gluster_fetch_callback(self, cluster, item, inst):
        '''
        Main fetch callback, defers to helpers for each cluster.
        Returns a list of value,status (single pair) for requested pmid/inst
        '''
        self.log("fetch callback for %d.%d[%d]" % (cluster, item, inst))
        if (cluster == 0):
            return self.gluster_fetch_latency_callback(item, inst)
        elif (cluster == 1):
            return self.gluster_fetch_volumes_callback(item, inst)
        return [c_api.PM_ERR_PMID, 0]


    def gluster_store_volume_callback(self, inst, val):
        ''' Helper for the store callback, volume profile enabling/disabling '''
        sts = 0
        namep = self.name_lookup(self.volumes_indom, inst)
        if (namep == None):
            sts = c_api.PM_ERR_INST
        elif (val < 0):
            sts = c_api.PM_ERR_SIGN
        elif (val == 0):
            self.log("disable: %s %s stop" % (self.vol_profile, namep))
            command = self.vol_profile + ' ' + namep + ' stop'
            process.call(command, shell=True)
        else:
            self.log("enable: %s %s start" % (self.vol_profile, namep))
            command = self.vol_profile + ' ' + namep + ' start'
            process.call(command, shell=True)
        return sts

    def gluster_store_callback(self, cluster, item, inst, val):
        '''
        Store callback, executed when a request to write to a metric happens
        Defers to helpers for each storable metric.  Returns a single value.
        '''
        self.log("store callback for %d.%d[%d]" % (cluster, item, inst))
        if (cluster == 1 and item == 0):
            return self.gluster_store_volume_callback(inst, val)
        elif (cluster == 0):
            return c_api.PM_ERR_PERMISSION
        return c_api.PM_ERR_PMID


    def __init__(self, name, domain):
        PMDA.__init__(self, name, domain)

        self.vol_list = getenv('GLUSTER_VOL_LIST', VOL_LIST_COMMAND)
        self.vol_profile = getenv('GLUSTER_VOL_PROFILE', VOL_PROFILE_COMMAND)

        self.brick_indom = self.indom(0)
        self.add_indom(pmdaIndom(self.brick_indom, self.bricks))

        self.volume_indom = self.indom(1)
        self.add_indom(pmdaIndom(self.volume_indom, self.volumes))

        self.add_metric(name + '.brick.read_bytes', pmdaMetric(self.pmid(0, 0),
                c_api.PM_TYPE_U64, self.brick_indom, c_api.PM_SEM_COUNTER,
                pmUnits(1, 0, 0, c_api.PM_SPACE_BYTE, 0, 0)))
        self.add_metric(name + '.brick.write_bytes', pmdaMetric(self.pmid(0, 1),
                c_api.PM_TYPE_U64, self.brick_indom, c_api.PM_SEM_COUNTER,
                pmUnits(1, 0, 0, c_api.PM_SPACE_BYTE, 0, 0)))

        item = 2
        for fileop in FILEOPS:
            metricname = name + '.brick.latency.' + fileop.lower()
            self.add_metric(metricname + '.avg', pmdaMetric(self.pmid(0, item),
                    c_api.PM_TYPE_FLOAT, self.brick_indom, c_api.PM_SEM_INSTANT,
                    pmUnits(0, 1, 0, 0, c_api.PM_TIME_USEC, 0)))
            item += 1
            self.add_metric(metricname + '.min', pmdaMetric(self.pmid(0, item),
                    c_api.PM_TYPE_U64, self.brick_indom, c_api.PM_SEM_INSTANT,
                    pmUnits(0, 1, 0, 0, c_api.PM_TIME_USEC, 0)))
            item += 1
            self.add_metric(metricname + '.max', pmdaMetric(self.pmid(0, item),
                    c_api.PM_TYPE_U64, self.brick_indom, c_api.PM_SEM_INSTANT,
                    pmUnits(0, 1, 0, 0, c_api.PM_TIME_USEC, 0)))
            item += 1
            self.add_metric(metricname + '.count', pmdaMetric(self.pmid(0, item),
                    c_api.PM_TYPE_U64, self.brick_indom, c_api.PM_SEM_INSTANT,
                    pmUnits(0, 1, 0, 0, c_api.PM_TIME_USEC, 0)))
            item += 1

        self.add_metric(name + '.volume.control', pmdaMetric(self.pmid(1, 0),
                c_api.PM_TYPE_32, self.volume_indom, c_api.PM_SEM_INSTANT,
                pmUnits(0, 0, 0, 0, 0, 0)))

        self.set_fetch(self.gluster_fetch)
        self.set_instance(self.gluster_instance)
        self.set_fetch_callback(self.gluster_fetch_callback)
        self.set_store_callback(self.gluster_store_callback)


if __name__ == '__main__':
    GlusterPMDA('gluster', 118).run()
