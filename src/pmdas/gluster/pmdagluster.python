'''
Performance Metrics Domain Agent exporting Gluster filesystem metrics.
'''
#
# Copyright (c) 2013 Red Hat.
# 
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
# 

import cpmapi as c_api
from pcp.pmapi import pmUnits
from pcp.pmda import PMDA, pmdaMetric, pmdaIndom
from ctypes import c_int, c_long, c_float, POINTER, cast, Structure
import xml.etree.cElementTree as xmltree
from os import getenv
import subprocess

VOL_LIST_COMMAND = 'gluster --xml volume info'
VOL_PROFILE_COMMAND = 'gluster --xml volume profile %s'

FILEOPS = [    # append only, do not change the order (changes PMID)
    'ACCESS', 'CREATE', 'DISCARD', 'ENTRYLK', 'FALLOCATE', 'FENTRYLK',
    'FGETXATTR', 'FINODELK', 'FLUSH', 'FREMOVEXATTR', 'FSETATTR',
    'FSETXATTR', 'FSTAT', 'FSYNC', 'FSYNCDIR', 'FTRUNCATE', 'FXATTROP',
    'GETSPEC', 'GETXATTR', 'INODELK', 'LINK', 'LK', 'LOOKUP', 'MKDIR',
    'MKNOD', 'OPEN', 'OPENDIR', 'RCHECKSUM', 'READDIR', 'READDIRP',
    'READLINK', 'READV', 'REMOVEXATTR', 'RENAME', 'RMDIR', 'SETATTR',
    'SETXATTR', 'STAT', 'STATFS', 'SYMLINK', 'TRUNCATE', 'UNLINK',
    'WRITEV', 'XATTROP',
]
FILEOPS_INDICES = {}

class GlusterVolume(Structure):
    ''' Statistic values per-gluster-volume (volume indom cache lookup) '''
    _fields_ = [("distCount", c_int),
                ("stripeCount", c_int),
                ("replicaCount", c_int),
                ("fopHitsEnabled", c_int),
                ("latencyEnabled", c_int)]

class GlusterBrick(Structure):
    ''' Statistic values per-gluster-brick, within a volume (brick indom) '''
    _fields_ = [("avgtime", c_float * len(FILEOPS)),
                ("mintime", c_long * len(FILEOPS)),
                ("maxtime", c_long * len(FILEOPS)),
                ("hits", c_long * len(FILEOPS)),
                ("read_bytes", c_long),
                ("write_bytes", c_long)]

class GlusterPMDA(PMDA):
    '''
    Performance Metrics Domain Agent exporting gluster brick metrics.
    Install it and make basic use of it if you use glusterfs, as follows:

    # $PCP_PMDAS_DIR/gluster/Install
    $ pminfo -fmdtT gluster
    '''

    # volumes and bricks instance domains
    volumes = {}
    bricks = {}

    def runVolumeInfo(self):
        ''' Execute the gluster volume info command to extract volume names '''
        process = subprocess.Popen(self.vol_list, shell = True,
                                   stdout = subprocess.PIPE, stderr = None)
        out, err = process.communicate()
        return xmltree.fromstring(out)

    def runVolumeProfileInfo(self, volume):
        ''' Execute the gluster volume profile command for a given volume '''
        command = self.vol_profile + ' ' + volume + ' info'
        process = subprocess.Popen(command, shell = True,
                                   stdout = subprocess.PIPE, stderr = None)
        out, err = process.communicate()
        return xmltree.fromstring(out)

    def parseVolumeInfo(self, xml):
        ''' Extract the set of volume names from given gluster XML string '''
        volumes = []
        for volxml in xml.findall('volInfo/volumes'):
            volname = volxml.find('volume/name').text
            volumes.append(volname)
            volume = GlusterVolume()
            volume.distCount = int(volxml.find('volume/distCount').text)
            volume.stripeCount = int(volxml.find('volume/stripeCount').text)
            volume.replicaCount = int(volxml.find('volume/replicaCount').text)
            volume.fopsEnabled = 0
            volume.latencyEnabled = 0
            for option in volxml.findall('volume/options/option'):
                optionName = option.find('name').text
                if (optionName == 'diagnostics.count-fop-hits' and
                    (option.find('value').text == 'on')):
                    volume.fopsEnabled = 1
                if (optionName == 'diagnostics.latency-measurement' and
                    (option.find('value').text == 'on')):
                    volume.latencyEnabled = 1
            self.volumes[volname] = volume	# prepare the volume indom cache
        return volumes

    def parseVolumeProfileInfo(self, volume, xml):
        ''' Extract the metric values from a given gluster profile string '''
        # self.log('Volume: %s' % (volume))
        for brickxml in xml.findall('volProfile/brick'):
            brickname = brickxml.find('brickName').text
            # self.log('Brick: %s' % (brickname))
            brick = GlusterBrick()
            for fileop in brickxml.findall('cumulativeStats/fopStats/fop'):
                name = fileop.find('name').text.lower()
                fop = FILEOPS_INDICES[name]
                brick.hits[fop] = long(fileop.find('hits').text)
                brick.avgtime[fop] = float(fileop.find('avgLatency').text)
                brick.mintime[fop] = long(float(fileop.find('minLatency').text))
                brick.maxtime[fop] = long(float(fileop.find('maxLatency').text))
            brick.read_bytes = long(brick.find('cumulativeStats/totalRead').text)
            brick.write_bytes = long(brick.find('cumulativeStats/totalWrite').text)
            self.bricks[brickname] = brick	# prepare the bricks indom cache


    def gluster_refresh(self):
        ''' Refresh the values and instances for gluster volumes and bricks '''
        xml = self.runVolumeInfo()
        if (xml != None):
            for vol in self.parseVolumeInfo(xml):
                self.log("runVolumeProfileInfo on %s" % (vol))
                xml = self.runVolumeProfileInfo(vol)
                if (xml != None):
                    self.parseVolumeProfileInfo(vol, xml)

    def gluster_instance(self, serial):
        ''' Called once per "instance request" PDU '''
        self.log("instance update for %d" % serial)
        if (serial == 0 or serial == 1):
            self.gluster_fetch()

    def gluster_fetch(self):
        ''' Called once per "fetch" PDU '''
        self.log("fetching values")
        self.bricks.clear()
        self.volumes.clear()
        self.gluster_refresh()
        self.replace_indom(self.brick_indom, self.bricks)
        self.replace_indom(self.volume_indom, self.volumes)


    def gluster_fetch_latency_callback(self, item, inst):
        '''
        Returns a list of value,status (single pair) for latency cluster
        Helper for the fetch callback
        '''
        if (item < 0):
            return [c_api.PM_ERR_PMID, 0]
        voidp = self.inst_lookup(self.brick_indom, inst)
        if (voidp == None):
            return [c_api.PM_ERR_INST, 0]
        cache = cast(voidp, POINTER(GlusterBrick))
        brick = cache.contents.value

        if (item == 0):
            return [brick.read_bytes, 1]
        elif (item == 1):
            return [brick.write_bytes, 1]
        elif (item == 2):
            return [brick.avgtime[(item - 2) % len(FILEOPS)], 1]
        elif (item == 3):
            return [brick.mintime[(item - 2) % len(FILEOPS)], 1]
        elif (item == 4):
            return [brick.maxtime[(item - 2) % len(FILEOPS)], 1]
        elif (item == 5):
            return [brick.hits[item % len(FILEOPS)], 1]
        return [c_api.PM_ERR_PMID, 0]

    def gluster_fetch_volumes_callback(self, item, inst):
        '''
        Returns a list of value,status (single pair) for volumes cluster
        Helper for the fetch callback
        '''
        if (item < 0 or item > 3):
            return [c_api.PM_ERR_PMID, 0]
        voidp = self.inst_lookup(self.volumes_indom, inst)
        if (voidp == None):
            return [c_api.PM_ERR_INST, 0]
        cached = cast(voidp, POINTER(GlusterVolume))
        volume = cached.contents.value
        if (item == 0):
            enabled = volume.fopHitsEnabled
            if (enabled):
                enabled = volume.latencyEnabled
            return [enabled, 1]
        elif (item == 1):
            return [volume.distCount, 1]
        elif (item == 2):
            return [volume.stripeCount, 1]
        elif (item == 3):
            return [volume.replicaCount, 1]
        return [c_api.PM_ERR_PMID, 0]

    def gluster_fetch_callback(self, cluster, item, inst):
        '''
        Main fetch callback, defers to helpers for each cluster.
        Returns a list of value,status (single pair) for requested pmid/inst
        '''
        self.log("fetch callback for %d.%d[%d]" % (cluster, item, inst))
        if (cluster == 0):
            return self.gluster_fetch_latency_callback(item, inst)
        elif (cluster == 1):
            return self.gluster_fetch_volumes_callback(item, inst)
        return [c_api.PM_ERR_PMID, 0]


    def gluster_store_volume_callback(self, inst, val):
        ''' Helper for the store callback, volume profile enabling/disabling '''
        sts = 0
        namep = self.name_lookup(self.volumes_indom, inst)
        if (namep == None):
            sts = c_api.PM_ERR_INST
        elif (val < 0):
            sts = c_api.PM_ERR_SIGN
        elif (val == 0):
            self.log("disable: %s %s stop" % (self.vol_profile, namep))
            command = self.vol_profile + ' ' + namep + ' stop'
            process.call(command, shell=True)
        else:
            self.log("enable: %s %s start" % (self.vol_profile, namep))
            command = self.vol_profile + ' ' + namep + ' start'
            process.call(command, shell=True)
        return sts

    def gluster_store_callback(self, cluster, item, inst, val):
        '''
        Store callback, executed when a request to write to a metric happens
        Defers to helpers for each storable metric.  Returns a single value.
        '''
        self.log("store callback for %d.%d[%d]" % (cluster, item, inst))
        if (cluster == 1 and item == 0):
            return self.gluster_store_volume_callback(inst, val)
        elif (cluster == 0):
            return c_api.PM_ERR_PERMISSION
        return c_api.PM_ERR_PMID


    def __init__(self, name, domain):
        PMDA.__init__(self, name, domain)

        self.vol_list = getenv('GLUSTER_VOL_LIST', VOL_LIST_COMMAND)
        self.vol_profile = getenv('GLUSTER_VOL_PROFILE', VOL_PROFILE_COMMAND)

        self.brick_indom = self.indom(0)
        self.add_indom(pmdaIndom(self.brick_indom, self.bricks))

        self.volume_indom = self.indom(1)
        self.add_indom(pmdaIndom(self.volume_indom, self.volumes))

        self.add_metric(name + '.brick.read_bytes', pmdaMetric(self.pmid(0, 0),
                c_api.PM_TYPE_U64, self.brick_indom, c_api.PM_SEM_COUNTER,
                pmUnits(1, 0, 0, c_api.PM_SPACE_BYTE, 0, 0)))
        self.add_metric(name + '.brick.write_bytes', pmdaMetric(self.pmid(0, 1),
                c_api.PM_TYPE_U64, self.brick_indom, c_api.PM_SEM_COUNTER,
                pmUnits(1, 0, 0, c_api.PM_SPACE_BYTE, 0, 0)))

        item = 2
        for fileop in FILEOPS:
            metricname = name + '.brick.latency.' + fileop.lower() + '.'
            self.add_metric(metricname + 'avg', pmdaMetric(self.pmid(0, item),
                    c_api.PM_TYPE_FLOAT, self.brick_indom, c_api.PM_SEM_INSTANT,
                    pmUnits(0, 1, 0, 0, c_api.PM_TIME_USEC, 0)))
            item += 1
            self.add_metric(metricname + 'min', pmdaMetric(self.pmid(0, item),
                    c_api.PM_TYPE_U64, self.brick_indom, c_api.PM_SEM_INSTANT,
                    pmUnits(0, 1, 0, 0, c_api.PM_TIME_USEC, 0)))
            item += 1
            self.add_metric(metricname + 'max', pmdaMetric(self.pmid(0, item),
                    c_api.PM_TYPE_U64, self.brick_indom, c_api.PM_SEM_INSTANT,
                    pmUnits(0, 1, 0, 0, c_api.PM_TIME_USEC, 0)))
            item += 1
            self.add_metric(metricname + 'count', pmdaMetric(self.pmid(0, item),
                    c_api.PM_TYPE_U64, self.brick_indom, c_api.PM_SEM_INSTANT,
                    pmUnits(0, 1, 0, 0, c_api.PM_TIME_USEC, 0)))
            item += 1

        metricname = name + '.volume.'
        self.add_metric(name + 'profile', pmdaMetric(self.pmid(1, 0),
                c_api.PM_TYPE_32, self.volume_indom, c_api.PM_SEM_INSTANT,
                pmUnits(0, 0, 0, 0, 0, 0)))
        self.add_metric(name + 'dist.count', pmdaMetric(self.pmid(1, 1),
                c_api.PM_TYPE_32, self.volume_indom, c_api.PM_SEM_INSTANT,
                pmUnits(0, 0, 0, 0, 0, 0)))
        self.add_metric(name + 'stripe.count', pmdaMetric(self.pmid(1, 2),
                c_api.PM_TYPE_32, self.volume_indom, c_api.PM_SEM_INSTANT,
                pmUnits(0, 0, 0, 0, 0, 0)))
        self.add_metric(name + 'replica.count', pmdaMetric(self.pmid(1, 3),
                c_api.PM_TYPE_32, self.volume_indom, c_api.PM_SEM_INSTANT,
                pmUnits(0, 0, 0, 0, 0, 0)))

        self.set_fetch(self.gluster_fetch)
        self.set_instance(self.gluster_instance)
        self.set_fetch_callback(self.gluster_fetch_callback)
        self.set_store_callback(self.gluster_store_callback)


if __name__ == '__main__':
    for index in range(0, len(FILEOPS)):
        fileop = FILEOPS[index]
        FILEOPS_INDICES[fileop] = index
    GlusterPMDA('gluster', 118).run()
