#!/usr/bin/env pmpython
'''
Performance Metrics Domain Agent exporting Prometheus endpoint metrics.
'''
#
# Copyright (c) 2014-2015 Red Hat.
# 
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
# 

import cpmapi as c_api
from pcp.pmapi import pmUnits, pmContext as PCP
from pcp.pmda import PMDA, pmdaMetric, pmdaIndom, pmdaInstid
from resource import getpagesize

import requests
import json

from os import getenv, listdir
import sys
import time

if sys.version >= '3':
    long = int	# python2 to python3 portability (no long() in python3)

class PrometheusPMDA(PMDA):

    def parse_line(self, line):
        if not line or line[0] == '#':
            return None

        return line.split(' ')

    def refresh_metrics(self):
        try:
            req = requests.get(self.config["endpoint"])
            lines = req.text.splitlines()

            for line in lines:
                tokens = self.parse_line(line)
                if not tokens:
                    continue

                self.values[tokens[0]] = float(tokens[1])
        except:
            self.connection_error =True

    def prometheus_fetch_callback(self, cluster, item, inst):
        key = (cluster, item)
        if key not in self.indexes or self.connection_error:
            return [c_api.PM_ERR_PMID, 0]

        index = self.indexes[key]
        if inst == c_api.PM_IN_NULL:
            return [self.values[self.config["metrics"][index]["prometheus_name"]],1]
        else:
            instances = self.config["metrics"][index]["instances"]

            if inst >= len(instances):
                return [c_api.PM_ERR_PMID, 0]
            else:
                return [self.values[instances[inst]["prometheus_name"]], 1]

    def prometheus_fetch(self):
        self.refresh_metrics()

    def setup_prometheus_metrics(self, pmdaName):
        indomCount=0
        for i, metric in enumerate(self.config["metrics"]):
            self.indexes[tuple(metric["pmid"])] = i
            instDomain = c_api.PM_INDOM_NULL
            if len(metric["instances"]) > 0:
                instDomain = self.indom(indomCount)
                indomCount += 1
                domains = []
                for instance in metric["instances"]:
                    domains.append(pmdaInstid(*instance["instId"]))
                self.add_indom(pmdaIndom(instDomain, domains))
            self.add_metric(pmdaName + "." + metric["name"], pmdaMetric(
                self.pmid(*metric["pmid"]),
                metric["type"], instDomain, metric["sem"],
                pmUnits(*metric["units"])),
                metric["description"])

    def read_config(self):
        configFile = open(self.configfile)
        self.config = json.loads(configFile.read())
        configFile.close()

    def __init__(self, name, domain):
        PMDA.__init__(self, name, domain)

        #self.configfile = PCP.pmGetConfig('PCP_PMDAS_DIR') +  '/' + name + '/' + "config.json"
        self.configfile =   '/home/ronakjain/project/pcp/src/pmdas/prometheus/config.json'
        self.connection_error = False
        self.values = {}
        self.indexes = {}
        self.config = {}

        self.read_config()
        self.setup_prometheus_metrics(name)     
        
        self.set_fetch(self.prometheus_fetch)
        self.set_fetch_callback(self.prometheus_fetch_callback)

if __name__ == '__main__':
    PrometheusPMDA('prometheus', 421).run()
