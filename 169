#! /bin/sh
# PCP QA Test No. 169
# $Revision: 2.23 $
#
# Test pmcd timeouts with the pmcd PMDA's pmcd.control.timeout
#
# Test setting the app's timeouts < pmcd's timeout and vice versa
#
# Copyright (c) 1995-2002 Silicon Graphics, Inc.  All Rights Reserved.
#

seq=`basename $0`
echo "QA output created by $seq"
echo ""
echo "Test pmcd timeouts with the pmcd PMDA's pmcd.control.timeout"
echo ""

. ./common.product
. ./common.check
. ./common.filter

tmp=/tmp/$$
LOCALHOST=`hostname`
sudo=./sudo

if [ -d $PCP_LOG_DIR/pmlogger ]
then
    LOGGING_DIR=$PCP_LOG_DIR/pmlogger
else
    LOGGING_DIR=$PCP_LOG_DIR
fi

_cleanup()
{
    $sudo $PCP_RC_DIR/pcp stop >$tmp.stop
    _filter_pcp_stop <$tmp.stop | sed -e 's/\.\.\.*/[dots]/'
    [ -f $tmp.pmcd.conf ] && $sudo mv $tmp.pmcd.conf $PCP_PMCDCONF_PATH
    pmafm $LOGGING_DIR/$LOCALHOST/Latest remove >$tmp.cmd 2>&1 \
    && $sudo "sh $tmp.cmd"
    $sudo $PCP_RC_DIR/pcp start >$tmp.start 
    _filter_pcp_start <$tmp.start | sed -e 's/\.\.\.*/[dots]/'
    _wait_for_pmcd
    _wait_for_pmlogger

    rm -f $tmp.*
}

status=1	# failure is the default!
trap "_cleanup; exit \$status" 0 1 2 3 15

# real QA test starts here

# This value is passed to processes this script creates on the command line.
# It's unlikely to occur anywhere in a ps output and is used as a tag to kill
# or check for the existence of the processes later.
#
TAG=000000660066


_check_pmcd_procs()
{
    n_pmcd=`ps $PCP_PS_ALL_FLAGS \
	    | tee $tmp.pmcd \
	    | fgrep "$PCP_PMCD_PATH" \
	    | grep -v grep \
	    | wc -l \
	    | tr -d ' '`
    if [ "X$n_pmcd" != "X$1" ]
    then
	echo "Expected $1 pmcd processes but found $n_pmcd:"
	cat $tmp.pmcd
	cat $PCP_PMCDLOG_PATH
	file $PCP_LOG_DIR/core $PCP_LOG_DIR/pmcd/core
	return 1
    else
	return 0
    fi
}

_set_timeouts()
{
    pmcd_timeout=$1
    app_timeout=$2

    echo "app timeout = $app_timeout"
    echo "pmcd timeout = $pmcd_timeout"
    PMCD_REQUEST_TIMEOUT=$app_timeout
    export PMCD_REQUEST_TIMEOUT

    pmstore pmcd.control.timeout $pmcd_timeout

}

rm -rf $tmp.*
pmns=$tmp.pmns

# use a dummy pmns for pminfo
dummy_domain=160 # choose non-existent domain
cat >$pmns <<EOF
root {
    dummyproc   $dummy_domain:0:0
}
EOF

# pmcd will run a sed, masquerading as the IRIX agent.  This will not respond
# to PDUs from PMCD, which should then time it out.
# The pmcd PMDA is required so that pmcd.control.timeout can be modified.
# Save the current pmcd.conf so it can be restored afterwards.

cp $PCP_PMCDCONF_PATH $tmp.pmcd.conf
cat >$tmp.tmp <<End-Of-File
# QA test 169 dummy pmcd.conf (blame Jonathan if you find this!)
#
# $Id: 169,v 2.23 2004/05/18 23:15:00 pcpqa Exp $
#
dummyproc	$dummy_domain	pipe	binary 		sed /$TAG/p
End-Of-File

$PCP_AWK_PROG <$PCP_PMCDCONF_PATH >>$tmp.tmp '
    $3 == "dso" && $4 == "irix_init"	{ print }
    $3 == "dso" && $4 == "pmcd_init"	{ print }
					{ next }'

pmcdlog=$PCP_PMCDLOG_PATH

$sudo mv $tmp.tmp $PCP_PMCDCONF_PATH
$sudo $PCP_RC_DIR/pcp start >$tmp.start
_filter_pcp_start <$tmp.start | sed -e 's/\.\.\.*/[dots]/'
_wait_for_pmcd
if _check_pmcd_procs 1
then
    :
else
    echo "pmcd didn't start!"
    echo ""
    cat $pmcdlog
    exit 1
fi

if ps $PCP_PS_ALL_FLAGS | grep -v grep | grep "sed /$TAG/p" >/dev/null
then
    :
else
    echo "pmcd didn't create the dummy sed agent"
    echo ""
    cat $pmcdlog
    exit 1
fi

# force to a known state
#
pmstore pmcd.control.timeout 5 >/dev/null 2>&1
# pmstore pmcd.control.tracenobuf 1 # for debugging

#
# pmcd agent timeout < application time out
#
echo ""
echo "*** pmcd agent timeout < app timeout ***"
echo "*** pmcd will killoff agent ***" 
echo ""
_set_timeouts 5 10

# Fetch from dummy domain.  This should cause the sed agent to be timed-out by
# pmcd, resulting in its termination.
#
echo ""
echo "Expect dummyproc to fail (IPC protocol failure):"
pminfo -n $pmns -d dummyproc
echo ""

if ps $PCP_PS_ALL_FLAGS | grep -v grep | grep "sed /$TAG/p" >/dev/null
then
    echo "Error: pmcd didn't terminate dummy sed agent"
    exit 1
else
    echo "pmcd terminated dummy sed agent as desired"
fi

# Restart pmcd and its agents
echo ""
$sudo killall -HUP pmcd
sleep 1
_wait_for_pmcd
if _check_pmcd_procs 1
then
    :
else
    echo "pmcd was sent SIGHUP and died"
    echo ""
    cat $pmcdlog
    exit 1
fi

if ps $PCP_PS_ALL_FLAGS | grep -v grep | grep "sed /$TAG/p" >/dev/null
then
    psline=`ps $PCP_PS_ALL_FLAGS | grep -v grep | grep "sed /$TAG/p"`
    old_dummy_pid=`echo $psline | cut -d ' ' -f 2`
else
    echo "pmcd SIGHUP didn't restart the dummy sed agent"
    echo ""
    cat $pmcdlog
    exit 1
fi

#
# pmcd agent timeout < application time out
#
echo ""
echo "*** pmcd agent timeout > app timeout ***"
echo "*** pmcd will not killoff agent until later ***" 
echo ""
_set_timeouts 10 5

# Fetch from dummy domain.  This should cause the sed agent to be timed-out by
# pmcd, resulting in its termination.
#
echo ""
echo "Expect dummyproc to fail (timeout for pmcd failure):"
pminfo -n $pmns -d dummyproc
echo ""

if ps $PCP_PS_ALL_FLAGS | grep -v grep | grep "sed /$TAG/p" >/dev/null
then 
    echo "pmcd did NOT terminate dummy sed agent as desired"

    # make sure it is really the same process - check pid
    psline=`ps $PCP_PS_ALL_FLAGS | grep -v grep | grep "sed /$TAG/p"`
    new_dummy_pid=`echo $psline | cut -d ' ' -f 2`
    if [ $old_dummy_pid -ne $new_dummy_pid ]
    then
	echo "Error: dummy sed proc has been recreated"
	echo "pid mismatch: $old_dummy_pid versus $new_dummy_pid"
	exit 1
    fi
else
    echo "Error: pmcd terminated dummy sed agent"
    exit 1
fi

echo ""
echo "Now wait for pmcd to timeout..."
echo ""
sleep 6

if ps $PCP_PS_ALL_FLAGS | grep -v grep | grep "sed /$TAG/p" >/dev/null
then
    echo "Error: pmcd didn't terminate dummy sed agent"
    exit 1
else
    echo "pmcd terminated dummy sed agent as desired"
fi

echo ""
status=0
