#!/bin/sh
# PCP QA Test No. 514
#
# pmie - lots of expressions, checking pmie -d output and %v binding
#
# Copyright (c) 2012 Ken McDonell.  All Rights Reserved.
#

# get standard environment, filters and checks
. ./common.product
. ./common.filter
. ./common.check

seq=`basename $0`

_notrun "Temporarily disabled in dev branch - work in progress"

echo "QA output created by $seq"

status=1	# failure is the default!
$sudo rm -rf $tmp.* $seq.full
trap "rm -f $tmp.*; exit \$status" 0 1 2 3 15

LOCALHOST=`hostname`

case $PCP_PLATFORM
in
    irix|linux|solaris)
	# same syslog options for Irix, Linux and OpenSolaris
	SYSLOG_OPT='"-p daemon.info"'
	;;
    darwin)
	SYSLOG_OPT=''
	;;
    *)
	echo "Arrgh ... need syslog option for $PCP_PLATFORM"
	exit 1
	;;
esac

SYSLOG=''
for f in /var/adm/SYSLOG /var/log/daemon.log /var/log/messages /var/log/syslog /var/log/system.log
do
    if [ -f $f ]
    then
	SYSLOG=$f
	break
    fi
done
if [ -z "$SYSLOG" ]
then
    echo "Arrgh! Cannot find your syslog file"
    exit 1
fi

_filter()
{
    sed \
	-e "s/$LOCALHOST/LOCALHOST/g" \
	-e 's/[A-Z][a-z][a-z] [A-Z][a-z][a-z]  *[0-9][0-9]* [0-9][0-9]:[0-9][0-9]:[0-9][0-9]/DATE/' \
	-e 's/DATE [12][0-9][0-9][0-9]/DATE/' \
	-e '/evaluator exiting/s/pmie([0-9][0-9]*)/pmie(PID)/' \
	-e '/Performance Co-Pilot Inference Engine/s/Version .*/Version .../'
}

_filter2()
{
    $PCP_AWK_PROG '
$1 == "initMetric:"	{ skip=1 }
skip == 1		{ if ($1 == "Rule:") skip = 0 }
skip == 1		{ next }
			{ print }' >$tmp.tmp
    tr ' =' '\012' <$tmp.tmp \
    | grep '0x' \
    | $PCP_AWK_PROG >$tmp.sed '
BEGIN	{ n = 0 }
    	{ if (seen[$1] == 1) next
	  printf "s/%s/ADDR%03d/\n",$1,n
	  n++
	  seen[$1] = 1
	}'
    sed -f $tmp.sed <$tmp.tmp
}

cat <<End-of-File >$tmp.pmie
some_inst sample.part_bin > 500 -> print "some > 500" " %v";
all_inst sample.part_bin > 0 -> shell "echo 'all > 0'" " %v";
some_sample hinv.ncpu @0..2 == hinv.ncpu -> syslog 10sec $SYSLOG_OPT "PCP QA $seq - please ignore: some sample ncpu equal" " %v";
( sample.long.million + sample.long.one - sample.long.ten ) * sample.long.hundred / sample.long.ten >= 0 -> print "arith %v";
// true && true
sample.long.one != 2 && ( sample.long.million + sample.long.one - sample.long.ten ) * sample.long.hundred / sample.long.ten >= 0 -> print "boolean1 %v";
// false && true
sample.long.one <= 0 && ( sample.long.million + sample.long.one - sample.long.ten ) * sample.long.hundred / sample.long.ten >= 0 -> print "boolean2 %v";
// true && false
sample.long.one < 9 && ! ( sample.long.million + sample.long.one - sample.long.ten ) * sample.long.hundred / sample.long.ten >= 0 -> print "boolean3 %v";
// false && false
sample.long.one < 1 && ! ( sample.long.million + sample.long.one - sample.long.ten ) * sample.long.hundred / sample.long.ten >= 0 -> print "boolean4 %v";
// true || true
min_inst sample_part.bin == 100 || ( sample.long.million + sample.long.one - sample.long.ten ) * sample.long.hundred / sample.long.ten >= 0 -> print "boolean5 %v";
// false || true
//sample.long.one <= 0 || ( sample.long.million + sample.long.one - sample.long.ten ) * sample.long.hundred / sample.long.ten >= 0 -> print "boolean6 %v";
// true || false
//sample.long.one < 9 || ! ( sample.long.million + sample.long.one - sample.long.ten ) * sample.long.hundred / sample.long.ten >= 0 -> print "boolean7 %v";
// false || false
//sample.long.one < 1 || ! ( sample.long.million + sample.long.one - sample.long.ten ) * sample.long.hundred / sample.long.ten >= 0 -> print "boolean8 %v";
//
// boolean operators ||
// rising, falling and rate
// some_host
// all_x{host,sample}
// N%_x{inst,host,sample}
// match_inst, nomatch_inst
// min_x{inst,host,sample}
// max_x{inst,host,sample}
// sum_x{inst,host,sample}
// avg_x{inst,host,sample}
// count_{inst,host,sample}
// alarm and stomp actions
// scale factors nanosecond, nanosec, nsec,  microsecond, microsec, usec,
//     millisecond, millisec, msec, second, sec, minute, min, hour, byte,
//     Kbyte, Mbyte, Gbyte, Tbyte, count, Kcount,  Mcount,  Gcount and Tcount
// $minute, $hour, $day, $month, $year, $day_of_week, $delta
// | and & in actions
End-of-File

# real QA test starts here
cat <<End-of-File | pmie -t 250msec -d -Dappl1 >$tmp.out 2>$tmp.err &
f $tmp.pmie
l
r 1sec
v
End-of-File

wait

echo >>$seq.full
echo "pmie PID $!" >>$seq.full
echo >>$seq.full
echo "=== pmie output ===" >>$seq.full
cat $tmp.out >>$seq.full
echo >>$seq.full
echo "=== pmie errors ===" >>$seq.full
cat $tmp.err >>$seq.full

_filter2 <$tmp.err | _filter
_filter <$tmp.out

echo
echo "SYSLOG ..."
$sudo tail -100 $SYSLOG >$tmp.tmp
sed <$tmp.tmp -n \
    -e 's/PCP QA '"$seq"'/PCP QA xxx/' \
    -e '/ncpu equal/s/ [0-9][0-9]*/ N/g' \
    -e 's/PCP QA xxx/PCP QA '"$seq"'/' \
    -e '/\['$!']: PCP QA '"$seq"' - please ignore/{
s/.*please ignore/.../
p
}' \
| LC_COLLATE=POSIX sort -u

echo >>$seq.full
echo "=== tail SYSLOG ===" >>$seq.full
cat $tmp.tmp >>$seq.full

# success, all done
status=0
exit
