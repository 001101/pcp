<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1997, v.4001
<!DOCTYPE SGIDOCBK PUBLIC "-//Silicon Graphics, Inc.//DTD DocBook V2.3-based Subset V1.5//EN" [
<!ENTITY disclaimer.sgml SYSTEM "frontmatter/disclaimer.sgml">
<!ENTITY o3000 SYSTEM "online/o3000.gif" NDATA gif>
<!ENTITY figure5y SYSTEM "online/figure5y.gif" NDATA gif>
<!ENTITY figure5x SYSTEM "online/figure5x.gif" NDATA gif>
<!ENTITY mpivis SYSTEM "online/mpivis.gif" NDATA gif>
<!ENTITY oview-tool.sgml SYSTEM "oview-tool.sgml">
<!ENTITY glossary.sgml SYSTEM "glossary.sgml">
<!ENTITY chap09.misc.sgml SYSTEM "chap09.misc.sgml">
<!ENTITY chap08.pixie.sgml SYSTEM "chap08.pixie.sgml">
<!ENTITY chap07.prof.sgml SYSTEM "chap07.prof.sgml">
<!ENTITY chap06.ssrun.sgml SYSTEM "chap06.ssrun.sgml">
<!ENTITY chap05.machuse.sgml SYSTEM "chap05.machuse.sgml">
<!ENTITY chap04.exptypes.sgml SYSTEM "chap04.exptypes.sgml">
<!ENTITY chap03.ftut.sgml SYSTEM "chap03.ftut.sgml">
<!ENTITY chap02.ctut.sgml SYSTEM "chap02.ctut.sgml">
<!ENTITY chap01.intro.sgml SYSTEM "chap01.intro.sgml">
<!ENTITY whentouseidmap.sgml SYSTEM "whentouseidmap.sgml">
<!ENTITY nfsintro.sgml SYSTEM "nfsintro.sgml">
<!ENTITY idmapping.sgml SYSTEM "idmapping.sgml">
<!ENTITY chapB.sgml SYSTEM "chapB.sgml">
<!ENTITY chapC.sgml SYSTEM "chapC.sgml">
<!ENTITY chapD.sgml SYSTEM "chapD.sgml">
<!ENTITY chapE.sgml SYSTEM "chapE.sgml">
<!ENTITY chapF.sgml SYSTEM "chapF.sgml">
<!ENTITY chapA.sgml SYSTEM "chapA.sgml">
<!ENTITY chap01.sgml SYSTEM "chap01.sgml">
<!ENTITY chap02.sgml SYSTEM "chap02.sgml">
<!ENTITY chap03.sgml SYSTEM "chap03.sgml">
<!ENTITY chap04.sgml SYSTEM "chap04.sgml">
<!ENTITY a12231 SYSTEM "online/a12231.gif" NDATA gif>
<!ENTITY a12129 SYSTEM "online/a12129.gif" NDATA gif>
<!ENTITY a11363 SYSTEM "online/a11363.gif" NDATA gif>
<!ENTITY a11362 SYSTEM "online/a11362.gif" NDATA gif>
<!ENTITY a10650 SYSTEM "online/a10650.gif" NDATA gif>
<!ENTITY a10209 SYSTEM "online/a10209.gif" NDATA gif>
<!ENTITY a10180 SYSTEM "online/a10180.gif" NDATA gif>
<!ENTITY a10181 SYSTEM "online/a10181.gif" NDATA gif>
<!ENTITY a10195 SYSTEM "online/a10195.gif" NDATA gif>
<!ENTITY a10196 SYSTEM "online/a10196.gif" NDATA gif>
<!ENTITY a10197 SYSTEM "online/a10197.gif" NDATA gif>
<!ENTITY a10198 SYSTEM "online/a10198.gif" NDATA gif>
<!ENTITY a10200 SYSTEM "online/a10200.gif" NDATA gif>
<!ENTITY a10201 SYSTEM "online/a10201.gif" NDATA gif>
<!ENTITY a10206 SYSTEM "online/a10206.gif" NDATA gif>
<!ENTITY a10207 SYSTEM "online/a10207.gif" NDATA gif>
<!ENTITY a10253 SYSTEM "online/a10253.gif" NDATA gif>
<!ENTITY a10254 SYSTEM "online/a10254.gif" NDATA gif>
<!ENTITY a10255 SYSTEM "online/a10255.gif" NDATA gif>
<!ENTITY a10256 SYSTEM "online/a10256.gif" NDATA gif>
<!ENTITY a10257 SYSTEM "online/a10257.gif" NDATA gif>
<!ENTITY a10258 SYSTEM "online/a10258.gif" NDATA gif>
<!ENTITY a10259 SYSTEM "online/a10259.gif" NDATA gif>
<!ENTITY a11427 SYSTEM "online/a11427.gif" NDATA gif>
<!ENTITY a11428 SYSTEM "online/a11428.gif" NDATA gif>
<!ENTITY a11429 SYSTEM "online/a11429.gif" NDATA gif>
<!ENTITY a11430 SYSTEM "online/a11430.gif" NDATA gif>
<!ENTITY a11431 SYSTEM "online/a11431.gif" NDATA gif>
<!ENTITY a11432 SYSTEM "online/a11432.gif" NDATA gif>
<!ENTITY conventions.abbreviation SYSTEM "frontmatter/conventions.abbreviation.sgml">
<!ENTITY collections SYSTEM "dwebcollections.sgml">
<!ENTITY unicos SYSTEM "frontmatter/unicos.sgml">
<!ENTITY trademarks SYSTEM "frontmatter/trademarks.sgml">
<!ENTITY disclaimer SYSTEM "frontmatter/disclaimer.sgml">
<!ENTITY rights SYSTEM "frontmatter/rights.sgml">
<!ENTITY manpage.section SYSTEM "frontmatter/manpage.section.sgml">
<!ENTITY % public.private "INCLUDE">
<!ENTITY % proprietary "IGNORE">
<!ENTITY % private "IGNORE">
<!ENTITY % public "INCLUDE">
<!ENTITY % craysoft "INCLUDE">
<!ENTITY conventions.ellipses SYSTEM "frontmatter/conventions.ellipses.sgml">
<!ENTITY conventions.manpage SYSTEM "frontmatter/conventions.manpage.sgml">
<!ENTITY conventions.variable SYSTEM "frontmatter/conventions.variable.sgml">
<!ENTITY conventions.brackets SYSTEM "frontmatter/conventions.brackets.sgml">
<!ENTITY conventions.command SYSTEM "frontmatter/conventions.command.sgml">
<!ENTITY conventions.userinput SYSTEM "frontmatter/conventions.userinput.sgml">
<!ENTITY machines.craympp SYSTEM "frontmatter/machines.craympp.sgml">
<!ENTITY machines.allcraysystems SYSTEM "frontmatter/machines.allcraysystems.sgml">
<!ENTITY standards SYSTEM "frontmatter/standards.sgml">
<!ENTITY reader.comments SYSTEM "frontmatter/reader.comments.sgml">
<!ENTITY ordering.pubs SYSTEM "frontmatter/ordering.pubs.sgml">
<!ENTITY a12229 SYSTEM "online/a12229.gif" NDATA gif>
<!ENTITY a12228 SYSTEM "online/a12228.gif" NDATA gif>
<!ENTITY a12227 SYSTEM "online/a12227.gif" NDATA gif>
<!ENTITY a12226 SYSTEM "online/a12226.gif" NDATA gif>
<!ENTITY a12225 SYSTEM "online/a12225.gif" NDATA gif>
<!ENTITY a12224 SYSTEM "online/a12224.gif" NDATA gif>
<!ENTITY a12223 SYSTEM "online/a12223.gif" NDATA gif>
<!ENTITY a12222 SYSTEM "online/a12222.gif" NDATA gif>
<!ENTITY a12221 SYSTEM "online/a12221.gif" NDATA gif>
<!ENTITY a12220 SYSTEM "online/a12220.gif" NDATA gif>
<!ENTITY a12219 SYSTEM "online/a12219.gif" NDATA gif>
<!ENTITY a12218 SYSTEM "online/a12218.gif" NDATA gif>
<!ENTITY a12217 SYSTEM "online/a12217.gif" NDATA gif>
<!ENTITY a12216 SYSTEM "online/a12216.gif" NDATA gif>
<!ENTITY a12215 SYSTEM "online/a12215.gif" NDATA gif>
<!ENTITY a12214 SYSTEM "online/a12214.gif" NDATA gif>
<!ENTITY a12213 SYSTEM "online/a12213.gif" NDATA gif>
<!ENTITY a12212 SYSTEM "online/a12212.gif" NDATA gif>
<!ENTITY a12211 SYSTEM "online/a12211.gif" NDATA gif>
<!ENTITY a12210 SYSTEM "online/a12210.gif" NDATA gif>
<!ENTITY a12209 SYSTEM "online/a12209.gif" NDATA gif>
<!ENTITY a12208 SYSTEM "online/a12208.gif" NDATA gif>
<!ENTITY a12207 SYSTEM "online/a12207.gif" NDATA gif>
<!ENTITY a12206 SYSTEM "online/a12206.gif" NDATA gif>
<!ENTITY a12205 SYSTEM "online/a12205.gif" NDATA gif>
<!ENTITY a12204 SYSTEM "online/a12204.gif" NDATA gif>
<!ENTITY a12203 SYSTEM "online/a12203.gif" NDATA gif>
<!ENTITY a12202 SYSTEM "online/a12202.gif" NDATA gif>
<!ENTITY a12201 SYSTEM "online/a12201.gif" NDATA gif>
<!ENTITY a12200 SYSTEM "online/a12200.gif" NDATA gif>
<!ENTITY a12199 SYSTEM "online/a12199.gif" NDATA gif>
<!ENTITY a12198 SYSTEM "online/a12198.gif" NDATA gif>
<!ENTITY a12197 SYSTEM "online/a12197.gif" NDATA gif>
<!ENTITY a12196 SYSTEM "online/a12196.gif" NDATA gif>
<!ENTITY a12195 SYSTEM "online/a12195.gif" NDATA gif>
<!ENTITY a12194 SYSTEM "online/a12194.gif" NDATA gif>
<!ENTITY a12193 SYSTEM "online/a12193.gif" NDATA gif>
<!ENTITY a12192 SYSTEM "online/a12192.gif" NDATA gif>
<!ENTITY a12191 SYSTEM "online/a12191.gif" NDATA gif>
<!ENTITY a12190 SYSTEM "online/a12190.gif" NDATA gif>
<!ENTITY a12189 SYSTEM "online/a12189.gif" NDATA gif>
<!ENTITY % IRIX.intros "IGNORE">
<!ENTITY % UAG "INCLUDE">
<!ENTITY ch01.sgml SYSTEM "ch01.sgml">
<!ENTITY ch02.sgml SYSTEM "ch02.sgml">
<!ENTITY ch03.sgml SYSTEM "ch03.sgml">
<!ENTITY ch04.sgml SYSTEM "ch04.sgml">
<!ENTITY ch05.sgml SYSTEM "ch05.sgml">
<!ENTITY ch07.sgml SYSTEM "ch07.sgml">
<!ENTITY ch08.sgml SYSTEM "ch08.sgml">
<!ENTITY ch09.sgml SYSTEM "ch09.sgml">
<!ENTITY chA.sgml SYSTEM "chA.sgml">
<!ENTITY preface.sgml SYSTEM "preface.sgml">
]>
-->
<?Pub UDT _bookmark _target>
<?Pub UDT _nopagebreak _touchup KeepsKeep="yes" KeepsPrev="no" KeepsNext="no" KeepsBoundary="page">
<chapter id="LE21414-PARENT">
<title id="LE21414-TITLE">Performance Metrics Inference Engine</title>
<para><indexterm id="ITch06-0"><primary>pmie tool</primary><secondary>performance
metrics inference engine</secondary></indexterm><indexterm id="ITch06-1">
<primary>tool options</primary></indexterm><indexterm id="ITch06-2"><primary>
Performance Metrics Inference Engine</primary><see>pmie tool</see></indexterm>The
Performance Metrics Inference Engine (<command>pmie</command>) is a tool that
provides automated monitoring of, and reasoning about, system performance
within the Performance Co-Pilot (PCP) framework.</para>
<para>The following major sections in this chapter are as follows:</para>
<itemizedlist>
<listitem><para><xref linkend="LE41170-PARENT">, provides an introduction
to the concepts and design of <command>pmie</command>.</para>
</listitem>
<listitem><para><xref linkend="LE15993-PARENT">, describes the basic syntax
and usage of <command>pmie</command>.</para>
</listitem>
<listitem><para><xref linkend="LE90227-PARENT">, discusses the complete <command>
pmie</command> rule specification language.</para>
</listitem>
<listitem><para><xref linkend="LE60280-PARENT">, provides an example, covering
several common performance scenarios.</para>
</listitem>
<listitem><para><xref linkend="LE31514-PARENT">, presents some tips and techniques
for <command>pmie</command> rule development.</para>
</listitem>
<listitem><para><xref linkend="LE91221-PARENT">, presents some important information
on using <command>pmie</command>.</para>
</listitem>
<listitem><para><xref linkend="Z927039566sdc">, describes how to use the <command>
pmieconf</command> command to generate <command>pmie</command> rules.</para>
</listitem>
<listitem><para><xref linkend="Z927039824sdc">, provides support for running <command>
pmie</command> as a daemon.</para>
</listitem></itemizedlist>
<section id="LE41170-PARENT">
<title id="LE41170-TITLE">Introduction to <command>pmie</command></title>
<para><indexterm id="ITch06-4"><primary>pmie tool</primary><secondary>automated
reasoning</secondary></indexterm>Automated reasoning within Performance Co-Pilot
(PCP) is provided by the Performance Metrics Inference Engine, (<command>
pmie</command>), which is an applied artificial intelligence application.
</para>
<para>The <command>pmie</command> tool accepts expressions describing adverse
performance scenarios, and periodically evaluates these against streams of
performance metric values from one or more sources. When an expression is
found to be true, <command>pmie</command> is able to execute arbitrary actions
to alert or notify the system administrator of the occurrence of an adverse
performance scenario. These facilities are very general, and are designed
to accommodate the automated execution of a mixture of generic and site-specific
performance monitoring and control functions.</para>
<para>The stream of performance metrics to be evaluated may be from one or
more hosts, or from one or more PCP archive logs. In the latter case, <command>
pmie</command> may be used to retrospectively identify adverse performance
conditions.</para>
<para><indexterm><primary>PMCS</primary><secondary>pmie capabilities</secondary>
</indexterm><indexterm><primary>PMAPI</primary><secondary>pmie capabilities
</secondary></indexterm>Using <command>pmie</command>, you can filter, interpret,
and reason about the large volume of performance data made available by the
Performance Metrics Collection Subsystem (PMCS) and delivered through the
Performance Metrics Application Programming Interface (PMAPI).</para>
<para>Typical <command>pmie</command> uses include the following:</para>
<itemizedlist>
<listitem><para>Automated real-time monitoring of a host, a set of hosts,
or client-server pairs of hosts to raise operational alarms when poor performance
is detected in a production environment</para>
</listitem>
<listitem><para>Nightly processing of archive logs to detect and report performance
regressions, or quantify quality of service for service agreements or management
reports, or produce advance warning of pending performance problems</para>
</listitem>
<listitem><para>Strategic performance management, for example, detection of
abnormal, but not chronic, system behavior, trend analysis, and capacity planning
</para>
</listitem></itemizedlist>
<para><indexterm><primary>pmie tool</primary><secondary>language</secondary>
</indexterm>The <command>pmie</command> expressions are described in a language
with expressive power and operational flexibility. It includes the following
operators and functions:</para>
<itemizedlist>
<listitem><para>Generalized predicate-action pairs, where a predicate is a
logical expression over the available performance metrics, and the action
is arbitrary. Predefined actions include the following:</para>
<itemizedlist><listitem><para><indexterm><primary>xconfirm command</primary>
<secondary>visible alarm</secondary></indexterm>Launch a visible alarm with <literal>
xconfirm</literal>; see the <command sectionref="1">xconfirm</command> man
page.</para>
</listitem><listitem><para><indexterm><primary>syslog function</primary></indexterm><indexterm>
<primary>/var/log/messages file</primary></indexterm>Post an entry to the
system log <filename>/var/log/messages</filename>; see the <command sectionref="3C">
syslog</command> man page.</para>
</listitem><listitem><para><indexterm><primary>/var/log/pcp/NOTICES file</primary>
</indexterm>Post an entry to the PCP noticeboard file <filename>/var/log/pcp/NOTICES
</filename>.</para>
</listitem><listitem><para>Execute a shell command or script, for example,
to send e-mail, initiate a pager call, warn the help desk, and so on.</para>
</listitem><listitem><para>Echo a message on standard output; useful for scripts
that generate reports from retrospective processing of PCP archive logs.</para>
</listitem></itemizedlist>
</listitem>
<listitem><para>Arithmetic and logical expressions in a C-like syntax.</para>
</listitem>
<listitem><para>Expression groups may have an independent evaluation frequency,
to support both short-term and long-term monitoring.</para>
</listitem>
<listitem><para>Canonical scale and rate conversion of performance metric
values to provide sensible expression evaluation.</para>
</listitem>
<listitem><para>Aggregation functions of <literal>sum</literal>, <literal>
avg</literal>, <literal>min</literal>, and <literal>max</literal>, that may
be applied to collections of performance metrics values clustered over multiple
hosts, or multiple instances, or multiple consecutive samples in time.</para>
</listitem>
<listitem><para>Universal and existential quantification, to handle expressions
of the form &ldquo;for every....&rdquo; and &ldquo;at least one...&rdquo;.
</para>
</listitem>
<listitem><para>Percentile aggregation to handle statistical outliers, such
as &ldquo;for at least 80% of the last 20 samples, ...&rdquo;.</para>
</listitem>
<listitem><para>Macro processing to expedite repeated use of common subexpressions
or specification components.</para>
</listitem>
<listitem><para>Transparent operation against either live-feeds of performance
metric values from PMCD on one or more hosts, or against PCP archive logs
of previously accumulated performance metric values.</para>
</listitem></itemizedlist>
<para>The power of <command>pmie</command> may be harnessed to automate the
most common of the deterministic system management functions that are responses
to changes in system performance. For example, disable a batch stream if the
DBMS transaction commit response time at the ninetieth percentile goes over
two seconds, or stop accepting news and send e-mail to the <replaceable>sysadmin
</replaceable> alias if free space in the news file system falls below five
percent.</para>
<para>Moreover, the power of <command>pmie</command> can be directed towards
the exceptional and sporadic performance problems. For example, if a network
packet storm is expected, enable IP header tracing for ten seconds, and send
e-mail to advise that data has been collected and is awaiting analysis. Or,
if production batch throughput falls below 50 jobs per hour, activate a pager
to the systems administrator on duty.</para>
<para><indexterm><primary>pmie tool</primary><secondary>customization</secondary>
</indexterm><indexterm><primary>pmieconf tool</primary><secondary>customization
</secondary></indexterm>Obviously, <command>pmie</command> customization is
required to produce meaningful filtering and actions in each production environment.
The <command>pmieconf</command> tool provides a convenient customization method,
allowing the user to generate parameterized <command>pmie</command> rules
for some of the more common performance scenarios.</para>
</section>
<section id="LE15993-PARENT">
<title id="LE15993-TITLE">Basic <command>pmie</command> Usage</title>
<para><indexterm><primary>pmie tool</primary><secondary>basic examples</secondary>
</indexterm>This section presents and explains some basic examples of <command>
pmie</command> usage. The <command>pmie</command> tool accepts the common
PCP command line arguments, as described in <xref linkend="LE94335-PARENT">.
In addition, <command>pmie</command> accepts the following command line arguments:
</para>
<deflist termlength="narrow">
<deflistentry>
<term><literal>-d</literal></term>
<listitem><para>Enables interactive debug mode.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>-v</literal></term>
<listitem><para>Verbose mode: expression values are displayed.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>-V</literal></term>
<listitem><para>Verbose mode: annotated expression values are displayed.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>-W</literal></term>
<listitem><para>When-verbose mode: when a condition is true, the satisfying
expression bindings are displayed.</para>
</listitem></deflistentry>
</deflist>
<para>One of the most basic invocations of this tool is this form:</para>
<literallayout format="yes"><userinput>pmie</userinput> <replaceable>filename
</replaceable></literallayout>
<para>In this form, the expressions to be evaluated are read from <replaceable>
filename</replaceable>. In the absence of a given <replaceable>filename</replaceable>,
expressions are read from standard input, usually your system keyboard.</para>
<section id="LE23271-PARENT">
<title id="LE23271-TITLE"><command>pmie</command> and the Performance Metrics
Collection Subsystem</title>
<para><indexterm id="ITch06-7"><primary>PMCS</primary><secondary>pmie tool
</secondary></indexterm>Before you use <command>pmie</command>, familiarize
yourself with some Performance Metrics Collection System (PMCS) basics. It
is strongly recommended that you familiarize yourself with the concepts from
the <xref linkend="LE79836-PARENT">. The discussion in this section serves
as a very brief review of these concepts.</para>
<para><indexterm><primary>pminfo tool</primary><secondary>pmie arguments</secondary>
</indexterm>The PMCS makes available hundreds of performance metrics that
you can use when formulating expressions for <command>pmie</command> to evaluate.
If you want to find out which metrics are currently available on your system,
use this command:</para>
<literallayout><userinput>pminfo</userinput>&ensp;</literallayout>
<para>Use the <command>pmie</command> command line arguments to find out more
about a particular metric. In <xref linkend="Z983826022sdc">, to fetch new
metric values from host <literal>moomba</literal>, you use the <literal>-f
</literal> flag:</para>
<example id="Z983825969sdc"><title id="Z983826022sdc"><command>pmie</command>
with the <literal>-f</literal> Option</title>
<literallayout><userinput>pminfo -f -h dove disk.dev.total</userinput></literallayout>
<para>This produces the following response:</para>
<literallayout>disk.dev.total
    inst [0 or "xscsi/pci00.01.0/target81/lun0/disc"] value 131233
    inst [4 or "xscsi/pci00.01.0/target82/lun0/disc"] value 4
    inst [8 or "xscsi/pci00.01.0/target83/lun0/disc"] value 4
    inst [12 or "xscsi/pci00.01.0/target84/lun0/disc"] value 4
    inst [16 or "xscsi/pci00.01.0/target85/lun0/disc"] value 4
    inst [18 or "xscsi/pci00.01.0/target86/lun0/disc"] value 4</literallayout>
</example>
<para>This reveals that on the host <literal>dove</literal>, the metric <literal>
disk.dev.total</literal> has six instances, one for each disk on the system.
</para>
<para>Use the following command to request help text (specified with the <literal>
-T</literal> flag) to provide more information about performance metrics:
</para>
<literallayout><userinput>pminfo -T network.interface.in.packets</userinput></literallayout>
<para>The metadata associated with a performance metric is used by <command>
pmie</command> to determine how the value should be interpreted. You can examine
the descriptor that encodes the metadata by using the <literal>-d</literal>
flag for <command>pminfo</command>, as shown in <xref linkend="Z983826191sdc">:
</para>
<example id="Z983826092sdc"><title id="Z983826191sdc"><command>pmie</command>
with the <literal>-d</literal> and <literal>-h</literal> Options</title>
<literallayout format="yes"><userinput>pminfo -d -h </userinput><replaceable>
somehost </replaceable><userinput>mem.freemem kernel.percpu.syscall</userinput></literallayout>
<para>In response, you see output similar to this:</para>
<literallayout width="wide">mem.freemem
    Data Type: 64-bit unsigned int  InDom: PM_INDOM_NULL 0xffffffff
    Semantics: instant  Units: Kbyte

kernel.percpu.syscall
    Data Type: 32-bit unsigned int  InDom: 60.0 0xf000000
    Semantics: counter  Units: count</literallayout>
</example>
<note><para><indexterm id="ITch06-8"><primary>PM_INDOM_NULL</primary></indexterm>A
cumulative counter such as <literal>kernel.percpu.syscall</literal> is automatically
converted by <command>pmie</command> into a rate (measured in events per second,
or count/second), while instantaneous values such as <literal>mem.freemem
</literal> are not subjected to rate conversion. Metrics with an instance
domain (<literal>InDom</literal> in the <command>pminfo</command> output)
of <literal>PM_INDOM_NULL</literal> are singular and always produce one value
per source. However, a metric like <literal>kernel.percpu.syscall</literal>
has an instance domain, and may produce multiple values per source (in this
case, it is one value for each configured CPU).</para>
</note>
</section>
<section>
<title>Simple <command>pmie</command> Usage</title>
<para><indexterm id="ITch06-9"><primary>pmie tool</primary><secondary>examples
</secondary></indexterm><xref linkend="Z983823657sdc"> directs the inference
engine to evaluate and print values (specified with the <literal>-v</literal>
flag) for a single performance metric (the simplest possible expression),
in this case <literal>disk.dev.total</literal>, collected from the local PMCD:
</para>
<example id="Z983823607sdc"><title id="Z983823657sdc"><command>pmie</command>
with the <literal>-v</literal> Option</title>
<literallayout><userinput>pmie -v</userinput>
<userinput>iops = disk.dev.total;</userinput>
<userinput>Ctrl+D</userinput>
iops:      ?      ?
iops:   14.4      0
iops:   25.9  0.112
iops:   12.2      0
iops:   12.3   64.1
iops:  8.594  52.17
iops:  2.001  71.64</literallayout>
</example>
<para>On this system, there are two disk spindles, hence two values of the
expression <command>iops</command> per sample. Notice that the values for
the first sample are unknown (represented by the question marks [?] in the
first line of output), because rates can be computed only when at least two
samples are available. The subsequent samples are produced every ten seconds
by default. The second sample reports that during the preceding ten seconds
there was an average of 14.4 transfers per second on one disk and no transfers
on the other disk.</para>
<para>Rates are computed using time stamps delivered by the PMCS. Due to unavoidable
inaccuracy in the actual sampling time (the sample interval is not exactly
10 seconds), you may see more decimal places in values than you expect. Notice,
however, that these errors do not accumulate but cancel each other out over
subsequent samples.</para>
<para>In <xref linkend="Z983823657sdc">, the expression to be evaluated was
enter (the keyboard), followed by the end-of-file character [<keycap>Ctrl
</keycap>+<keycap>D</keycap>]. Usually, it is more convenient to enter expressions
into a file (for example, <filename>myrules</filename>) and ask <command>
pmie</command> to read the file. Use this command syntax:</para>
<literallayout><userinput>pmie -v myrules</userinput>&ensp;</literallayout>
<para>Please refer to the <command sectionref="1">pmie</command> man page
for a complete description of <command>pmie</command> command line options.
</para>
</section>
<section>
<title>Complex <command>pmie</command> Examples</title>
<para><indexterm id="ITch06-10"><primary>pmie tool</primary><secondary>examples
</secondary></indexterm>This section illustrates more complex <command>pmie
</command> expressions of the specification language. <xref linkend="LE90227-PARENT">,
provides a complete description of the <command>pmie</command> specification
language.</para>
<para>The following arithmetic expression computes the percentage of write
operations over the total number of disk transfers.</para>
<literallayout>(disk.all.write / disk.all.total) * 100; </literallayout>
<para>The <literal>disk.all</literal> metrics are singular, so this expression
produces exactly one value per sample, independent of the number of disk devices.
</para>
<note><para>If there is no disk activity,<literal>&ensp;disk.all.total</literal>
will be zero and <command>pmie</command> evaluates this expression to be not
a number. When <literal>-v</literal> is used, any such values are displayed
as question marks.</para>
</note>
<para>The following logical expression has the value <literal>true</literal>
or <literal>false</literal> for each disk:</para>
<literallayout>disk.dev.total > 10 &amp;&amp; 
disk.dev.write > disk.dev.read; </literallayout>
<para>The value is true if the number of writes exceeds the number of reads,
and if there is significant disk activity (more than 10 transfers per second). <xref
linkend="Z983824256sdc"> demonstrates a simple action:</para>
<example id="Z983824038sdc"><title id="Z983824256sdc"><command>pmie</command>
Output Printed</title>
<literallayout width="standard">some_inst disk.dev.total > 60 -> 
                              print "[%i] high disk i/o "; </literallayout>
<para>This prints a message to the standard output whenever the total number
of transfers for some disk (<literal>some_inst</literal>) exceeds 60 transfers
per second. The <literal>%i</literal> (instance) in the message is replaced
with the name(s) of the disk(s) that caused the logical expression to be <literal>
true</literal>.</para>
<para>Using <command>pmie</command> to evaluate the above expressions every
3 seconds, you see output similar to the following:</para>
<literallayout width="wide"><userinput>pmie -v -t 3sec</userinput>
<userinput>pct_wrt = (disk.all.write / disk.all.total) * 100;</userinput>
<userinput>busy_wrt = disk.dev.total > 10 &amp;&amp;</userinput>
           <userinput>disk.dev.write > disk.dev.read;</userinput>
<userinput>busy = some_inst disk.dev.total > 60 -></userinput>
                           <userinput>print "[%i] high disk i/o ";</userinput>
<userinput>Ctrl+D</userinput>
pct_wrt:       ? 
busy_wrt:      ?      ?
busy:          ?

pct_wrt:   18.43
busy_wrt:  false  false
busy:      false

Mon Aug  5 14:56:08 2002: [dks0d2] high disk i/o
pct_wrt:   10.83
busy_wrt:  false  false
busy:      true

pct_wrt:   19.85
busy_wrt:   true  false
busy:      false

pct_wrt:       ?
busy_wrt:  false  false
busy:      false

Mon Aug  5 14:56:17 2002: [dks0d1] high disk i/o [dks0d2] high disk i/o
pct_wrt:   14.8
busy_wrt:  false  false
busy:   true</literallayout>
<para>The first sample contains unknowns, since all expressions depend on
computing rates. Also notice that the expression <literal>pct_wrt</literal>
may have an undefined value whenever all disks are idle, as the denominator
of the expression is zero. If one or more disks is busy, the expression <literal>
busy</literal> is true, and the message from the <literal>print</literal>
in the action part of the rule appears (before the <literal>-v</literal> values).
</para>
</example>
</section>
</section>
<?Pub _newpage>
<section id="LE90227-PARENT">
<title id="LE90227-TITLE">Specification Language for <command>pmie</command></title>
<para><indexterm><primary>pmie tool</primary><secondary>language</secondary>
</indexterm>This section describes the complete syntax of the <command>pmie
</command> specification language, as well as macro facilities and the issue
of sampling and evaluation frequency. The reader with a preference for learning
by example may choose to skip this section and go straight to the examples
in <xref linkend="LE60280-PARENT">.</para>
<para>Complex expressions are built up recursively from simple elements:</para>
<orderedlist><listitem><para>Performance metric values are obtained from PMCD
for real-time sources, otherwise from PCP archive logs.</para>
</listitem><listitem><para>Metrics values may be combined using arithmetic
operators to produce arithmetic expressions.</para>
</listitem><listitem><para>Arithmetic expressions may be compared using relational
operators to produce logical expressions.</para>
</listitem><listitem><para>Logical expressions may be combined using Boolean
operators, including powerful quantifiers.</para>
</listitem><listitem><para>Aggregation operators may be used to compute summary
expressions, for either arithmetic or logical operands.</para>
</listitem><listitem><para>The final logical expression may be used to initiate
a sequence of actions.</para>
</listitem></orderedlist>
<section id="LE51927-PARENT">
<title id="LE51927-TITLE">Basic <command>pmie</command> Syntax</title>
<para><indexterm id="ITch06-11"><primary>pmie tool</primary><secondary>syntax
</secondary></indexterm>The <command>pmie</command> rule specification language
supports a number of basic syntactic elements.</para>
<section>
<title>Lexical Elements</title>
<para><indexterm><primary>lexical elements</primary></indexterm>All <command>
pmie</command> expressions are composed of the following lexical elements:
</para>
<deflist>
<deflistentry>
<term>Identifier</term>
<listitem><para>Begins with an alphabetic character (either upper or lowercase),
followed by zero or more letters, the numeric digits, and the special characters
period (<literal>.</literal>) and underscore (<literal>_</literal>), as shown
in the following example:<literallayout><literal>x</literal>, <literal>disk.dev.total
</literal> and <literal>my_stuff</literal></literallayout></para>
<para>As a special case, an arbitrary sequence of letters enclosed by apostrophes
(<literal>'</literal>) is also interpreted as an <replaceable>identifier</replaceable>;
for example:<literallayout>'vms$slow_response'</literallayout></para>
</listitem></deflistentry>
<deflistentry>
<term>Keyword</term>
<listitem><para>The aggregate operators, units, and predefined actions are
represented by keywords; for example, <literal>some_inst</literal>, <literal>
print</literal>, and <literal>hour</literal>.</para>
</listitem></deflistentry>
<deflistentry>
<term>Numeric constant</term>
<listitem><para>Any likely representation of a decimal integer or floating
point number; for example, 124, 0.05, and -45.67</para>
</listitem></deflistentry>
<deflistentry>
<term>String constant</term>
<listitem><para>An arbitrary sequence of characters, enclosed by double quotation
marks (<literal>"x"</literal>).</para>
</listitem></deflistentry>
</deflist>
<para>Within quotes of any sort, the backslash (<literal>/</literal>) may
be used as an escape character as shown in the following example:</para>
<literallayout>"A \"gentle\" reminder"</literallayout>
</section>
<section>
<title>Comments </title>
<para><indexterm><primary>comments</primary></indexterm>Comments may be embedded
anywhere in the source, in either of these forms:</para>
<deflist>
<deflistentry>
<term><literal>/* text */</literal></term>
<listitem><para>Comment, optionally spanning multiple lines, with no nesting
of comments.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>// text</literal></term>
<listitem><para>Comment from here to the end of the line.</para>
</listitem></deflistentry>
</deflist>
</section>
<section>
<title>Macros</title>
<para><indexterm><primary>macros</primary></indexterm>When they are fully
specified, expressions in <command>pmie</command> tend to be verbose and repetitious.
The use of macros can reduce repetition and improve readability and modularity.
Any statement of the following form associates the macro name <literal>identifier
</literal> with the given string constant.</para>
<literallayout><literal>identifier = "<replaceable>string</replaceable>";
</literal></literallayout>
<para>Any subsequent occurrence of the macro name <literal>identifier</literal>
is replaced by the <replaceable>string</replaceable> most recently associated
with a macro definition for <literal>identifier</literal>.</para>
<literallayout><userinput>$</userinput><literal>identifier</literal>&ensp;
</literallayout>
<para>For example, start with the following macro definition:</para>
<literallayout>disk = "disk.all"; </literallayout>
<para>You can then use the following syntax:</para>
<literallayout>pct_wrt = ($disk.write / $disk.total) * 100;</literallayout>
<note><para>Macro expansion is performed before syntactic parsing; so macros
may only be assigned constant string values.</para>
</note>
</section>
<section>
<title>Units</title>
<para><indexterm><primary>units</primary></indexterm>The inference engine
converts all numeric values to canonical units (seconds for time, bytes for
space, and events for count). To avoid surprises, you are encouraged to specify
the units for numeric constants. If units are specified, they are checked
for dimension compatibility against the metadata for the associated performance
metrics.</para>
<para>The syntax for a <literal>units</literal> specification is a sequence
of one or more of the following keywords separated by either a space or a
slash (<literal>/</literal>), to denote per: <literal>byte</literal>, <literal>
KByte</literal>, <literal>MByte</literal>, <literal>GByte</literal>, <literal>
TByte</literal>, <literal>nsec</literal>, <literal>nanosecond</literal>, <literal>
usec</literal>, <literal>microsecond</literal>, <literal>msec</literal>, <literal>
millisecond</literal>, <literal>sec</literal>, <literal>second</literal>, <literal>
min</literal>, <literal>minute</literal>, <literal>hour</literal>, <literal>
count</literal>, <literal>Kcount</literal>, <literal>Mcount</literal>, <literal>
Gcount</literal>, or <literal>Tcount</literal>. Plural forms are also accepted.
</para>
<para>The following are examples of units usage:</para>
<literallayout>disk.dev.blktotal > 1 Mbyte / second; 
mem.freemem &lt; 500 Kbyte;</literallayout>
<note><para>If you do not specify the units for numeric constants, it is assumed
that the constant is in the canonical units of seconds for time, bytes for
space, and events for count, and the dimensionality of the constant is assumed
to be correct. Thus, in the following expression, the <literal>500</literal>
is interpreted as 500 bytes.</para>
<literallayout>mem.freemem &lt; 500</literallayout>
</note>
</section>
</section>
<section id="LE88708-PARENT">
<title id="LE88708-TITLE">Setting Evaluation Frequency</title>
<para><indexterm id="ITch06-12"><primary>pmie tool</primary><secondary>setting
evaluation frequency</secondary></indexterm><indexterm><primary>evaluation
frequency</primary></indexterm>The identifier name <literal>delta</literal>
is reserved to denote the interval of time between consecutive evaluations
of one or more expressions. Set <literal>delta</literal> as follows:</para>
<literallayout>delta = <replaceable>number</replaceable> [<replaceable>units
</replaceable>];</literallayout>
<?Pub _newpage>
<para>If present, <literal>units</literal> must be one of the time units described
in the preceding section. If absent, <literal>units</literal> are assumed
to be <literal>seconds</literal>. For example, the following expression has
the effect that any subsequent expressions (up to the next expression that
assigns a value to <literal>delta</literal>) are scheduled for evaluation
at a fixed frequency, once every five minutes.</para>
<literallayout>delta = 5 min; </literallayout>
<para>The default value for <literal>delta</literal> may be specified using
the <literal>-t</literal> command line option; otherwise <literal>delta</literal>
is initially set to be 10 seconds.</para>
</section>
<section id="LE73508-PARENT">
<title id="LE73508-TITLE"><command>pmie</command> Metric Expressions</title>
<para><indexterm id="ITch06-13"><primary>pmie tool</primary><secondary>metric
expressions</secondary></indexterm><indexterm><primary>PMNS</primary><secondary>
metric expressions</secondary></indexterm><indexterm><primary>PMCS</primary>
<secondary>metric expressions</secondary></indexterm><indexterm><primary>
PMCD</primary><secondary>collector host</secondary></indexterm>A Performance
Metrics Name Space (PMNS) provides a means of naming performance metrics,
for example, <literal>disk.dev.read</literal>. The Performance Metrics Collection
System (PMCS) allows an application to retrieve one or more values for a performance
metric from a designated source (a collector host running PMCD, or a PCP archive
log). To specify a single value for some performance metric requires the metric
name to be associated with all three of the following:</para>
<itemizedlist>
<listitem><para>A particular host (or source of metrics values)</para>
</listitem>
<listitem><para>A particular instance (for metrics with multiple values)</para>
</listitem>
<listitem><para>A sample time</para>
</listitem></itemizedlist>
<para>The permissible values for hosts are the range of valid hostnames as
provided by Internet naming conventions.</para>
<para><indexterm><primary>PMDA</primary><secondary>instance names</secondary>
</indexterm>The names for instances are provided by the Performance Metrics
Domain Agents (PMDA) for the instance domain associated with the chosen performance
metric.</para>
<para>The sample time specification is defined as the set of natural numbers
0, 1, 2, and so on. A number refers to one of a sequence of sampling events,
from the current sample 0 to its predecessor 1, whose predecessor was 2, and
so on. This scheme is illustrated by the time line shown in <xref linkend="LE54208-TITLE">.
</para>
<figure>
<graphic entityref="a12217" scale="NO"></graphic>
<title id="LE54208-TITLE">Sampling Time Line</title>
</figure>
<para>Each sample point is assumed to be separated from its predecessor by
a constant amount of real time, the <literal>delta</literal>. The most recent
sample point is always zero. The value of <literal>delta</literal> may vary
from one expression to the next, but is fixed for each expression; for more
information on the sampling interval, see <xref linkend="LE88708-PARENT">.
</para>
<para>For <command>pmie</command>, a metrics expression is the name of a metric,
optionally qualified by a host, instance and sample time specification. Special
characters introduce the qualifiers: colon (<literal>:</literal>) for hosts,
hash or pound sign (<literal>#</literal>) for instances, and at (<literal>
@</literal>) for sample times. The following expression refers to the previous
value (<literal>@1</literal>) of the counter for the disk read operations
associated with the disk instance <literal>#dks0d1</literal> on the host <literal>
moomba</literal>.</para>
<literallayout>disk.dev.read :moomba #dks0d1 @1 </literallayout>
<para>In fact, this expression defines a point in the three-dimensional (3D)
parameter space of {<literal>host</literal>} x {<literal>instance</literal>}
x {<literal>sample time</literal>} as shown in <xref linkend="LE32691-TITLE">.
</para>
<figure>
<graphic entityref="a12218" scale="NO"></graphic>
<title id="LE32691-TITLE">Three-Dimensional Parameter Space</title>
</figure>
<para>A metric expression may also identify sets of values corresponding to
one-, two-, or three-dimensional slices of this space, according to the following
rules:</para>
<orderedlist><listitem><para>A metric expression consists of a PCP metric
name, followed by optional host specifications, followed by optional instance
specifications, and finally, optional sample time specifications.</para>
</listitem><listitem><para>A host specification consists of one or more host
names, each prefixed by a colon (<literal>:</literal>). For example: <literal>
:indy :far.away.domain.com :localhost</literal></para>
</listitem><listitem><para>A missing host specification implies the default <command>
pmie</command> source of metrics, as defined by a <literal>-h</literal> option
on the command line, or the first named archive in an <literal>-a</literal>
option on the command line, or PMCD on the local host.</para>
</listitem><listitem><para>An instance specification consists of one or more
instance names, each prefixed by a hash or pound (<literal>#</literal>) sign.
For example: <literal>#ec0 #ec2</literal></para>
<para>Recall that you can discover the instance names for a particular metric,
using the <command>pminfo</command> command. See <xref linkend="LE23271-PARENT">.
</para>
<para>Within the <command>pmie</command> grammar, an instance name is an identifier.
If the instance name contains characters other than alphanumeric characters,
enclose the instance name in single quotes; for example, <literal>#'/dev/root'
#'/dev/usr'</literal></para>
</listitem><listitem><para>A missing instance specification implies all instances
for the associated performance metric from each associated <command>pmie</command>
source of metrics.</para>
</listitem><listitem><para>A sample time specification consists of either
a single time or a range of times. A single time is represented as an at (<literal>
@</literal>) followed by a natural number. A range of times is an at (<literal>
@</literal>), followed by a natural number, followed by two periods (<literal>
..</literal>) followed by a second natural number. The ordering of the end
points in a range is immaterial. For example, <literal>@0..9</literal> specifies
the last 10 sample times.</para>
</listitem><listitem><para>A missing sample time specification implies the
most recent sample time.</para>
</listitem></orderedlist>
<para>The following metric expression refers to a three-dimensional set of
values, with two hosts in one dimension, five sample times in another, and
the number of instances in the third dimension being determined by the number
of configured disk spindles on the two hosts.</para>
<literallayout>disk.dev.read :foo :bar @0..4</literallayout>
</section>
<section id="LE59099-PARENT">
<title id="LE59099-TITLE"><command>pmie</command> Rate Conversion</title>
<para><indexterm id="ITch06-14"><primary>pmie tool</primary><secondary>rate
conversion</secondary></indexterm><indexterm><primary>rate conversion</primary>
</indexterm>Many of the metrics delivered by the PMCS are cumulative counters.
Consider the following metric:</para>
<literallayout>disk.all.total </literallayout>
<?Pub _newpage>
<para>A single value for this metric tells you only that a certain number
of disk I/O operations have occurred since boot time, and that information
may be invalid if the counter has exceeded its 32-bit range and wrapped. You
need at least two values, sampled at known times, to compute the recent rate
at which the I/O operations are being executed. The required syntax would
be this:</para>
<literallayout>(disk.all.total @0 - disk.all.total @1) / delta </literallayout>
<para>The accuracy of <literal>delta</literal> as a measure of actual inter-sample
delay is an issue. <command>pmie</command> requests samples, at intervals
of approximately <literal>delta</literal>, while the results exported to the
PMCS are time stamped with the high-resolution system clock time when the
samples were exported. For these reasons, a built-in and implicit rate conversion
using accurate time stamps is provided by <command>pmie</command> for performance
metrics that have counter semantics. For example, the following expression
is unconditionally converted to a rate by <command>pmie</command>.</para>
<literallayout>disk.all.total </literallayout>
</section>
<section>
<title><command>pmie</command> Arithmetic Expressions</title>
<para><indexterm id="ITch06-15"><primary>pmie tool</primary><secondary>arithmetic
expressions</secondary></indexterm><indexterm><primary>arithmetic expressions
</primary></indexterm>Within <command>pmie</command>, simple arithmetic expressions
are constructed from metrics expressions (see <xref linkend="LE73508-PARENT">)
and numeric constants, using all of the arithmetic operators and precedence
rules of the C programming language.</para>
<para>All <command>pmie</command> arithmetic is performed in double precision.
</para>
<para><xref linkend="LE87294-PARENT">, describes additional operators that
may be used for aggregate operations to reduce the dimensionality of an arithmetic
expression.</para>
</section>
<section>
<title><command>pmie</command> Logical Expressions</title>
<para><indexterm id="ITch06-16"><primary>pmie tool</primary><secondary>logical
expressions</secondary></indexterm><indexterm><primary>logical expressions
</primary></indexterm>A number of logical expression types are supported:
</para>
<itemizedlist>
<listitem><para>Logical constants</para>
</listitem>
<listitem><para>Relational expressions</para>
</listitem>
<listitem><para>Boolean expressions</para>
</listitem>
<listitem><para>Quantification operators</para>
</listitem></itemizedlist>
<section>
<title>Logical Constants</title>
<para><indexterm><primary>logical constants</primary></indexterm>Like in the
C programming language, <command>pmie</command> interprets an arithmetic value
of zero to be false, and all other arithmetic values are considered true.
</para>
</section>
<section>
<title>Relational Expressions</title>
<para><indexterm><primary>relational expressions</primary></indexterm>Relational
expressions are the simplest form of logical expression, in which values may
be derived from arithmetic expressions using <command>pmie</command> relational
operators. For example, the following is a relational expression that is true
or false, depending on the aggregate total of disk read operations per second
being greater than 50.</para>
<literallayout>disk.all.read > 50 count/sec</literallayout>
<para>All of the relational logical operators and precedence rules of the
C programming language are supported in <command>pmie</command>.</para>
<para>As described in <xref linkend="LE73508-PARENT">, arithmetic expressions
in <command>pmie</command> may assume set values. The relational operators
are also required to take constant, singleton, and set-valued expressions
as arguments. The result has the same dimensionality as the operands. Suppose
the rule in <xref linkend="Z983832325sdc"> is given:</para>
<example id="Z983832287sdc"><title id="Z983832325sdc">Relational Expressions
</title>
<literallayout format="yes"><userinput>hosts = ":gonzo";</userinput>
<userinput>intfs = "#ec0 #ec2";</userinput>
<userinput>all_intf = network.interface.in.packets</userinput>
               <userinput>$hosts $intfs @0..2 > 300 count/sec;</userinput></literallayout>
<para>Then the execution of <command>pmie</command> may proceed as follows:
</para>
<literallayout format="yes"><userinput>pmie -V uag.11</userinput>
all_intf: 
       gonzo: [ec0]      ?      ?      ? 
       gonzo: [ec2]      ?      ?      ?
all_intf:
       gonzo: [ec0]  false      ?      ?
       gonzo: [ec2]  false      ?      ?
all_intf:
       gonzo: [ec0]   true  false      ?
       gonzo: [ec2]  false  false      ?
all_intf:
       gonzo: [ec0]   true   true  false
       gonzo: [ec2]  false  false  false</literallayout>
</example>
<para>At each sample, the relational operator greater than (>) produces six
truth values for the cross-product of the <literal>instance</literal> and <literal>
sample time</literal> dimensions.</para>
<para><xref linkend="LE97708-PARENT">, describes additional logical operators
that may be used to reduce the dimensionality of a relational expression.
</para>
</section>
<section>
<title>Boolean Expressions</title>
<para><indexterm><primary>Boolean expressions</primary></indexterm>The regular
Boolean operators from the C programming language are supported: conjunction
(<literal>&amp;&amp;</literal>), disjunction (<literal>||</literal>) and negation
(<literal>!</literal>).</para>
<para>As with the relational operators, the Boolean operators accommodate
set-valued operands, and set-valued results.</para>
</section>
<section id="LE97708-PARENT">
<title id="LE97708-TITLE">Quantification Operators</title>
<para><indexterm><primary>quantification operators</primary></indexterm><indexterm>
<primary>operators</primary></indexterm>Boolean and relational operators may
accept set-valued operands and produce set-valued results. In many cases,
rules that are appropriate for performance management require a set of truth
values to be reduced along one or more of the dimensions of hosts, instances,
and sample times described in <xref linkend="LE73508-PARENT">. The <command>
pmie</command> quantification operators perform this function.</para>
<para>Each quantification operator takes a one-, two-, or three-dimension
set of truth values as an operand, and reduces it to a set of smaller dimension,
by quantification along a single dimension. For example, suppose the expression
in the previous example is simplified and prefixed by <literal>some_sample
</literal>, to produce the following expression:</para>
<literallayout format="yes"><userinput>intfs = "#ec0 #ec2";</userinput>&ensp;
<userinput>all_intf = some_sample network.interface.in.packets</userinput>
                     <userinput>$intfs @0..2 > 300 count/sec;</userinput></literallayout>
<para>Then the expression result is reduced from six values to two (one per
interface instance), such that the result for a particular instance will be
false unless the relational expression for the same interface instance is
true for at least one of the preceding three sample times.</para>
<para>There are existential, universal, and percentile quantification operators
in each of the <replaceable>host</replaceable>, <replaceable>instance</replaceable>,
and <replaceable>sample time</replaceable> dimensions to produce the nine
operators as follows:</para>
<deflist>
<deflistentry>
<term><literal>some_host</literal></term>
<listitem><para>True if the expression is true for at least one <replaceable>
host</replaceable> for the same <replaceable>instance</replaceable> and <literal>
sample time</literal>.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>all_host</literal></term>
<listitem><para>True if the expression is true for every <replaceable>host
</replaceable> for the same <replaceable>instance</replaceable> and <replaceable>
sample time</replaceable>.</para>
</listitem></deflistentry>
<deflistentry>
<term><replaceable>N</replaceable><literal>%</literal><literal>_host</literal></term>
<listitem><para>True if the expression is true for at least <replaceable>
N</replaceable>% of the <replaceable>hosts</replaceable> for the same <replaceable>
instance</replaceable> and <replaceable>sample time</replaceable>.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>some_inst</literal></term>
<listitem><para>True if the expression is true for at least one <replaceable>
instance</replaceable> for the same <replaceable>host</replaceable> and <replaceable>
sample time</replaceable>.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>all_instance</literal></term>
<listitem><para>True if the expression is true for every <replaceable>instance
</replaceable> for the same <replaceable>host</replaceable> and <replaceable>
sample time</replaceable>.</para>
</listitem></deflistentry>
<deflistentry>
<term><replaceable>N</replaceable><literal>%</literal><literal>_instance</literal></term>
<listitem><para>True if the expression is true for at least <replaceable>
N</replaceable>% of the <replaceable>instances</replaceable> for the same <replaceable>
host</replaceable> and <replaceable>sample time</replaceable>.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>some_sample time</literal></term>
<listitem><para>True if the expression is true for at least one <replaceable>
sample time</replaceable> for the same <replaceable>host</replaceable> and <replaceable>
instance</replaceable>.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>all_sample time</literal></term>
<listitem><para>True if the expression is true for every <replaceable>sample
time</replaceable> for the same <replaceable>host</replaceable> and <replaceable>
instance</replaceable>.</para>
</listitem></deflistentry>
<deflistentry>
<term><replaceable>N</replaceable><literal>%</literal><literal>_sample time
</literal></term>
<listitem><para>True if the expression is true for at least <replaceable>
N</replaceable>% of the <replaceable>sample times</replaceable> for the same <replaceable>
host</replaceable> and <replaceable>instance</replaceable>.</para>
</listitem></deflistentry>
</deflist>
<para>These operators may be nested. For example, the following expression
answers the question: &ldquo;Are all hosts experiencing at least 20% of their
disks busy either reading or writing?&rdquo;</para>
<literallayout>Servers = ":moomba :babylon";
all_host ( 
    20%_inst disk.dev.read $Servers > 40 || 
    20%_inst disk.dev.write $Servers > 40
); </literallayout>
<para>The following expression uses different syntax to encode the same semantics:
</para>
<literallayout>all_host (
    20%_inst (
        disk.dev.read $Servers > 40 ||
        disk.dev.write $Servers > 40
    )
);</literallayout>
<note><para>To avoid confusion over precedence and scope for the quantification
operators, use explicit parentheses.</para>
</note>
<para>Two additional quantification operators are available for the instance
dimension only, namely <literal>match_inst</literal> and <literal>nomatch_inst
</literal>, that take a regular expression and a boolean expression. The result
is the boolean AND of the expression and the result of matching (or not matching)
the associated instance name against the regular expression.</para>
<para>For example, this rule evaluates error rates on various 10BaseT Ethernet
network interfaces (such as ecN, etN, or efN):</para>
<literallayout width="wide">some_inst
                  match_inst "^(ec|et|ef)"
                      network.interface.total.errors > 10 count/sec
-> syslog "Ethernet errors:" " %i"</literallayout>
</section>
</section>
<section>
<title><command>pmie</command> Rule Expressions</title>
<para><indexterm><primary>rule expressions</primary></indexterm>Rule expressions
for <command>pmie</command> have the following syntax:</para>
<literallayout>lexpr -> <replaceable>actions</replaceable> ;</literallayout>
<para>The semantics are as follows:</para>
<itemizedlist>
<listitem><para>If the logical expression <literal>lexpr</literal> evaluates <literal>
true</literal>, then perform the <replaceable>actions</replaceable> that follow.
Otherwise, do not perform the <replaceable>actions</replaceable>.</para>
</listitem>
<listitem><para>It is required that <literal>lexpr</literal> has a singular
truth value. Aggregation and quantification operators must have been applied
to reduce multiple truth values to a single value.</para>
</listitem>
<listitem><para>When executed, an <replaceable>action</replaceable> completes
with a success/failure status.</para>
</listitem>
<listitem><para>One or more <replaceable>actions</replaceable> may appear;
consecutive <replaceable>actions</replaceable> are separated by operators
that control the execution of subsequent <replaceable>actions</replaceable>,
as follows:</para>
<deflist id="Z926963018sdc">
<deflistentry>
<term><replaceable>action-1 </replaceable><literal>&amp;</literal></term>
<listitem><para>Always execute subsequent actions (serial execution).</para>
</listitem></deflistentry>
<deflistentry>
<term><replaceable>action-1 </replaceable><userinput>|</userinput> </term>
<listitem><para>If <replaceable>action-1</replaceable> fails, execute subsequent
actions, otherwise skip the subsequent actions (alternation).</para>
</listitem></deflistentry>
</deflist>
</listitem></itemizedlist>
<para>An <replaceable>action</replaceable> is composed of a keyword to identify
the action method, an optional <replaceable>time</replaceable> specification,
and one or more arguments.</para>
<para>A <replaceable>time</replaceable> specification uses the same syntax
as a valid time interval that may be assigned to <literal>delta</literal>,
as described in <xref linkend="LE88708-PARENT">. If the <replaceable>action
</replaceable> is executed and the <replaceable>time</replaceable> specification
is present, <command>pmie</command> will suppress any subsequent execution
of this <replaceable>action</replaceable> until the wall clock time has advanced
by <replaceable>time</replaceable>.</para>
<para>The arguments are passed directly to the action method.</para>
<para>The following action methods are provided:</para>
<deflist>
<deflistentry>
<term><literal>shell</literal></term>
<listitem><para>The single argument is passed to the shell for execution.
This <replaceable>action</replaceable> is implemented using <literal>system
</literal> in the background. The <replaceable>action</replaceable> does not
wait for the system call to return, and succeeds unless the fork fails.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>alarm</literal></term>
<listitem><para><indexterm><primary>DISPLAY variable</primary></indexterm>A
notifier containing a time stamp, a single <replaceable>argument</replaceable>
as a message, and a <interface class="BUTTON">Cancel</interface> button is
posted on the current display screen (as identified by the <literal>DISPLAY
</literal> environment variable). Each alarm <replaceable>action</replaceable>
first checks if its notifier is already active. If there is an identical active
notifier, a duplicate notifier is not posted. The action succeeds unless the
fork fails.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>syslog</literal></term>
<listitem><para><indexterm><primary>pmlogger tool</primary></indexterm><indexterm>
<primary>syslog function</primary></indexterm>A message is written into the
system log. If the first word of the first argument is <literal>-p</literal>,
the second word is interpreted as the priority (see the <command sectionref="3">
syslog</command> man page); the message tag is <literal>pcp-pmie</literal>.
The remaining argument is the message to be written to the system log. The
action succeeds unless the fork fails.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>print</literal></term>
<listitem><para><indexterm><primary>time-stamped message</primary></indexterm>A
message containing a time stamp in <command>ctime</command> format and the
argument is displayed out to standard output (<command>stdout</command>).
This action always succeeds.</para>
</listitem></deflistentry>
</deflist>
<para>Within the argument passed to an action method, the following expansions
are supported to allow some of the context from the logical expression on
the left to appear to be embedded in the argument:</para>
<deflist termlength="narrow">
<deflistentry>
<term><literal>%h</literal></term>
<listitem><para>The value of a <replaceable>host</replaceable> that makes
the expression true.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>%i</literal></term>
<listitem><para>The value of an <replaceable>instance</replaceable> that makes
the expression true.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>%v</literal></term>
<listitem><para>The value of a performance metric from the logical expression.
</para>
</listitem></deflistentry>
</deflist>
<para><indexterm><primary>pmie tool</primary><secondary>%-token</secondary>
</indexterm>Some ambiguity may occur in respect to which host, instance, or
performance metric is bound to a %-token. In most cases, the leftmost binding
in the top-level subexpression is used. You may need to use <command>pmie
</command> in the interactive debugging mode (specify the <literal>-d</literal>
command line option) in conjunction with the <literal>-W</literal> command
line option to discover which subexpressions contributes to the %-token bindings.
</para>
<para><xref linkend="Z983833509sdc"> illustrates some of the options when
constructing rule expressions:</para>
<example id="Z983833504sdc"><title id="Z983833509sdc">Rule Expression Options
</title>
<literallayout width="wide">some_inst ( disk.dev.total > 60 ) 
       -> syslog 10 mins "[%i] busy, %v IOPS " &amp; 
          shell 1 hour "echo \ 
               'Disk %i is REALLY busy. Running at %v I/Os per second' \ 
               | Mail -s 'pmie alarm' sysadm"; </literallayout>
</example>
<para><indexterm><primary>/var/log/messages file</primary></indexterm>In this
case, <literal>%v</literal> and <literal>%i</literal> are both associated
with the instances for the metric <literal>disk.dev.total</literal> that make
the expression true. If more than one instance makes the expression true (more
than one disk is busy), then the argument is formed by concatenating the result
from each %-token binding. The text added to <filename><?Pub _nolinebreak>/var/log/messages<?Pub /_nolinebreak></filename>
might be as shown in <xref linkend="Z983833476sdc">:</para>
<example id="Z983833442sdc"><title id="Z983833476sdc"><filename>/var/log/messages
</filename> Text</title>
<literallayout width="wide">Aug 6 08:12:44 5B:gonzo pcp-pmie[3371]:
                         [dks0d1] busy, 3.7 IOPS [dks0d2] busy, 0.3 IOPS</literallayout>
</example>
<note><para>When <command>pmie</command> is processing performance metrics
from a PCP archive log, the <replaceable>actions</replaceable> will be processed
in the expected manner; however, the action methods are modified to report
a textual facsimile of the <replaceable>action</replaceable> on the standard
output.</para>
</note>
<para>Consider the rule in <xref linkend="Z983833391sdc">:</para>
<example id="Z983833364sdc"><title id="Z983833391sdc">Standard Output</title>
<literallayout width="wide">delta = 2 sec;  // more often for demonstration purposes 
percpu  = "kernel.percpu"; 
// Unusual usr-sys split when some CPU is more than 20% in usr mode 
// and sys mode is at least 1.5 times usr mode 
// 
cpu_usr_sys = some_inst ( 
        $percpu.cpu.sys > $percpu.cpu.user * 1.5 &amp;&amp; 
        $percpu.cpu.user > 0.2 
   ) ->  alarm "Unusual sys time: " "%i "; </literallayout>
<para>When evaluated against an archive, the following output is generated
(the alarm action produces a message on standard output):</para>
<literallayout><userinput>pmafm /tmp/f4 pmie cpu.head cpu.00</userinput>
alarm Wed Aug  7 14:54:48 2002: Unusual sys time: cpu0 
alarm Wed Aug  7 14:54:50 2002: Unusual sys time: cpu0 
alarm Wed Aug  7 14:54:52 2002: Unusual sys time: cpu0 
alarm Wed Aug  7 14:55:02 2002: Unusual sys time: cpu0 
alarm Wed Aug  7 14:55:06 2002: Unusual sys time: cpu0 </literallayout>
</example>
</section>
<section id="LE87294-PARENT">
<title id="LE87294-TITLE"><command>pmie</command> Intrinsic Operators</title>
<para><indexterm id="ITch06-17"><primary>pmie tool</primary><secondary>intrinsic
operators</secondary></indexterm><indexterm><primary>intrinsic operators</primary>
</indexterm>The following sections describe some other useful intrinsic operators
for <command>pmie</command>. These operators are divided into three groups:
</para>
<itemizedlist>
<listitem><para>Arithmetic aggregation</para>
</listitem>
<listitem><para>The <literal>rate</literal> operator</para>
</listitem>
<listitem><para>Transitional operators</para>
</listitem></itemizedlist>
<section>
<title>Arithmetic Aggregation</title>
<para><indexterm><primary>pmie tool</primary><secondary>arithmetic aggregation
</secondary></indexterm><indexterm><primary>arithmetic aggregation</primary>
</indexterm>For set-valued arithmetic expressions, the following operators
reduce the dimensionality of the result by arithmetic aggregation along one
of the <replaceable>host</replaceable>, <replaceable>instance</replaceable>,
or <replaceable>sample time</replaceable> dimensions. For example, to aggregate
in the <replaceable>host</replaceable> dimension, the following operators
are provided:</para>
<deflist>
<deflistentry>
<term><literal>avg_host</literal></term>
<listitem><para><indexterm><primary>avg_host operator</primary></indexterm>Computes
the average value across all <replaceable>instances</replaceable> for the
same <replaceable>host</replaceable> and <replaceable>sample time</replaceable></para>
</listitem></deflistentry>
<deflistentry>
<term><literal>sum_host</literal></term>
<listitem><para><indexterm><primary>sum_host operator</primary></indexterm>Computes
the total value across all <replaceable>instances</replaceable> for the same <replaceable>
host</replaceable> and <replaceable>sample time</replaceable></para>
</listitem></deflistentry>
<deflistentry>
<term><literal>count_host</literal></term>
<listitem><para><indexterm><primary>count_host operator</primary></indexterm>Computes
the number of values across all <replaceable>instances</replaceable> for the
same <replaceable>host</replaceable> and <replaceable>sample time</replaceable></para>
</listitem></deflistentry>
<deflistentry>
<term><literal>min_host</literal></term>
<listitem><para><indexterm><primary>min_host operator</primary></indexterm>Computes
the minimum value across all <replaceable>instances</replaceable> for the
same <replaceable>host</replaceable> and <replaceable>sample time</replaceable></para>
</listitem></deflistentry>
<deflistentry>
<term><literal>max_host</literal></term>
<listitem><para><indexterm><primary>max_host operator</primary></indexterm>Computes
the maximum value across all <replaceable>instances</replaceable> for the
same <replaceable>host</replaceable> and <replaceable>sample time</replaceable></para>
</listitem></deflistentry>
</deflist>
<para><indexterm><primary>*_inst operator</primary></indexterm><indexterm>
<primary>*_sample operator</primary></indexterm>Ten additional operators correspond
to the forms <literal>*_inst</literal> and <literal>*_sample</literal>.</para>
<para>The following example illustrates the use of an aggregate operator in
combination with an existential operator to answer the question &ldquo;Does
some host currently have two or more busy processors?&rdquo;</para>
<literallayout>// note '' to escape - in host name 
poke = ":moomba :'mac-larry' :bitbucket"; 
some_host ( 
    count_inst ( kernel.percpu.cpu.user $poke + 
                 kernel.percpu.cpu.sys $poke > 0.7 ) >= 2 
    ) 
       -> alarm "2 or more busy CPUs"; </literallayout>
</section>
<section>
<title>The <command>rate</command> Operator</title>
<para><indexterm><primary>pmie tool</primary><secondary>rate operator</secondary>
</indexterm><indexterm><primary>rate operator</primary></indexterm>The <literal>
rate</literal> operator computes the rate of change of an arithmetic expression
as shown in the following example:</para>
<literallayout>rate mem.freemem </literallayout>
<para>It returns the rate of change for the <literal>mem.freemem</literal>
performance metric; that is, the rate at which free physical memory is being
allocated or released.</para>
<para>The <literal>rate</literal> intrinsic operator is most useful for metrics
with instantaneous value semantics. For metrics with counter semantics, <command>
pmie</command> already performs an implicit rate calculation (see the <xref
linkend="LE59099-PARENT">) and the <literal>rate</literal> operator would
produce the second derivative with respect to time, which is less likely to
be useful.</para>
</section>
<section>
<title>Transitional Operators</title>
<para><indexterm><primary>pmie tool</primary><secondary>transitional operators
</secondary></indexterm><indexterm><primary>transitional operators</primary>
</indexterm>In some cases, an action needs to be triggered when an expression
changes from true to false or vice versa. The following operators take a logical
expression as an operand, and return a logical expression:</para>
<deflist>
<deflistentry>
<term><literal>rising</literal></term>
<listitem><para>Has the value <literal>true</literal> when the operand transitions
from <literal>false</literal> to <literal>true</literal> in consecutive samples.
</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>falling</literal></term>
<listitem><para>Has the value <literal>false</literal> when the operand transitions
from <literal>true</literal> to <literal>false</literal> in consecutive samples.
</para>
</listitem></deflistentry>
</deflist>
</section>
</section>
</section>
<section id="LE60280-PARENT">
<title id="LE60280-TITLE"><command>pmie</command> Examples</title>
<para><indexterm id="ITch06-18"><primary>pmie tool</primary><secondary>real
examples</secondary></indexterm>The examples presented in this section are
task-oriented and use the full power of the <command>pmie</command> specification
language as described in <xref linkend="LE90227-PARENT">.</para>
<para><indexterm><primary>pcp.sw.demo subsystems</primary></indexterm><indexterm>
<primary>/var/pcp/demos/pmie file</primary></indexterm>Source code for the <command>
pmie</command> examples in this chapter, and many more examples, is provided
in the PCP subsystem <filename>pcp-2.3&ndash;<replaceable>rev</replaceable></filename>,
and when installed may be found in <filename>/usr/share/pcp/examples/pmie
</filename>. <xref linkend="Z978985046sdc"> and <xref linkend="Z984413965sdc">
illustrate monitoring CPU utilization and disk activity.</para>
<example id="Z928441343sdc"><title id="Z978985046sdc">Monitoring CPU Utilization
</title>
<literallayout width="wide" format="yes">// Some Common Performance Monitoring Scenarios
//
// The CPU Group
//
delta = 2 sec;  // more often for demonstration purposes
// common prefixes
//
percpu  = "kernel.percpu";
all     = "kernel.all";
// Unusual usr-sys split when some CPU is more than 20% in usr mode
// and sys mode is at least 1.5 times usr mode
//
cpu_usr_sys =
       some_inst (
           $percpu.cpu.sys > $percpu.cpu.user * 1.5 &amp;&amp;
           $percpu.cpu.user > 0.2
       )
           ->  alarm "Unusual sys time: " "%i ";
// Over all CPUs, syscall_rate > 1000 * no_of_cpus
//
cpu_syscall =
       $all.syscall > 1000 count/sec * hinv.ncpu
       ->  print "high aggregate syscalls: %v";
// Sustained high syscall rate on a single CPU
//
delta = 30 sec;
percpu_syscall =
       some_inst (
           $percpu.syscall > 2000 count/sec
       )
           -> syslog "Sustained syscalls per second? " "[%i] %v ";
// the 1 minute load average exceeds 5 * number of CPUs on any host
hosts = ":gonzo :moomba";   // change as required
delta = 1 minute;           // no need to evaluate more often than this
high_load =
     some_host (
           $all.load $hosts #'1 minute' > 5 * hinv.ncpu
       )
           -> alarm "High Load Average? " "%h: %v ";</literallayout>
</example>
<example id="Z928441176sdc"><title id="Z984413965sdc">Monitoring Disk Activity
</title>
<literallayout width="wide" format="yes">// Some Common Performance Monitoring Scenarios
//
// The Disk Group
//
delta = 15 sec;         // often enough for disks?
// common prefixes
//
disk    = "disk";
// Any disk performing more than 40 I/Os per second, sustained over
// at least 30 seconds is probably busy
//
delta = 30 seconds;
disk_busy =
       some_inst (
           $disk.dev.total > 40 count/sec
       )
]      -> shell "Mail -s 'Heavy systained disk traffic' sysadm";
// Try and catch bursts of activity ... more than 60 I/Os per second
// for at least 25% of 8 consecutive 3 second samples
//
delta = 3 sec;
disk_burst =
       some_inst (
           25%_sample (
               $disk.dev.total @0..7 > 60 count/sec
           )
       )
       -> alarm "Disk Burst? " "%i ";
// any SCSI disk controller performing more than 3 Mbytes per
// second is busy
// Note: the obscure 512 is to convert blocks/sec to byte/sec,
//       and pmie handles the rest of the scale conversion
//
some_inst $disk.ctl.blktotal * 512 > 3 Mbyte/sec
           -> alarm "Busy Disk Controller: " "%i ";</literallayout>
</example>
</section>
<section id="LE31514-PARENT">
<title id="LE31514-TITLE">Developing and Debugging <command>pmie</command>
Rules</title>
<para> <indexterm id="ITch06-20"><primary>pmie tool</primary><secondary>developing
rules</secondary></indexterm>Given the <literal>-d</literal> command line
option, <command>pmie</command> executes in interactive mode, and the user
is presented with a menu of options:</para>
<literallayout width="wide">pmie debugger commands
     f [file-name]      - load expressions from given file or stdin
     l [expr-name]      - list named expression or all expressions
     r [interval]       - run for given or default interval
     S time-spec        - set start time for run
     T time-spec        - set default interval for run command
     v [expr-name]      - print subexpression for %h, %i and %v bindings
     h or ?             - print this menu of commands
     q                  - quit
pmie> </literallayout>
<para>If both the <literal>-d</literal> option and a filename are present,
the expressions in the given file are loaded before entering interactive mode.
Interactive mode is useful for debugging new rules.</para>
</section>
<section id="LE91221-PARENT">
<title id="LE91221-TITLE">Caveats and Notes on <command>pmie</command></title>
<para><indexterm><primary>caveats</primary></indexterm>The following sections
provide important information for users of <command>pmie</command>.</para>
<section>
<title>Performance Metrics Wraparound</title>
<para><indexterm id="ITch06-21"><primary>performance metric wraparound</primary>
</indexterm><indexterm><primary>PCP_COUNTER_WRAP variable</primary></indexterm><indexterm>
<primary>metric wraparound</primary></indexterm>Performance metrics that are
cumulative counters may occasionally overflow their range and wraparound to
0. When this happens, an unknown value (printed as <literal>?</literal>) is
returned as the value of the metric for one sample (recall that the value
returned is normally a rate). You can have PCP interpolate a value based on
expected rate of change by setting the <literal>PCP_COUNTER_WRAP</literal>
environment variable.</para>
</section>
<section>
<title><command>pmie</command> Sample Intervals</title>
<para><indexterm id="ITch06-22"><primary>pmie tool</primary><secondary>sample
intervals</secondary></indexterm><indexterm><primary>sample intervals</primary>
</indexterm>The sample interval (<literal>delta</literal>) should always be
long enough, particularly in the case of rates, to ensure that a meaningful
value is computed. Interval may vary according to the metric and your needs.
A reasonable minimum is in the range of ten seconds or several minutes. Although
the PMCS supports sampling rates up to hundreds of times per second, using
small sample intervals creates unnecessary load on the monitored system.</para>
</section>
<section>
<title><command>pmie</command> Instance Names</title>
<para><indexterm id="ITch06-23"><primary>pmie tool</primary><secondary>instance
names</secondary></indexterm>When you specify a metric instance name (<literal>
#</literal><replaceable>identifier</replaceable>) in a <command>pmie</command>
expression, it is compared against the instance name supplied by the PMCS
as follows:</para>
<itemizedlist>
<listitem><para>If the given instance name and the PMCS name are the same,
they are considered to match.</para>
</listitem>
<listitem><para>Otherwise, the first two space separated tokens are extracted
from the PMCS name. If the given instance name is the same as either of these
tokens, they are considered a match.</para>
</listitem></itemizedlist>
<para>For some metrics, notably the per process (<literal>proc.xxx.xxx</literal>)
metrics, the first token in the PMCS instance name is impossible to determine
at the time you are writing <command>pmie</command> expressions. The above
policy circumvents this problem.</para>
</section>
<section>
<title><command>pmie</command> Error Detection</title>
<para><indexterm id="ITch06-24"><primary>pmie tool</primary><secondary>error
detection</secondary></indexterm><indexterm><primary>error detection</primary>
</indexterm>The parser used in <command>pmie</command> is currently not robust
in handling syntax errors. It is suggested that you check any problematic
expressions individually in interactive mode:</para>
<literallayout format="yes"><userinput>pmie -v -d</userinput>
pmie> f
<replaceable>expression</replaceable>
<userinput>Ctrl+D</userinput></literallayout>
<para>If the expression was parsed, its internal representation is shown:
</para>
<literallayout>pmie> <userinput>l</userinput></literallayout>
<para>The expression is evaluated twice and its value printed:</para>
<literallayout>pmie> <userinput>r 10sec</userinput></literallayout>
<para>Then quit:</para>
<literallayout>pmie> <userinput>q</userinput></literallayout>
<para>It is not always possible to detect semantic errors at parse time. This
happens when a performance metric descriptor is not available from the named
host at this time. A warning is issued, and the expression is put on a wait
list. The wait list is checked periodically (about every five minutes) to
see if the metric descriptor has become available. If an error is detected
at this time, a message is printed to the standard error stream (<command>
stderr</command>) and the offending expression is put aside.</para>
</section>
</section>
<section id="Z927039566sdc">
<title id="Z984414261sdc">Creating <command>pmie</command> Rules with <command>
pmieconf</command></title>
<para><indexterm><primary>pmie tool</primary><secondary>pmieconf rules</secondary>
</indexterm><indexterm><primary>pmieconf tool</primary><secondary>rules</secondary>
</indexterm>The <command>pmieconf</command> tool is a command line utility
that is designed to aid the specification of <command>pmie</command> rules
from parameterized versions of the rules. <command>pmieconf</command> is used
to display and modify variables or parameters controlling the details of the
generated <command>pmie</command> rules.</para>
<para><command>pmieconf</command> reads two different forms of supplied input
files and produces a localized <command>pmie</command> configuration file
as its output.</para>
<para>The first input form is a generalized <command>pmie</command> rule file
such as those found below <filename><?Pub _nolinebreak>/var/pcp/config/pmieconf/*/*<?Pub /_nolinebreak></filename>.
These files contain the generalized rules which <command>pmieconf</command>
is able to manipulate. Each of the rules can be enabled or disabled, or the
individual variables associated with each rule can be edited.</para>
<para>The second form is an actual <command>pmie</command> configuration file
(that is, a file which can be interpreted by <command>pmie</command>, conforming
to the <command>pmie</command> syntax described in <xref linkend="LE90227-PARENT">).
This file is both input to and output from <command>pmieconf</command>.</para>
<para>The input version of the file contains any changed variables or rule
states from previous invocations of <command>pmieconf</command>, and the output
version contains both the changes in state (for any subsequent <command>pmieconf
</command> sessions) and the generated <command>pmie</command> syntax. The <command>
pmieconf</command> state is embedded within a <command>pmie</command> comment
block at the head of the output file and is not interpreted by <command>pmie
</command> itself.</para>
<para><indexterm><primary>pmie tool</primary><secondary>procedures</secondary>
</indexterm><command>pmieconf</command> is an integral part of the <command>
pmie</command> daemon management process described in <xref linkend="Z927039824sdc">. <xref
linkend="Z984414095sdc"> and <xref linkend="Z984414130sdc"> introduce the <command>
pmieconf</command> tool through a series of typical operations.</para>
<procedure id="Z930357839sdc"><title id="Z984414095sdc">Display <command>
pmieconf</command> Rules</title>
<orderedlist><listitem><para>Start <command>pmieconf</command> interactively.<literallayout
width="wide" format="yes">$ pmieconf -f /tmp/pmiefile
Updates will be made to /tmp/pmiefile

pmieconf></literallayout></para>
</listitem><listitem><para>List the set of available <command>pmieconf</command>
rules by using the <command>rules</command> command.</para>
</listitem><listitem><para>List the set of rule groups using the <command>
groups</command> command.</para>
</listitem><listitem><para>List only the enabled rules, using the <command>
rules enabled</command> command.</para>
</listitem><listitem><para>List a single rule:</para>
<literallayout width="wide" format="yes">pmieconf> list memory.swap_low
   rule: memory.swap_low  [Low free swap space]
   help: There is only threshold percent swap space remaining - the system
         may soon run out of virtual memory.  Reduce the number and size of
         the running programs or add more swap(1) space before it
completely
         runs out.
         predicate =
           some_host (
               ( 100 * ( swap.free $hosts$ / swap.length $hosts$ ) )
                 &lt; $threshold$
               &amp;&amp; swap.length $hosts$ > 0        // ensure swap in use
            )
   vars: enabled = no
         threshold = 10%

pmieconf></literallayout>
</listitem><listitem><para>List one rule variable:<literallayout>pmieconf> list memory.swap_low threshold
   rule: memory.swap_low  [Low free swap space]
         threshold = 10%

pmieconf></literallayout></para>
</listitem></orderedlist>
</procedure>
<procedure id="Z930357878sdc"><title id="Z984414130sdc">Modify <command>pmieconf
</command> Rules and Generate a <command>pmie</command> File</title>
<orderedlist><listitem><para>Lower the threshold for the <literal>memory.swap_low
</literal> rule, and also change the <command>pmie</command> sample interval
affecting just this rule. The <literal>delta</literal> variable is special
in that it is not associated with any particular rule; it has been defined
as a global <command>pmieconf</command> variable. Global variables can be
displayed using the <command>list global</command> command to <command>pmieconf
</command>, and can be modified either globally or local to a specific rule.<?Pub _newpage><literallayout>
pmieconf> modify memory.swap_low threshold 5

pmieconf> modify memory.swap_low delta "1 sec"

pmieconf></literallayout></para>
</listitem><listitem><para>Disable all of the rules except for the <literal>
memory.swap_low</literal> rule so that you can see the effects of your change
in isolation.</para>
<para>This produces a relatively simple <command>pmie</command> configuration
file:<literallayout>pmieconf> disable all

pmieconf> enable memory.swap_low

pmieconf> status
  verbose:  off
  enabled rules:  1 of 35
  pmie configuration file:  /tmp/pmiefile
  pmie processes (PIDs) using this file:  (none found)

pmieconf> quit</literallayout></para>
<para>You can also use the <command>status</command> command to verify that
only one rule is enabled at the end of this step.</para>
<para></para>
</listitem><listitem id="Z930357553sdc"><para>Run <command>pmie</command>
with the new configuration file. Use a text editor to view the newly generated <command>
pmie</command> configuration file (<filename>/tmp/pmiefile</filename>), and
then run the command:<literallayout format="yes">$ pmie -T "1.5 sec" -v -l /tmp/log /tmp/pmiefile
memory.swap_low: false

memory.swap_low: false

$ cat /tmp/log
Log for pmie on moomba started Mon Jun 21 16:26:06 2002

pmie: PID = 21847, default host = moomba

[Mon Jun 21 16:26:07] pmie(21847) Info: evaluator exiting

Log finished Mon Jun 21 16:26:07 2002
$</literallayout></para>
</listitem><listitem><para>Notice that both of the <command>pmieconf</command>
files used in the previous step are simple text files, as described in the <command
sectionref="4">pmieconf</command> man page:</para>
<literallayout width="wide">$ file /tmp/pmiefile
/tmp/pmiefile:  PCP pmie config (V.1)
$ file /var/pcp/config/pmieconf/memory/swap_low
/var/pcp/config/pmieconf/memory/swap_low:       PCP pmieconf rules (V.1)</literallayout>
</listitem></orderedlist>
</procedure>
</section>
<section id="Z927039824sdc">
<title>Management of <command>pmie</command> Processes</title>
<para><indexterm><primary>pmie tool</primary><secondary>procedures</secondary>
</indexterm>The <command>pmie</command> process can be run as a daemon as
part of the system startup sequence, and can thus be used to perform automated,
live performance monitoring of a running system. To do this, run these commands
(as superuser):</para>
<literallayout># chkconfig pmie on
# /etc/rc.d/init.d/pmie start</literallayout>
<para>By default, these enable a single <command>pmie</command> process monitoring
the local host, with the default set of <command>pmieconf</command> rules
enabled (for more information about <command>pmieconf</command>, see <xref
linkend="Z984414261sdc"> ). <xref linkend="Z984414202sdc"> illustrates how
you can use these commands to start any number of <command>pmie</command>
processes to monitor local or remote machines.</para>
<procedure id="Z930363467sdc"><title id="Z984414202sdc">Add a New <command>
pmie</command> Instance to the <command>pmie</command> Daemon Management Framework
</title>
<orderedlist><listitem><para>Use a text editor (as superuser) to edit the <command>
pmie</command> control file <filename><?Pub _nolinebreak>/var/pcp/config/pmie/control<?Pub /_nolinebreak></filename>.
Notice the default entry toward the end of the file, which looks like this:
</para>
<literallayout width="wide" format="yes">#Host           S?  Log File                                  Arguments
LOCALHOSTNAME   n   /var/log/pcp/pmie/LOCALHOSTNAME/pmie.log   -c config.default
</literallayout>
<para>This entry is used to enable a local <command>pmie</command> process.
Add a new entry for a remote host on your local network (for example, <literal>
moomba</literal>), by using your <command>pmie</command> configuration file
(see <xref linkend="Z927039566sdc">):</para>
<literallayout width="wide" format="yes">

#Host           S?  Log File                                  Arguments
moomba          n   /var/log/pcp/pmie/moomba/pmie.log          -c /tmp/pmiefile

</literallayout>
</listitem><listitem><para>Enable <command>pmie</command> daemon management: <literallayout>
# chkconfig pmie on</literallayout></para>
<para>This simple step allows <command>pmie</command> to be started as part
of your machine's boot process.</para>
</listitem><listitem><para>Start the two <command>pmie</command> daemons.
At the end of this step, you should see two new <command>pmie</command> processes
monitoring the local and remote hosts:</para>
<literallayout># /etc/rc.d/init.d/pmie start
    Performance Co-Pilot starting inference engine(s) ...

</literallayout>
<para>Wait a few moments while the startup scripts run. The <command>pmie
</command> start script uses the <command>pmie_check</command> script to do
most of its work.</para>
<para>Verify that the <command>pmie</command> processes have started using
the <command>pmie</command> metrics exported by the PMCD PMDA (<literal>wobbly
</literal> is the lo<?Pub Caret>cal host):</para>
<literallayout width="wide" format="yes"># pminfo -f pmcd.pmie.pmcd_host

pmcd.pmie.pmcd_host
    inst [23150 or "23150"] value "wobbly.melbourne.sgi.com"
    inst [23204 or "23204"] value "moomba.melbourne.sgi.com"</literallayout>
</listitem></orderedlist>
</procedure>
<para>If a remote host is not up at the time when <command>pmie</command>
is started, the <command>pmie</command> process may exit. <command>pmie</command>
processes may also exit if the local machine is starved of memory resources.
To counter these adverse cases, it can be useful to have a <command>crontab
</command> entry running. Adding an entry as shown in <xref linkend="Z984414334sdc">,
ensures that if one of the configured <command>pmie</command> processes exits,
it is automatically restarted.</para>
<procedure id="Z930363412sdc"><title id="Z984414334sdc">Add a <command>pmie
</command> <command>crontab</command> Entry</title></procedure>
<orderedlist><listitem><para>Merge the sample <command>pmie</command> <command>
crontab</command> entry with your <literal>root</literal> <command>crontab
</command> entry. The <filename><?Pub _nolinebreak>/var/pcp/config/pmie/crontab<?Pub /_nolinebreak></filename>
file holds this sample entry:<literallayout width="wide" format="yes">$ cat /var/pcp/config/pmie/crontab
#
# standard Performance Co-Pilot crontab entries for a PCP site
# with one or more pmie instances running
#
# every 30 minutes, check pmie instances are running
25,55   *       *       *       *       /usr/share/pcp/bin/pmie_check

</literallayout></para>
</listitem><listitem><para>Use the <command>crontab</command> command and
a text editor to append the sample <command>pmie</command> <command>crontab
</command> entry to <literal>root</literal> <command>crontab</command> file.
This procedure runs the <command>pmie_check</command> script once every thirty
minutes to verify that the <command>pmie</command> instances are running.
If they are not, the procedure restarts them and sends e-mail to <literal>
root</literal> indicating which instances needed restarting.</para>
</listitem></orderedlist>
<section>
<title>Global Files and Directories</title>
<para><indexterm><primary>pmie tool</primary><secondary>global files and directories
</secondary></indexterm>The following global files and directories influence
the behavior of <command>pmie</command> and the <command>pmie</command> management
scripts:</para>
<deflist termlength="nextline" id="Z930361086sdc">
<deflistentry>
<term><filename>/usr/share/pcp/demos/pmie/*</filename></term>
<listitem><para>Contains sample <command>pmie</command> rules that may be
used as a basis for developing local rules.</para>
</listitem></deflistentry>
<deflistentry>
<term><filename>/var/pcp/config/pmie/config.default</filename></term>
<listitem><para>Is the default <command>pmie</command> configuration file
that is used when the <command>pmie</command> daemon facility is enabled.
</para>
</listitem></deflistentry>
<deflistentry>
<term><filename>/var/pcp/config/pmieconf/*/*</filename></term>
<listitem><para>Contains the <command>pmieconf</command> rule definitions
in its subdirectories.</para>
</listitem></deflistentry>
<deflistentry>
<term><filename>/var/pcp/config/pmie/control</filename></term>
<listitem><para>Defines which PCP collector hosts require a daemon <command>
pmie</command> to be launched on the local host, where the configuration file
comes from, where the <command>pmie</command> log file should be created,
and <command>pmie</command> startup options.</para>
</listitem></deflistentry>
<deflistentry>
<term><filename>/var/pcp/config/pmlogger/crontab</filename></term>
<listitem><para>Contains prototype <command>crontab</command> entries that
may be merged with the <command>crontab</command> entries for root to schedule
the periodic execution of the <command>pmie_check</command> script, for verifying
that <command>pmie</command> instances are running.</para>
</listitem></deflistentry>
<deflistentry>
<term><filename>/var/log/pcp/pmie/*</filename></term>
<listitem><para>Contains the <command>pmie</command> log files for the host.
These files are created by the default behavior of the <filename>/etc/rc.d/init.d/pmie
</filename> startup scripts.</para>
</listitem></deflistentry>
</deflist>
</section>
<section>
<title><command>pmie</command> Instances and Their Progress</title>
<para>The PMCD PMDA exports information about executing <command>pmie</command>
instances and their progress in terms of rule evaluations and action execution
rates.</para>
<deflist termlength="wide" id="Z929060000sdc">
<deflistentry>
<term><command>pmie_check</command></term>
<listitem><para>This command is similar to the <command>pmlogger</command>
support script, <command>pmlogger_check</command>.</para>
</listitem></deflistentry>
<deflistentry>
<term><filename>/etc/rc.d/init.d/pmie</filename></term>
<listitem><para>This control file supports the starting and stopping of multiple <command>
pmie</command> instances that are monitoring one or more hosts.</para>
</listitem></deflistentry>
<deflistentry>
<term><filename>/var/tmp/pmie</filename></term>
<listitem><para>The statistics that <command>pmie</command> gathers are maintained
in binary data structure files. These files are in the <filename><?Pub _nolinebreak>/var/tmp/pmie<?Pub /_nolinebreak></filename>
directory.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>pmcd.pmie</literal> metrics</term>
<listitem><para>If <command>pmie</command> is running on a system with a PCP
collector deployment, the PMCD PMDA exports these metrics via the <filename>
pmcd.pmie</filename> group of metrics.</para>
</listitem></deflistentry>
</deflist>
</section>
</section>
</chapter>
<?Pub *0000093398>
