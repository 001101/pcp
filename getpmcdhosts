#! /bin/sh
# 
# Output a list of hosts from the "qa_hosts" file which meet certain
# criteria specified by the options (see _usage).
# The list of QA hosts can be overridden by setting the environment
# variable QA_HOSTS.
#
# Allows QA tests to get hostnames of particular configurations
# that they need.
#
# Copyright (c) 1997-2002 Silicon Graphics, Inc.  All Rights Reserved.
#
# $Id: getpmcdhosts,v 1.40 2004/05/20 02:28:01 pcpqa Exp $
#

. ./common.rc

tmp=/tmp/$$
status=1	# failure is the default!
trap "rm -f $tmp.*; exit \$status" 0 1 2 3 15
HOSTS=qa_hosts
PROBE=pmprobe
BRAND=pmbrand
RSH_USER=pcpqa

_usage()
{
  echo >&2 'Usage: getpmcdhosts [options]

Options:
-a {pmda}                pmda connected to pmcd
-b 32|64                 kernel binary format
-D                       debug/trace (see also -V)
-e big|little            endianess
-i 5.3|6.2|...           version of IRIX
-h hostfile              name of host file, default is qa_hosts
-l none|full|web         PCP collector license
-L                       do not consider localhost
-m {metric}=|<|>{value}  satisfies metric value predicate
-n num                   match first num hosts
-P                       return host running a primary pmlogger
-p multi|single          multi or single processor
-s system                operating system (uname -s)
-v {item}={ver}          version of item
-V                       verbose diagnostics (see also -D)

Legal item:
ipc                 inter-process protocol
libpcp              shared library
pcp                 installation

Most options may be used together but not repeated.
The environment variable QA_STS overrides the default host
file and -h
'
    exit 1
}

# 
# _checkpmcdhost moomba _ 64 6.2 _ _ multi _ 2 _ _
#
# Parameters:
#	host	name
#	agent	name | _
#	binfmt	32 | n32 | 64 | _
#	irix	5.3 | 6.2 | 6.3 | 6.4 | 6.5 | _
#	license	none | full | web | _
#	primary	true | false
#	proc	multi | single | _
#	ipc	1 | 2 | _
#	libpcp	1 | 2 | _
#	pcp	1 | 2 | _
#	msg	true | false
#	system  irix | linux
#	endian	big | small
#

_checkpmcdhost()
{
    HOST=$1
    AGENT=$2
    BINFMT=$3
    IRIX=$4
    LICENSE=$5
    PRIMARY=$6
    PROC=$7
    IPC=$8
    LIBPCP=$9
    PCP=${10}
    MSG=${11}
    SYSTEM=${12}
    ENDIAN=${13}
    ERROR=0

    # check that host has a running pmcd
    #
    if pminfo -h $HOST -f pmcd.agent.status >/dev/null 2>&1
    then
	:
    else
	$MSG && echo "$HOST: No running pmcd" >&2
	return 1
    fi

    # check for running agent
    #
    if [ "$AGENT" != "_" ]
    then
	if $PROBE -h $HOST -I pmcd.agent.type 2>/dev/null | grep $AGENT >/dev/null 2>&1
	then
	    :
        else
	    $MSG && echo "$HOST: $AGENT not running" >&2
	    return 1
        fi
    fi


    # check binfmt
    #
    if [ "$BINFMT" != "_" ]
    then
        # only want 32 or 64 (not ia32 or n32 etc...)
        # if want to be specific then use "-m pmcd.simabi=ia32"
	objfmt=`$PROBE -h $HOST -v pmcd.simabi 2>/dev/null \
		| sed -e 's/\"//g' \
		| $PCP_AWK_PROG 'NF == 3 { print $3 }' \
                | sed -e 's/[a-zA-Z]//g' `

	if [ "$objfmt" != $BINFMT ]
	then
	    $MSG && echo "$HOST: binary format $BINFMT != $objfmt" >&2
	    return 1
	fi
    fi

    # check that rsh works for host -l user
    #
    if [ "$LICENSE" != "_" -o "$IRIX" != "_" ]
    then
	if rsh $HOST -l $RSH_USER date 1>/dev/null 2>&1
	then
	    :
	else
	    if $MSG
	    then
		echo "$0: WARNING: \"rsh $HOST\" -l $RSH_USER failed" >&2
		return 1
	    fi
	fi
    fi

    # check operating system name 
    #
    if [ "$SYSTEM" != "_" ]
    then
	osname=`rsh $HOST -l $RSH_USER uname -s`
        if echo $osname | grep -i $SYSTEM >/dev/null 2>&1 
        then
	    :
        else
	    $MSG && echo "$HOST: system $SYSTEM no match with $osname " >&2
	    return 1;
	fi
    fi


    # check IRIX format
    #
    if [ "$IRIX" != "_" ]
    then
	irixrev=`rsh $HOST -l $RSH_USER uname -r | sed -e 's/-ALPHA.*//' -e 's/ .*//'`
	if [ "$irixrev" != $IRIX ]
	then
	    $MSG && echo "$HOST: IRIX $IRIX != $irixrev" >&2
	    return 1;
	fi
    fi

    # check license
    #
    if [ "$LICENSE" != "_" ]
    then
	$VERBOSE && echo "+ rsh $HOST -l $RSH_USER $BRAND -l"
	license=`rsh $HOST -l $RSH_USER "$BRAND -l" 2>&1`
	$VERBOSE && echo "-> $license"
	if [ "$LICENSE" = "full" ]
	then
	    if echo "$license" | grep "PCP Collector" > /dev/null 2>&1
	    then
		:
	    else
		$MSG && echo "$HOST: No pcp collector license" >&2
		return 1
	    fi
	elif [ "$LICENSE" = "web" ]
	then
	    if echo "$license" | grep "WebMeter Collector" > /dev/null 2>&1
	    then
		:
	    else
		$MSG && echo "$HOST: No webmeter license" >&2
		return 1
	    fi
	elif echo "$license" | grep "Collector" > /dev/null 2>&1
	then
	    $MSG && echo "$HOST: Has a valid license" >&2
	    return 1
	fi
    fi

    # check that host is running primary pmlogger
    #
    if $PRIMARY
    then
	if pminfo -h $HOST -f pmcd.pmlogger.host | grep primary > /dev/null 2>&1
	then
	    :
	else
	    $MSG && echo "$HOST: is _not_ running primary pmlogger" >&2
	    return 1
	fi
    fi

    # check number of processors
    #
    if [ "$PROC" != "_" ]
    then
	$VERBOSE && echo "+ $PROBE -h $HOST -v hinv.ncpu | sed ..."
	ncpu=`$PROBE -h $HOST -v hinv.ncpu 2>/dev/null \
		| sed -e 's/\"//g' \
		| $PCP_AWK_PROG 'NF == 3 && $3 ~ /^[0-9][0-9]*$/ { print $3 }'`
	$VERBOSE && echo "-> $ncpu"

	if [ -z "$ncpu" -o "$ncpu" = 0 ]
	then
	    if $MSG
	    then
		echo "$HOST: Unknown number of processors, pmprobe -> `$PROBE -h $HOST -v hinv.ncpu 2>&1`" >&2
	    fi
	    return 1
	fi
	if [ "$ncpu" -gt 1 -a "$PROC" = "single" ]
	then
	    $MSG && echo "$HOST: Has $ncpu processors" >&2
	    return 1
	elif [ "$ncpu" -eq 1 -a "$PROC" = "multi" ]
	then
	    $MSG && echo "$HOST: Has only one processor" >&2
	    return 1
	fi
    fi

    # check endianess
    #
    if [ "$ENDIAN" != "_" ]
    then
	$VERBOSE && echo "+ echo a | rsh $HOST -l $RSH_USER od -x"
	check=`echo a | rsh $HOST -l $RSH_USER "od -x" 2>&1 | sed -e 's/^0[^ ]* *//' -e '/^$/d'`
	$VERBOSE && echo "-> $check"
	case "$check"
	in
	    0a61)
		if [ "$ENDIAN" = big ]
		then
		    $MSG && echo "$HOST: little endian" >&2
		    return 1
		fi
		;;
	    610a)
		if [ "$ENDIAN" = little ]
		then
		    $MSG && echo "$HOST: big endian" >&2
		    return 1
		fi
		;;
	esac
    fi

    # The remainding tests are fixed on the PCP version
    # This information should be updated when required
    #

    if [ "$PCP" != "_" -o "$IPC" != "_" -o "$LIBPCP" != "_" ]
    then
    	probe=`$PROBE -h $HOST -v pmcd.version 2>/dev/null`
	if echo "$probe" | fgrep -s pmprobe:
	then
	    $MSG && echo "$HOST: Unable to pmprobe" >&2
	    return 1
	fi

        version=`echo $probe | $PCP_AWK_PROG -F'"' '{ print $2 }' | sed -e 's/\..*//'`

	# check pcp version
	#
	if [ "$PCP" != "_" -a "$PCP" != "$version" ]
	then
	    $MSG && echo "$HOST: PCP Version $PCP != $version" >&2
	    return 1
        fi

    	# check IPC protocol
    	#
    	if [ "$IPC" != "_" ]
    	then
	    case "$version"
	    in
	    	1)
		    if [ "$IPC" != 1 ]
		    then
		    	$MSG && echo "$HOST: IPC $IPC not supported" >&2
		    	return 1
		    fi
		    ;;
	    	2)
		    if [ "$IPC" != 1 -a "$IPC" != 2 ]
		    then
		     	$MSG && echo "$HOST: IPC $IPC not supported" >&2
		    	return 1
		    fi
		    ;;
		esac
    	fi

    	# check libpcp version
    	#
     	if [ "$LIBPCP" != "_" ]
    	then
	    case "$version"
	    in
	    	1)
		    if [ "$LIBPCP" != 1 ]
		    then
		    	$MSG && echo "$HOST: libpcp $LIBPCP not supported" >&2
		    	return 1
		    fi
		    ;;
	    	2)
		    if [ "$LIBPCP" != 1 -a "$LIBPCP" != 2 ]
		    then
		    	$MSG && echo "$HOST: libpcp $LIBPCP not supported" >&2
		    	return 1
		    fi
		    ;;
		esac
    	fi
    fi

    # check the metric value pairs
    if [ -s "$tmp.metrics" ]
    then
    cat $tmp.metrics \
    | while read metric op value
    do
        if pmprobe -h $HOST -v $metric >$tmp.probe 2>&1
        then
	    satisfies=`sed -e 's/"//g' $tmp.probe \
		        | $PCP_AWK_PROG '
BEGIN			{ op = "'"$op"'"; value="'"$value"'" }

                NF >=3 {
		    if ( $2 < 0 ) {
			print "0";
			exit;
		    }
		    # got a value
		    if (op == "=") {
			if ($3 == value)
			    print "1";
			else
			    print "0";
		    } 
		    else if (op == "<") {
			if ($3 < value)
			    print "1";
			else
			    print "0";
		    }
		    else if (op == ">") {
			if ($3 > value)
			    print "1";
			else
			    print "0";
		    }
		    else {
			    print "2";
		    }
		    exit;
		}
		{ print "0" }'`
	    if [ $satisfies -ne 1 ]
	    then
		$MSG && echo "$HOST: does not satisfy predicate $metric $op $value" >&2
		return 1
	    fi
	else
	    $MSG && echo "$HOST: does not satisfy predicate $metric $op $value" >&2
	    return 1
        fi
    done
    [ $? -eq 1 ] && return 1
    fi

    return 0
}


# Go thru table of hosts and see which meet the
# given criteria and return either the first one
# or a list of them if need be.
#

# set defaults
AGENT="_"
BINFMT="_"
IRIX="_"
LICENSE="_"
PROC="_"
IPC="_"
LIBPCP="_"
PCP="_"
SYSTEM="_"
ENDIAN="_"

PRIMARY=false
LOCAL=false
LIST=true
MSG=false
COUNT=0
VERBOSE=false

while getopts "a:b:De:h:i:l:Lm:n:Pp:s:v:V" c
do
    case $c
    in
	a)
	    AGENT=$OPTARG
	    ;;
	b)
	    BINFMT=$OPTARG
	    ;;
	D)
	    MSG=true
	    ;;
	e)
	    ENDIAN=$OPTARG
	    case "$ENDIAN"
	    in
		big|little)
		    ;;
		small)	# synonym for little
		    ENDIAN=little
		    ;;
		*)
		    echo "$0: Illegal endianess $ENDIAN" >&2
		    _usage
		    ;;
	    esac
	    ;;
	h)
	    HOSTS=$OPTARG
	    if [ ! -f $OPTARG ]
	    then
	        echo "$0: Cannot open $OPTARG" >&2
		_usage
	    fi
	    ;;
	i)
	    IRIX=$OPTARG
	    ;;
	l)
	    LICENSE=$OPTARG
	    ;;
	L)
	    LOCAL=true
	    ;;
	m)
	    metric=`echo $OPTARG | sed -e 's/[ 	]*//' -e 's/[=<>].*//'`
	    value=`echo $OPTARG | sed -e 's/[ 	]*//' -e 's/.*[=<>]//'`
	    op=`echo $OPTARG | sed -e 's/[ 	]*//' -e "s/$metric//" -e "s/$value//"`
	    if [ "X$op" != "X<" -a "X$op" != "X>" -a "X$op" != "X=" ]
	    then 
		echo "$0: Illegal metric argument: $OPTARG" >&2
		_usage
	    fi
	    echo "$metric $op $value" >> $tmp.metrics
	    $MSG && echo "---tmp.metrics---" >&2
	    $MSG && cat $tmp.metrics >&2
	    ;;
	    
	n)
	    COUNT=$OPTARG
	    if [ $COUNT -eq 1 ]
	    then
	    	LIST=false
	    fi
	    ;;
	P)
	    PRIMARY=true
	    ;;
	p)
	    PROC=$OPTARG
	    ;;
	s)
	    SYSTEM=$OPTARG
	    ;;
	v)
	    ITEM=`echo $OPTARG | sed -e 's/[ 	]*//' -e 's/=.*//'`
	    VERS=`echo $OPTARG | sed -e 's/[ 	]*//' -e 's/.*=//'`
	    case "$ITEM"
	    in
		"ipc"|"IPC")
		    IPC=$VERS
		    ;;
		"libpcp"|"LIBPCP")
		    LIBPCP=$VERS
		    ;;
		"pcp"|"PCP")
		    PCP=$VERS
		    ;;
		*)
		    echo "$0: Illegal item $ITEM" >&2
		    _usage
	    esac
	    if [ "$VERS" -ne 1 -a "$VERS" -ne 2 ]
	    then
	        echo "$0: Illegal value $VERS for item $ITEM, expected 1 or 2" >&2
		_usage
	    fi
	    ;;

	V)
	    VERBOSE=true
	    ;;

	*)
	    _usage
	    ;;
    esac
done
	
# Verify the options
#

err=0

if [ "$BINFMT" != "_" -a "$BINFMT" != 32 -a "$BINFMT" != 64 ]
then
    echo "$0: -b option takes 32 or 64" >&2
    err=1
fi

if [ "$IRIX" != "_" -a "$IRIX" != 5.3 -a "$IRIX" != 6.2 -a "$IRIX" != 6.3 -a \
     "$IRIX" != 6.4 -a "$IRIX" != 6.5 ]
then
    echo "$0: -i option takes 5.3, 6.2, 6.3, 6.4 or 6.5" >&2
    err=1
fi

if [ "$LICENSE" != "_" -a "$LICENSE" != "none" -a "$LICENSE" != "full" -a \
     "$LICENSE" != "web" ]
then
    echo "$0: -l option takes none, full or web" >&2
    err=1
fi

if [ "$PROC" != "_" -a "$PROC" != "multi" -a "$PROC" != "single" ]
then
    echo "$0: -p options takes multi or single" >&2
    err=1
fi

if [ $err -eq 1 ]
then
    _usage
    exit 1
fi

# Use qa_hosts file if environment variable $QA_HOSTS is not set (or null)
#
if [ -z "$QA_HOSTS" ]
then
    if [ ! -f $HOSTS ]
    then
	if make $HOSTS >$tmp.make.out 2>&1
	then
	    :
	else
	    cat $tmp.make.out >&2
	    echo "$0: Unable to make \"$HOSTS\"" >&2
	    exit 1
	fi
    fi
    QA_HOSTS=`cat $HOSTS`
fi

# Remove the localhost if requested
#
if $LOCAL
then
    localhost=`hostname | sed -e 's/\..*//'`
    QA_HOSTS=`echo $QA_HOSTS | sed \
      -e 's/$/ /' \
      -e "s/$localhost\.[^ ]* //g" \
      -e "s/$localhost //g"`
fi

$MSG && ( echo "Checking hosts:"; echo "$QA_HOSTS"; echo ) >&2

# Iterate through hosts
#

i=0
for HOST in $QA_HOSTS
do
    if _checkpmcdhost $HOST $AGENT $BINFMT $IRIX $LICENSE $PRIMARY $PROC $IPC $LIBPCP $PCP $MSG $SYSTEM $ENDIAN
    then
	if $LIST
	then
	    if $MSG
	    then
	        echo "-> $HOST" >&2
	    else
		echo -n "$HOST "
	    fi
	else
	    echo "$HOST"
	fi
        i=`expr $i + 1`
    fi

    if [ $COUNT -gt 0 -a $i -ge $COUNT ]
    then
        break
    fi
done

# if been using \c then do final \n
#

$LIST && echo

if [ $i -lt $COUNT ]
then
    echo "$0: ERROR: unable to get $COUNT host(s) with options: \"$@\"" >&2
    exit
fi

status=0
exit 
